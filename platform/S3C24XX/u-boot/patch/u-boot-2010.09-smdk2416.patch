diff -NBbur u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/config.mk u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/config.mk
--- u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/config.mk	2011-09-01 15:16:04.000000000 +0800
@@ -0,0 +1,33 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8 \
+	-msoft-float -mfloat-abi=soft
+#PLATFORM_CPPFLAGS += -march=armv4t
+# =========================================================================
+#
+# Supply options according to compiler version
+#
+# =========================================================================
+#PLATFORM_CPPFLAGS +=$(call cc-option,-mapcs-32,-mabi=apcs-gnu)
+PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,))
diff -NBbur u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/cpu.c u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/cpu.c
--- u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/cpu.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/cpu.c	2011-09-01 16:11:26.000000000 +0800
@@ -0,0 +1,247 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * CPU specific code
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/arch/s3c2416.h>
+
+extern void cleanFlushDCache(void);
+
+/* read co-processor 15, register #1 (control register) */
+static unsigned long read_p15_c1 (void)
+{
+	unsigned long value;
+
+	__asm__ __volatile__(
+		"mrc	p15, 0, %0, c1, c0, 0   @ read control reg\n"
+		: "=r" (value)
+		:
+		: "memory");
+
+#ifdef MMU_DEBUG
+	printf ("p15/c1 is = %08lx\n", value);
+#endif
+	return value;
+}
+
+/* write to co-processor 15, register #1 (control register) */
+static void write_p15_c1 (unsigned long value)
+{
+#ifdef MMU_DEBUG
+	printf ("write %08lx to p15/c1\n", value);
+#endif
+	__asm__ __volatile__(
+		"mcr	p15, 0, %0, c1, c0, 0   @ write it back\n"
+		:
+		: "r" (value)
+		: "memory");
+
+	read_p15_c1 ();
+}
+
+static void cp_delay (void)
+{
+	volatile int i;
+
+	/* copro seems to need some delay between reading and writing */
+	for (i = 0; i < 100; i++);
+}
+
+/* See also ARM926EJ-S Technical Reference Manual */
+#define C1_MMU		(1<<0)		/* mmu off/on */
+#define C1_ALIGN	(1<<1)		/* alignment faults off/on */
+#define C1_DC		(1<<2)		/* dcache off/on */
+
+#define C1_BIG_ENDIAN	(1<<7)		/* big endian off/on */
+#define C1_SYS_PROT	(1<<8)		/* system protection */
+#define C1_ROM_PROT	(1<<9)		/* ROM protection */
+#define C1_IC		(1<<12)		/* icache off/on */
+#define C1_HIGH_VECTORS	(1<<13)		/* location of vectors: low/high addresses */
+
+int arch_cpu_init (void)
+{
+	/*
+	 * setup up stacks if necessary
+	 */
+#ifdef CONFIG_USE_IRQ
+#ifdef CONFIG_MEMORY_UPPER_CODE
+	IRQ_STACK_START = _armboot_start + CFG_UBOOT_SIZE - CONFIG_SYS_MALLOC_LEN - CFG_STACK_SIZE - 4;
+#else
+	IRQ_STACK_START = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4;
+#endif
+
+	FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;
+#endif
+
+	return 0;
+}
+
+/*
+ * Before Kernel boots
+ *
+ * 1. IRQ & FIQ must be disabled
+ * 2. CPU must be in SVC mode.
+ * 3. MMU must be off
+ * 4. D-cache must be off and not contain any stale data.
+ *
+ */
+int cleanup_before_linux (void)
+{
+	/*
+	 * this function is called just before we call linux
+	 * it prepares the processor for linux
+	 *
+	 * we turn off caches etc ...
+	 */
+
+	unsigned long i;
+
+	disable_interrupts ();
+
+	/* turn off I/D-cache */
+	asm ("mrc p15, 0, %0, c1, c0, 0":"=r" (i));
+	i &= ~(C1_DC | C1_IC);
+	asm ("mcr p15, 0, %0, c1, c0, 0": :"r" (i));
+
+	/* flush I/D-cache */
+	i = 0;
+	asm ("mcr p15, 0, %0, c7, c7, 0": :"r" (i));
+
+	return (0);
+}
+
+void check_cpu_clock (void)
+{
+	uint i;
+	uint j = 0;
+	uint cnt, dat;
+	printf("clock test...\n");
+
+	WTCON_REG = 0x00000000;
+	WTCNT_REG = 0x0000ffff;
+	WTDAT_REG = 0x0000ffff;
+	WTCON_REG = 0x00000038;
+
+	for (i=0;i<16*1024*1024;i++) {
+		j+=i;
+	}
+
+	cnt = WTCNT_REG;
+	dat = WTDAT_REG;
+	printf("%u, %08x, %08x, %d\n", j, cnt, dat, dat-cnt);
+}
+
+int do_clock_test (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	check_cpu_clock();
+
+	return (0);
+}
+
+/*
+ * reset the cpu by setting up the watchdog timer and let him time out
+ */
+void reset_cpu(ulong ignored)
+{
+	printf("reset... \n\n\n");
+
+	WTCON_REG = 0x00000000;
+	WTCNT_REG = 0x00000001;
+	WTDAT_REG = 0x0;
+	WTCON_REG = 0x00000021;
+
+	/* loop forever and wait for reset to happen */
+	while (1) {
+		if (serial_tstc()) {
+			serial_getc();
+			break;
+		}
+	}
+ 	/*NOTREACHED*/
+}
+
+int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	disable_interrupts ();
+	reset_cpu (0);
+
+	/*NOTREACHED*/
+	return (0);
+}
+
+void icache_enable (void)
+{
+	ulong reg;
+
+	reg = read_p15_c1 ();		/* get control reg. */
+	cp_delay ();
+	write_p15_c1 (reg | C1_IC);
+}
+
+void icache_disable (void)
+{
+	ulong reg;
+
+	reg = read_p15_c1 ();
+	cp_delay ();
+	write_p15_c1 (reg & ~C1_IC);
+}
+
+int icache_status (void)
+{
+	return (read_p15_c1 () & C1_IC) != 0;
+}
+
+void dcache_enable (void)
+{
+	ulong reg;
+
+	reg = read_p15_c1 ();		/* get control reg. */
+	cp_delay ();
+	write_p15_c1 (reg | C1_DC);
+}
+
+void dcache_disable (void)
+{
+	ulong reg;
+
+	cleanFlushDCache();
+
+	reg = read_p15_c1 ();
+	cp_delay ();
+	write_p15_c1 (reg & ~C1_DC);
+}
+
+int dcache_status (void)
+{
+	return (read_p15_c1 () & C1_DC) != 0;
+}
+
diff -NBbur u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/interrupts.c u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/interrupts.c
--- u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/interrupts.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/interrupts.c	2011-09-01 16:10:21.000000000 +0800
@@ -0,0 +1,313 @@
+/*
+ * (C) Copyright 2003
+ * Texas Instruments <www.ti.com>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * (C) Copyright 2002-2004
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * (C) Copyright 2004
+ * Philippe Robin, ARM Ltd. <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/proc-armv/ptrace.h>
+#include <asm/arch/s3c2416.h>
+
+extern ulong get_PCLK(void);
+
+#ifdef CONFIG_USE_IRQ
+/* enable IRQ interrupts */
+void enable_interrupts(void)
+{
+	unsigned long temp;
+	__asm__ __volatile__("mrs %0, cpsr\n" "bic %0, %0, #0x80\n" "msr cpsr_c, %0":"=r"(temp)
+			     ::"memory");
+}
+
+
+/*
+ * disable IRQ/FIQ interrupts
+ * returns true if interrupts had been enabled before we disabled them
+ */
+int disable_interrupts(void)
+{
+	unsigned long old, temp;
+	__asm__ __volatile__("mrs %0, cpsr\n"
+			     "orr %1, %0, #0xc0\n" "msr cpsr_c, %1":"=r"(old), "=r"(temp)
+			     ::"memory");
+	return (old & 0x80) == 0;
+}
+#else
+void enable_interrupts(void)
+{
+	return;
+}
+int disable_interrupts(void)
+{
+	return 0;
+}
+#endif
+
+
+void bad_mode(void)
+{
+	panic("Resetting CPU ...\n");
+	reset_cpu(0);
+}
+
+void show_regs(struct pt_regs *regs)
+{
+	unsigned long flags;
+	const char *processor_modes[] = {
+		"USER_26", "FIQ_26", "IRQ_26", "SVC_26",
+		"UK4_26", "UK5_26", "UK6_26", "UK7_26",
+		"UK8_26", "UK9_26", "UK10_26", "UK11_26",
+		"UK12_26", "UK13_26", "UK14_26", "UK15_26",
+		"USER_32", "FIQ_32", "IRQ_32", "SVC_32",
+		"UK4_32", "UK5_32", "UK6_32", "ABT_32",
+		"UK8_32", "UK9_32", "UK10_32", "UND_32",
+		"UK12_32", "UK13_32", "UK14_32", "SYS_32",
+	};
+
+	flags = condition_codes(regs);
+
+	printf("pc : [<%08lx>]	   lr : [<%08lx>]\n"
+	       "sp : %08lx  ip : %08lx	 fp : %08lx\n",
+	       instruction_pointer(regs), regs->ARM_lr, regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
+	printf("r10: %08lx  r9 : %08lx	 r8 : %08lx\n", regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
+	printf("r7 : %08lx  r6 : %08lx	 r5 : %08lx  r4 : %08lx\n",
+	       regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
+	printf("r3 : %08lx  r2 : %08lx	 r1 : %08lx  r0 : %08lx\n",
+	       regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
+	printf("Flags: %c%c%c%c",
+	       flags & CC_N_BIT ? 'N' : 'n',
+	       flags & CC_Z_BIT ? 'Z' : 'z',
+	       flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
+	printf("  IRQs %s  FIQs %s  Mode %s%s\n",
+	       interrupts_enabled(regs) ? "on" : "off",
+	       fast_interrupts_enabled(regs) ? "on" : "off",
+	       processor_modes[processor_mode(regs)], thumb_mode(regs) ? " (T)" : "");
+}
+
+void do_undefined_instruction(struct pt_regs *pt_regs)
+{
+	printf("undefined instruction\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_software_interrupt(struct pt_regs *pt_regs)
+{
+	printf("software interrupt\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_prefetch_abort(struct pt_regs *pt_regs)
+{
+	printf("prefetch abort\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_data_abort(struct pt_regs *pt_regs)
+{
+	printf("data abort\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_not_used(struct pt_regs *pt_regs)
+{
+	printf("not used\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_fiq(struct pt_regs *pt_regs)
+{
+	printf("fast interrupt request\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_irq(struct pt_regs *pt_regs)
+{
+	printf("interrupt request\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+/*
+ * timer without interrupts
+ */
+int timer_load_val = 0;
+static ulong timestamp;
+static ulong lastdec;
+
+int interrupt_init(void)
+{
+	S3C24X0_TIMERS *const timers = S3C24X0_GetBase_TIMERS();
+
+	/* use PWM Timer 4 because it has no output */
+	/* prescaler for Timer 4 is 16 */
+	timers->TCFG0 = 0x0f00;
+	if (timer_load_val == 0) {
+		/*
+		 * for 10 ms clock period @ PCLK with 4 bit divider = 1/2
+		 * (default) and prescaler = 16. Should be 10390
+		 * @33.25MHz and 15625 @ 50 MHz
+		 */
+		timer_load_val = get_PCLK() / (2 * 16 * 100);
+	}
+
+	/* load value for 10 ms timeout */
+	lastdec = timers->TCNTB4 = timer_load_val;
+	/* auto load, manual update of Timer 4 */
+	timers->TCON = (timers->TCON & ~0x00700000) | 0x00600000;
+	/* auto load, start Timer 4 */
+	timers->TCON = (timers->TCON & ~0x00700000) | 0x00500000;
+	timestamp = 0;
+
+	return (0);
+}
+
+/* macro to read the 16 bit timer */
+static inline ulong READ_TIMER(void)
+{
+	S3C24X0_TIMERS *const timers = S3C24X0_GetBase_TIMERS();
+
+	return (timers->TCNTO4 & 0xffff);
+}
+
+void reset_timer(void)
+{
+	reset_timer_masked();
+}
+
+ulong get_timer(ulong base)
+{
+	return get_timer_masked() - base;
+}
+
+void set_timer(ulong t)
+{
+	timestamp = t;
+}
+
+void udelay(unsigned long usec)
+{
+	ulong tmo, tmp;
+
+	if (usec >= 1000) {		/* if "big" number, spread normalization to seconds */
+		tmo = usec / 1000;	/* start to normalize for usec to ticks per sec */
+		tmo *= CONFIG_SYS_HZ;		/* find number of "ticks" to wait to achieve target */
+		tmo /= 1000;		/* finish normalize. */
+	}
+	else {				/* else small number, don't kill it prior to HZ multiply */
+		tmo = usec * CONFIG_SYS_HZ;
+		tmo /= (1000 * 1000);
+	}
+
+	tmp = get_timer(0);		/* get current timestamp */
+	if ((tmo + tmp + 1) < tmp)	/* if setting this fordward will roll time stamp */
+		reset_timer_masked();	/* reset "advancing" timestamp to 0, set lastdec value */
+	else
+		tmo += tmp;		/* else, set advancing stamp wake up time */
+
+	while (get_timer_masked()<tmo)	/* loop till event */
+		 /*NOP*/;
+}
+
+void reset_timer_masked(void)
+{
+	/* reset time */
+	lastdec = READ_TIMER();
+	timestamp = 0;
+}
+
+ulong get_timer_masked(void)
+{
+	ulong now = READ_TIMER();
+
+	if (lastdec >= now) {
+		/* normal mode */
+		timestamp += lastdec - now;
+	}
+	else {
+		/* we have an overflow ... */
+		timestamp += lastdec + timer_load_val - now;
+	}
+	lastdec = now;
+
+	return timestamp;
+}
+
+void udelay_masked(unsigned long usec)
+{
+	ulong tmo;
+	ulong endtime;
+	signed long diff;
+
+	if (usec >= 1000) {
+		tmo = usec / 1000;
+		tmo *= (timer_load_val * 100);
+		tmo /= 1000;
+	}
+	else {
+		tmo = usec * (timer_load_val * 100);
+		tmo /= (1000 * 1000);
+	}
+
+	endtime = get_timer_masked() + tmo;
+
+	do {
+		ulong now = get_timer_masked();
+		diff = endtime - now;
+	} while (diff >= 0);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+ulong get_tbclk(void)
+{
+	return (ulong)(timer_load_val * 100);
+}
+
diff -NBbur u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/Makefile u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/Makefile
--- u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/Makefile	2011-09-02 08:33:52.000000000 +0800
@@ -0,0 +1,46 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(CPU).a
+
+COBJS-$(CONFIG_USE_IRQ) += interrupts.o
+COBJS-y += cpu.o mmu_table.o nand_cp.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS-y))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -NBbur u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/mmu_table.c u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/mmu_table.c
--- u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/mmu_table.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/mmu_table.c	2011-09-01 15:16:04.000000000 +0800
@@ -0,0 +1,71 @@
+/*
+ * $Id: mmu_table.c,v 1.3 2008/11/08 02:38:33 scsuh Exp $
+ *
+ * (C) Copyright 2008 Samsung Electronics
+ *       SeungChull, Suh <sc.suh@samsung.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This function can make mmu_table on run_time.
+ * It takes only trivial time to make table. Thus using this function
+ * is recommended not using static mmu_table in lowlevel_init.S
+ * To enable this functionality add definitions of
+ * CONFIG_BUILD_MMU_TABLE_RUNTIME and MMU_TABLE_BASE on your config file.
+ * refering to include/configs/smdk2450.h will be helpful.
+ *
+ * By scsuh.
+ */
+
+
+#include <common.h>
+
+#ifdef CONFIG_BUILD_MMU_TABLE_RUNTIME
+#define SECTION_ENTRY(base,ap,d,c,b) \
+	((base << 20)|(ap<<10)|(d<<5)|(1<<4)|(c<<3)|(b<<2)|(1<<1))
+
+void make_mmu_table (void)
+{
+	int i;
+	uint *addr = (uint*)MMU_TABLE_BASE;
+
+	/* 1:1 mapping */
+	for (i=(MMU_IO_AREA_START>>20); i<(MMU_RESERVED1_START>>20); i++) {
+		addr[i] = SECTION_ENTRY(i,3,0,0,0);
+	}
+
+	/* disabled */
+	for (i=(MMU_RESERVED1_START>>20); i<(MMU_MEM_AREA_START>>20); i++) {
+		addr[i] = 0x00000000;
+	}
+
+	/* mapping system memory to 0xc0000000 */
+	for (i=(MMU_MEM_AREA_START>>20); i<(MMU_RESERVED2_START>>20); i++) {
+		addr[i] = SECTION_ENTRY((i-(0xc00-0x300)),3,0,1,1);
+	}
+
+	/* disabled */
+	for (i=(MMU_RESERVED2_START>>20); i<0x1000; i++) {
+		addr[i] = 0x00000000;
+	}
+}
+
+#endif
+
diff -NBbur u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/nand_cp.c u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/nand_cp.c
--- u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/nand_cp.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/nand_cp.c	2011-09-01 16:12:08.000000000 +0800
@@ -0,0 +1,150 @@
+/*
+ * $Id: nand_cp.c,v 1.1 2006/12/06 01:30:18 scsuh Exp $
+ *
+ * (C) Copyright 2006 Samsung Electronics
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * You must make sure that all functions in this file are designed
+ * to load only U-Boot image.
+ *
+ * So, DO NOT USE in common read.
+ *
+ * By scsuh.
+ */
+
+
+#include <common.h>
+
+#ifdef CONFIG_S3C24XX
+#include <asm/io.h>
+#include <linux/mtd/nand.h>
+#include <asm/arch/s3c2416.h>
+
+/*
+ * address format
+ *              17 16         9 8            0
+ * --------------------------------------------
+ * | block(12bit) | page(5bit) | offset(9bit) |
+ * --------------------------------------------
+ */
+
+static int nandll_read_page (uchar *buf, ulong addr, int large_block)
+{
+        int i;
+	int page_size = 512;
+
+	if (large_block)
+		page_size = 2048;
+
+        NAND_ENABLE_CE();
+
+        NFCMD_REG = NAND_CMD_READ0;
+
+        /* Write Address */
+        NFADDR_REG = 0;
+
+	if (large_block)
+	        NFADDR_REG = 0;
+
+        NFADDR_REG = (addr) & 0xff;
+        NFADDR_REG = (addr >> 8) & 0xff;
+        NFADDR_REG = (addr >> 16) & 0xff;
+
+	if (large_block)
+		NFCMD_REG = NAND_CMD_READSTART;
+
+        NF_TRANSRnB();
+
+	/* for compatibility(2460). u32 cannot be used. by scsuh */
+	for(i=0; i < page_size; i++) {
+                *buf++ = NFDATA8_REG;
+        }
+
+        NAND_DISABLE_CE();
+        return 0;
+}
+
+/*
+ * Read data from NAND.
+ */
+static int nandll_read_blocks (ulong dst_addr, ulong size, int large_block)
+{
+        uchar *buf = (uchar *)dst_addr;
+        int i;
+	uint page_shift = 9;
+
+	if (large_block)
+		page_shift = 11;
+
+        /* Read pages */
+        for (i = 0; i < (0x3c000>>page_shift); i++, buf+=(1<<page_shift)) {
+                nandll_read_page(buf, i, large_block);
+        }
+
+        return 0;
+}
+
+int copy_uboot_to_ram (void)
+{
+	int large_block = 0;
+	int i;
+	vu_char id;
+
+        NAND_ENABLE_CE();
+        NFCMD_REG = NAND_CMD_READID;
+        NFADDR_REG =  0x00;
+
+	/* wait for a while */
+        for (i=0; i<200; i++);
+	id = NFDATA8_REG;
+	id = NFDATA8_REG;
+
+	if (id > 0x80)
+		large_block = 1;
+
+	/* read NAND Block.
+	 * 128KB ->240KB because of U-Boot size increase. by scsuh
+	 * So, read 0x3c000 bytes not 0x20000(128KB).
+	 */
+	return nandll_read_blocks(CFG_PHY_UBOOT_BASE, 0x3c000, large_block);
+}
+
+#if 0
+//int NF8_ReadPage_Adv(unsigned int block,unsigned int page,unsigned char *buffer) // Advanced nand by MGR
+#define NF8_ReadPage_Adv(a,b,c)	(((int(*)(uint, uint, uchar*))(*((uint *)(0x40004000 + 0x4))))(a,b,c))
+
+void nand_bl2_copy(void)
+{
+	int block, page;
+	volatile unsigned int *base = 0x33e00000;
+
+	for (block = 0; block < 2; block++) {
+		for (page = 0; page < 64; page++) {
+			NF8_ReadPage_Adv(block, page, base);
+			base += 2048;
+		}
+	}
+
+}
+#endif
+#endif
+
diff -NBbur u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/s3c2416/config.mk u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/s3c2416/config.mk
--- u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/s3c2416/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/s3c2416/config.mk	2011-09-01 15:16:04.000000000 +0800
@@ -0,0 +1,24 @@
+#
+# (C) Copyright 2006
+# Seung-Chull, Suh, Samsung Electronics, <sc.suh@samsung.com>
+#
+# derived from config.mk made by Denx Software
+# modified to support S3C SoCs from Samsung.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+PLATFORM_CPPFLAGS += -march=armv4t
diff -NBbur u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/s3c2416/cpu_init.S u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/s3c2416/cpu_init.S
--- u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/s3c2416/cpu_init.S	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/s3c2416/cpu_init.S	2011-09-01 16:13:02.000000000 +0800
@@ -0,0 +1,220 @@
+/*
+ *  cpu/s3c24xx/s3c2416/cpu_init.S
+ *
+ *  Memory controller and cache code for U-Boot
+ *
+ *  Copyright (c) 2006,  Samsung Electronics
+ *  All rights reserved.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * $Id: cpu_init.S,v 1.2 2008/03/24 12:27:06 boyko Exp $
+ */
+
+#include <config.h>
+#include <asm/arch/s3c2416.h>
+
+/*
+ * sdr_ram_asm_init: Initialize memory controller
+ *
+ * r0: input argument that contains memory setting value
+ * r1: BANKCON1 Value
+ * r2: BANKCON1 Value Modified
+ * r3: Temp value
+ * r4: MEMCON Base Address
+ * r5-r11: setting value
+ *
+ */
+
+	.globl sdr_ctrl_asm_init
+sdr_ctrl_asm_init:
+	mov	r13, #2
+
+	/* Set GPK port when using x32 bus width. */
+	ldr	r2,=GPKCON_REG
+	ldr	r1,=0xaaaaaaaa	@ set Sdata[31:16]
+	str	r1, [r2]
+
+	/* read setting value from structure */
+	ldr	r4, =ELFIN_MEMCTL_BASE
+	ldmia	r0!, {r5-r11}
+	stmia	r4!, {r5-r9}
+
+#ifdef CONFIG_PM
+	/* compare INFORM2 register to confirm the dram type*/
+	ldr	r1, =INFORM2_REG
+	ldr	r1, [r1]
+	ldr	r2, =0xDA
+	cmp	r2, r1
+
+	ldreq	r4, =ELFIN_MEMCTL_BASE
+	beq	1002f
+#endif
+
+1000:	ldr	r4, =ELFIN_MEMCTL_BASE
+
+	ldr	r1, [r4, #BANKCON1_OFFSET]
+	ldr	r2, =0x40000000			/* DDR DSQInDLL Value Setting */
+	orr	r1, r1, r2
+	bic	r1, r1, #INIT_MASK
+
+	/* Step 1: issue PALL */
+	orr	r2, r1, #INIT_PALL
+	str	r2, [r4, #BANKCON1_OFFSET]
+
+	/* Step 2: write 0xff into the refresh timer */
+	mov	r3, #0xff
+	str	r3, [r4, #REFRESH_OFFSET]
+
+	/* Step 3: wait more than 120 clk */
+	mov	r3, #0x100
+1:	subs	r3, r3, #1
+	bne	1b
+
+	/* Step 4: issue MRS */
+	orr	r2, r1, #INIT_MRS
+	str	r2, [r4, #BANKCON1_OFFSET]
+
+	/* Step 5: nornal operation value into the refresh timer */
+	str	r9, [r4, #REFRESH_OFFSET]
+
+	/* Step 6: issue EMRS */
+	orr	r2, r1, #INIT_EMRS
+	str	r2, [r4, #BANKCON1_OFFSET]
+
+	/* Step 7: Normal Mode */
+	orr	r2, r1, #INIT_NORMAL
+	str	r2, [r4, #BANKCON1_OFFSET]
+
+	ldr	r6, =(PHYS_SDRAM_1+0x4)
+	ldr	r7, =0x24564236
+	swp	r8, r7, [r6]
+	swp	r5, r8, [r6]
+	cmp	r7, r5
+	beq	1001f
+
+	sub	r13, r13, #1
+	cmp	r13, #0
+	beq	1004f
+
+1002:	stmia	r4!, {r10-r11}
+	b	1000b
+
+/* boyko : Memory Type DDR2 */
+1004:	ldr	r4, =ELFIN_MEMCTL_BASE
+
+	/* Step 1: BANKCFG Setting */
+	ldr	r2, =CFG_BANK_CFG_VAL_DDR2
+	str	r2, [r4, #BANKCFG_OFFSET]
+
+	ldr	r1, =0x44000040
+	str	r1, [r4, #BANKCON1_OFFSET]
+
+	/* Step 2: BANKCON2 Setting */
+	ldr	r2, =CFG_BANK_CON2_VAL_DDR2
+	str	r2, [r4, #BANKCON2_OFFSET]
+
+	/* Step 3: issue PALL */
+	orr	r2, r1, #INIT_PALL
+	str	r2, [r4, #BANKCON1_OFFSET]
+
+	/* Step 4: Issue a EMRS2 command */
+	ldr	r2, =0x80000000
+	str	r2, [r4, #BANKCON3_OFFSET]
+
+	orr	r2, r1, #INIT_EMRS
+	str	r2, [r4, #BANKCON1_OFFSET]
+
+	/* Step 5: Issue a EMRS3 command */
+	ldr	r2, =0xc0000000
+	str	r2, [r4, #BANKCON3_OFFSET]
+
+	orr	r2, r1, #INIT_EMRS
+	str	r2, [r4, #BANKCON1_OFFSET]
+
+	/* Step 6: Issue a EMRS1 command */
+	ldr	r2, =0x44000000
+	str	r2, [r4, #BANKCON3_OFFSET]
+
+	orr	r2, r1, #INIT_EMRS
+	str	r2, [r4, #BANKCON1_OFFSET]
+
+	/* Step 7: issue MRS */
+	ldr	r2, =0x44000130
+	str	r2, [r4, #BANKCON3_OFFSET]
+
+	orr	r2, r1, #INIT_MRS
+	str	r2, [r4, #BANKCON1_OFFSET]
+
+	/* Step 8: issue PALL */
+	orr	r2, r1, #INIT_PALL
+	str	r2, [r4, #BANKCON1_OFFSET]
+
+	/* Step 9: write 0xff into the refresh timer */
+	mov	r3, #0xff
+	str	r3, [r4, #REFRESH_OFFSET]
+
+	/* Step 10: wait more than 120 clk */
+	mov	r3, #0x100
+10:	subs	r3, r3, #1
+	bne	10b
+
+	/* Step 11: issue MRS */
+	ldr	r2, =0x44000030
+	str	r2, [r4, #BANKCON3_OFFSET]
+
+	orr	r2, r1, #INIT_MRS
+	str	r2, [r4, #BANKCON1_OFFSET]
+
+	/* Step 12: Issue a EMRS1 command */
+	ldr	r2, =0x47800030
+	str	r2, [r4, #BANKCON3_OFFSET]
+
+	orr	r2, r1, #INIT_EMRS
+	str	r2, [r4, #BANKCON1_OFFSET]
+
+	ldr	r2, =0x44000030
+	str	r2, [r4, #BANKCON3_OFFSET]
+
+	orr	r2, r1, #INIT_EMRS
+	str	r2, [r4, #BANKCON1_OFFSET]
+
+	/* Step 13: write 0x87 into the refresh timer */
+	mov	r3, #0x87
+	str	r3, [r4, #REFRESH_OFFSET]
+
+	/* Step 14: Normal Mode */
+	orr	r2, r1, #INIT_NORMAL
+	str	r2, [r4, #BANKCON1_OFFSET]
+/* boyko : END - Memory Type DDR2 */
+
+1001:	mov	pc, lr
+
+	.ltorg
+
+
+/* Below code is for ARM926EJS and ARM1026EJS */
+	.globl cleanDCache
+cleanDCache:
+	mrc	p15, 0, pc, c7, c10, 3	/* test/clean D-Cache */
+	bne	cleanDCache
+	mov	pc, lr
+
+	.globl cleanFlushDCache
+cleanFlushDCache:
+	mrc	p15, 0, pc, c7, c14, 3	/* test/cleanflush D-Cache */
+	bne	cleanFlushDCache
+	mov	pc, lr
+
+	.globl cleanFlushCache
+cleanFlushCache:
+	mrc	p15, 0, pc, c7, c14, 3	/* test/cleanflush D-Cache */
+	bne	cleanFlushCache
+	mcr	p15, 0, r0, c7, c5, 0	/* flush I-Cache */
+	mov	pc, lr
+
+	.ltorg
+
diff -NBbur u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/s3c2416/Makefile u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/s3c2416/Makefile
--- u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/s3c2416/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/s3c2416/Makefile	2011-09-01 15:16:04.000000000 +0800
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(SOC).a
+
+SOBJS	= cpu_init.o
+OBJS	= speed.o
+
+all:	.depend $(SOBJS) $(LIB)
+
+$(LIB):	 $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(SOBJS) $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -NBbur u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/s3c2416/speed.c u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/s3c2416/speed.c
--- u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/s3c2416/speed.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/s3c2416/speed.c	2011-09-01 16:13:37.000000000 +0800
@@ -0,0 +1,149 @@
+/*
+ * (C) Copyright 2001-2004
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, d.mueller@elsoft.ch
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* This code should work for both the S3C2400 and the S3C2410
+ * as they seem to have the same PLL and clock machinery inside.
+ * The different address mapping is handled by the s3c24xx.h files below.
+ */
+
+#include <common.h>
+#include <asm/arch/s3c2416.h>
+
+#define MPLL 0
+#define UPLL 1
+
+/* ------------------------------------------------------------------------- */
+/* NOTE: This describes the proper use of this file.
+ *
+ * CONFIG_SYS_CLK_FREQ should be defined as the input frequency of the PLL.
+ *
+ * get_FCLK(), get_HCLK(), get_PCLK() and get_UCLK() return the clock of
+ * the specified bus in HZ.
+ */
+/* ------------------------------------------------------------------------- */
+
+static ulong get_PLLCLK(int pllreg)
+{
+	ulong r, m, p, s;
+
+	if (pllreg == MPLL)
+		r = MPLLCON_REG;
+#if 0
+	else if (pllreg == UPLL)
+		r = UPLLCON_REG;
+#endif
+	else
+		hang();
+
+	m = ((r>>14) & 0x3ff);
+	p = ((r>>5) & 0x3f);
+	s = r & 0x7;
+
+	/* XXX: To Do calculate UPLL */
+
+	return (m * (CONFIG_SYS_CLK_FREQ / (p << s)));
+}
+
+/* return FCLK frequency */
+ulong get_FCLK(void)
+{
+	return(get_PLLCLK(MPLL));
+}
+
+/* return HCLK frequency */
+ulong get_HCLK(void)
+{
+	uint hclk_div = (CLKDIV0CON_REG & 0x3) + 1;
+	uint pre_div = ((CLKDIV0CON_REG>>4) & 0x3) + 1;
+
+	return get_FCLK()/(hclk_div * pre_div);
+}
+
+/* return PCLK frequency */
+ulong get_PCLK(void)
+{
+	return ((CLKDIV0CON_REG & 0x4) ? get_HCLK()/2 : get_HCLK());
+}
+
+/* return UCLK frequency */
+ulong get_UCLK(void)
+{
+	return (get_PLLCLK(UPLL));
+}
+
+/* return ARMCORE frequency */
+ulong get_ARMCLK(void)
+{
+	uint div_val = CLKDIV0CON_REG;
+	uint fclk = get_FCLK();
+	uint arm_clk = 0;
+
+	switch((div_val >> 9) & 0xf) {
+	case 0:
+		arm_clk = fclk;
+		break;
+
+	case 1:
+		arm_clk = fclk/2;
+		break;
+
+	case 2:
+		arm_clk = fclk/3;
+		break;
+
+	case 3:
+		arm_clk = fclk/4;
+		break;
+
+	case 5:
+		arm_clk = fclk/6;
+		break;
+
+	case 7:
+		arm_clk = fclk/8;
+		break;
+
+	case 13:
+		arm_clk = fclk/12;
+		break;
+
+	case 15:
+		arm_clk = fclk/16;
+		break;
+
+	}
+
+	return arm_clk;
+}
+
+int print_cpuinfo(void)
+{
+	printf("\nCPU:   S3C2416@%luMHz\n", get_ARMCLK()/1000000);
+	printf("       Fclk = %luMHz, Hclk = %luMHz, Pclk = %luMHz\n",
+			get_FCLK()/1000000, get_HCLK()/1000000, get_PCLK()/1000000);
+
+	return 0;
+}
diff -NBbur u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/start.S u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/start.S
--- u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/start.S	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/start.S	2011-09-01 15:16:04.000000000 +0800
@@ -0,0 +1,710 @@
+/*
+ *  cpu/s3c24xx/start.S
+ *
+ *  U-Boot - Startup Code for S3C24XX
+ *
+ *  Copyright (c) 2006,2007,2008  Samsung Electronics
+ *  All rights reserved.
+ *
+ *  Based on cpu/arm926ejs/start.S
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * $Id: start.S,v 1.7 2008/04/22 07:31:41 boyko Exp $
+ */
+
+/*
+ *  mod by sc.suh@samsung.com
+ *
+ *  Our U-Boot Memory Map with static mmu_table
+ *                                      (offset)
+ *       --------------------------     0x04000000
+ *       |     Stack     (512KB)  |
+ *       --------------------------     0x03f80000
+ *       |     Heap       (1MB)   |
+ *       --------------------------     0x03e80000
+ *       |     IRQ Stack  (4KB)   | <------------------------ if exists
+ *       --------------------------     0x03e70000
+ *       |     FIQ Stack  (4KB)   | <------------------------ if exists
+ *       --------------------------     0x03e60000
+ *       |     GBL       (128B)   |
+ *       --------------------------     0x03exxxxx
+ *       |     BSS and Reserved   |
+ *       --------------------------     0x03e40000
+ *       |     U-Boot    (256KB)  |
+ *       --------------------------     0x03e00000
+ *
+ *  Our U-Boot Memory Map with run-time mmu_table
+ *                                      (offset)
+ *       --------------------------     0x04000000
+ *       |     Stack     (256KB)  |
+ *       --------------------------     0x03fc0000
+ *       |     Heap       (1MB)   |
+ *       --------------------------     0x03ec0000
+ *       |     IRQ Stack  (4KB)   | <------------------------ if exists
+ *       --------------------------     0x03ec0000
+ *       |     FIQ Stack  (4KB)   | <------------------------ if exists
+ *       --------------------------     0x03eb0000
+ *       |     GBL       (128B)   |
+ *       --------------------------     0x03exxxxx
+ *       |     MMU Table (16KB)   |
+ *       --------------------------     0x03e9c000
+ *       |     BSS and Reserved   |
+ *       --------------------------     0x03e40000
+ *       |     U-Boot    (256KB)  |
+ *       --------------------------     0x03e00000
+ */
+
+#include <config.h>
+#include <version.h>
+#ifdef CONFIG_ENABLE_MMU
+#include <asm/proc/domain.h>
+#endif
+
+#ifndef CONFIG_ENABLE_MMU
+#ifndef CFG_PHY_UBOOT_BASE
+#define CFG_PHY_UBOOT_BASE	CFG_UBOOT_BASE
+#endif
+#endif
+
+
+/*
+ *************************************************************************
+ *
+ * Jump vector table as in table 3.1 in [1]
+ *
+ *************************************************************************
+ */
+
+
+.globl _start
+_start:
+	b	reset
+	ldr	pc, _undefined_instruction
+	ldr	pc, _software_interrupt
+	ldr	pc, _prefetch_abort
+	ldr	pc, _data_abort
+	ldr	pc, _not_used
+	ldr	pc, _irq
+	ldr	pc, _fiq
+
+_undefined_instruction:
+	.word undefined_instruction
+_software_interrupt:
+	.word software_interrupt
+_prefetch_abort:
+	.word prefetch_abort
+_data_abort:
+	.word data_abort
+_not_used:
+	.word not_used
+_irq:
+	.word irq
+_fiq:
+	.word fiq
+
+	.balignl 16,0xdeadbeef
+
+
+/*
+ *************************************************************************
+ *
+ * Startup Code (reset vector)
+ *
+ * do important init only if we don't start from memory!
+ * setup Memory and board specific bits prior to relocation.
+ * relocate armboot to ram
+ * setup stack
+ *
+ *************************************************************************
+ */
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+/*
+ * Below variable is very important because we use MMU in U-Boot.
+ * Without it, we cannot run code correctly before MMU is ON.
+ * by scsuh.
+ */
+_TEXT_PHY_BASE:
+	.word	CFG_PHY_UBOOT_BASE
+
+.globl _armboot_start
+_armboot_start:
+	.word _start
+
+/*
+ * These are defined in the board-specific linker script.
+ */
+.globl _bss_start
+_bss_start:
+	.word __bss_start
+
+.globl _bss_end
+_bss_end:
+	.word _end
+
+#ifdef CONFIG_USE_IRQ
+/* IRQ stack memory (calculated at run-time) */
+.globl IRQ_STACK_START
+IRQ_STACK_START:
+	.word	0x0badc0de
+
+/* IRQ stack memory (calculated at run-time) */
+.globl FIQ_STACK_START
+FIQ_STACK_START:
+	.word 0x0badc0de
+#endif
+
+
+/*
+ * the actual reset code
+ */
+
+reset:
+	/*
+	 * set the cpu to SVC32 mode
+	 */
+	mrs	r0,cpsr
+	bic	r0,r0,#0x1f
+	orr	r0,r0,#0xd3
+	msr	cpsr,r0
+
+#if defined(CONFIG_S3C2416)
+	/*
+	 * Retention IO power will be turen off whel sleep mode,
+	 * but, when wakeup process starts, User should write '1'
+	 * produce power on retention IO. PM check
+	 */
+	ldr	r0, =0x4c00006c
+	ldr	r1, =0x4c000064
+	ldr	r2, [r0]
+	tst 	r2, #0x8
+
+	ldreq	r2, [r1]
+	orreq	r2, r2, #0x10000  /* (1<<16) */
+	streq	r2, [r1]
+#endif
+
+	/*
+	 * we do sys-critical inits only at reboot,
+	 * not when booting from ram!
+	 */
+cpu_init_crit:
+	/*
+	 * flush v4 I/D caches
+	 */
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7, 0	/* flush v3/v4 cache */
+	mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */
+
+	/*
+	 * disable MMU stuff and caches
+	 */
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x00002300	/* clear bits 13, 9:8 (--V- --RS) */
+	bic	r0, r0, #0x00000087	/* clear bits 7, 2:0 (B--- -CAM) */
+	orr	r0, r0, #0x00000002	/* set bit 2 (A) Align */
+	orr	r0, r0, #0x00001000	/* set bit 12 (I) I-Cache */
+	mcr	p15, 0, r0, c1, c0, 0
+
+	/*
+	 * Go setup Memory and board specific bits prior to relocation.
+	 */
+	bl	lowlevel_init	/* go setup pll,mux,memory */
+
+	/* when we already run in ram, we don't need to relocate U-Boot.
+	 * and actually, memory controller must be configured before U-Boot
+	 * is running in ram.
+	 */
+check_boot_device:
+	ldr	r0, =0xff000fff
+	bic	r1, pc, r0		/* r0 <- current base addr of code */
+	ldr	r2, _TEXT_BASE		/* r1 <- original base addr in ram */
+	bic	r2, r2, r0		/* r0 <- current base addr of code */
+	cmp     r1, r2                  /* compare r0, r1                  */
+	beq     after_copy		/* r0 == r1 then skip flash copy   */
+
+	/* check boot device is nand or nor */
+	ldr	r0, =0x00000000
+	ldr	r3, [r0]
+	ldr	r1, =0xfffffffe
+	str	r1, [r0]
+
+	ldr	r2, [r0]
+	str	r3, [r0]
+	cmp	r1, r2
+
+#if defined(CONFIG_S3C2416)
+
+#if 1
+	b	nand_copy
+#else
+	beq	nand_copy
+#endif
+
+#else
+	beq	nand_copy
+#endif
+
+nand_copy:
+	mov	r0, #0x1000
+	bl	copy_from_nand
+
+after_copy:
+#ifdef CONFIG_ENABLE_MMU
+#ifdef CONFIG_BUILD_MMU_TABLE_RUNTIME
+	ldr	sp, _TEXT_PHY_BASE	/* setup temp stack pointer */
+	sub	sp, sp, #12
+	mov	fp, #0			/* no previous frame, so fp=0 */
+	bl	make_mmu_table
+#endif
+enable_mmu:
+	/* enable domain access */
+	ldr	r5, =0x0000ffff
+	mcr	p15, 0, r5, c3, c0, 0		@ load domain access register
+
+	/* Set the TTB register */
+#ifdef CONFIG_BUILD_MMU_TABLE_RUNTIME
+	ldr	r1, =MMU_TABLE_BASE
+#else
+	ldr	r0, _mmu_table_base
+	ldr	r1, =CFG_PHY_UBOOT_BASE
+	ldr	r2, =0xfff00000
+	bic	r0, r0, r2
+	orr	r1, r0, r1
+#endif
+	mcr	p15, 0, r1, c2, c0, 0
+
+	/* Enable the MMU */
+mmu_on:
+	mrc	p15, 0, r0, c1, c0, 0
+	orr	r0, r0, #1			/* Set CR_M to enable MMU */
+	mcr	p15, 0, r0, c1, c0, 0
+	nop
+	nop
+	nop
+	nop
+#endif
+
+	/* Set up the stack						    */
+stack_setup:
+#ifdef CONFIG_MEMORY_UPPER_CODE
+	ldr	sp, =(CFG_UBOOT_BASE + CFG_UBOOT_SIZE - 0xc)
+#else
+	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
+	sub	r0, r0, #CONFIG_SYS_MALLOC_LEN	/* malloc area                      */
+	sub	r0, r0, #CONFIG_SYS_GBL_DATA_SIZE /* bdinfo                        */
+#ifdef CONFIG_USE_IRQ
+	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
+#endif
+	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
+
+#endif
+
+clear_bss:
+	ldr	r0, _bss_start		/* find start of bss segment        */
+	ldr	r1, _bss_end		/* stop here                        */
+	mov 	r2, #0x00000000		/* clear                            */
+
+clbss_l:str	r2, [r0]		/* clear loop...                    */
+	add	r0, r0, #4
+	cmp	r0, r1
+	ble	clbss_l
+
+	ldr	pc, _start_armboot
+
+_start_armboot:
+	.word start_armboot
+
+#ifdef CONFIG_ENABLE_MMU
+#ifndef CONFIG_BUILD_MMU_TABLE_RUNTIME
+_mmu_table_base:
+	.word mmu_table
+#endif
+#endif
+
+#ifdef CONFIG_ONENAND
+temp_copy_onenand:
+	adr	r0, _start		/* r0 <- current position of code   */
+	ldr	r1, _TEXT_PHY_BASE	/* test if we run from flash or RAM */
+	ldr	r2, =0xbff
+
+1:	ldmia	r0!, {r3-r10}		/* copy from source address [r0]    */
+	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
+	cmp	r0, r2			/* until source end addreee [r2]    */
+	ble	1b
+
+	adr	r0, onenand_copy
+	ldr	r1, _TEXT_PHY_BASE
+	add	r0, r0, r1
+	mov	pc, r0
+
+	.ltorg
+#endif
+
+/*
+ * copy U-Boot to SDRAM and jump to ram (from NAND)
+ * r0: size to be compared
+ */
+	.globl copy_from_nand
+copy_from_nand:
+	mov	r10, lr		/* save return address */
+
+	mov	r9, r0
+	/* get ready to call C functions */
+	ldr	sp, _TEXT_PHY_BASE	/* setup temp stack pointer */
+	sub	sp, sp, #12
+	mov	fp, #0			/* no previous frame, so fp=0 */
+
+	mov	r9, #0x1000
+	bl	copy_uboot_to_ram
+
+	tst 	r0, #0x0
+	bne	copy_failed
+
+#if defined(CONFIG_S3C2416)
+
+/* Confirm Booting Status NAND Booting or iROM NAND*/
+
+	ldr	r6, =0x40008000
+	ldr	r7, =0x24564236
+	swp	r8, r7, [r6]
+	swp	r5, r8, [r6]
+	cmp	r7, r5
+
+/* If compare value is same between r7 and r5, Booting Device is iROM */
+
+	beq	444f
+
+	mov	r0, #0		/* NAND Booting */
+	b	555f
+444:
+	mov	r0, #0x40000000	/* iROM booting */
+
+#else
+	mov	r0, #0
+
+#endif
+
+555:
+	ldr	r1, _TEXT_PHY_BASE
+1:	ldr	r3, [r0], #4
+	ldr	r4, [r1], #4
+	teq	r3, r4
+	bne	compare_failed	/* not matched */
+	subs	r9, r9, #4
+	bne	1b
+
+4:	mov	lr, r10		/* all is OK */
+	mov	pc, lr
+
+copy_failed:
+	nop			/* copy from nand failed */
+	b	copy_failed
+compare_failed:
+	nop			/* compare failed */
+	b	compare_failed
+
+/*
+ * we assume that cache operation is done before. (eg. cleanup_before_linux())
+ * actually, we don't need to do anything about cache if not use d-cache in U-Boot
+ * So, in this function we clean only MMU. by scsuh
+ *
+ * void	theLastJump(void *kernel, int arch_num, uint boot_params);
+ */
+#ifdef CONFIG_ENABLE_MMU
+	.globl theLastJump
+theLastJump:
+	mov	r9, r0
+	ldr	r3, =0xfff00000
+	ldr	r4, _TEXT_PHY_BASE
+	adr	r5, phy_last_jump
+	bic	r5, r5, r3
+	orr	r5, r5, r4
+	mov	pc, r5
+phy_last_jump:
+	/*
+	 * disable MMU stuff
+	 */
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x00002300	/* clear bits 13, 9:8 (--V- --RS) */
+	bic	r0, r0, #0x00000087	/* clear bits 7, 2:0 (B--- -CAM) */
+	orr	r0, r0, #0x00000002	/* set bit 2 (A) Align */
+	orr	r0, r0, #0x00001000	/* set bit 12 (I) I-Cache */
+	mcr	p15, 0, r0, c1, c0, 0
+
+	mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */
+
+	mov	r0, #0
+	mov	pc, r9
+#endif
+
+/*
+ *************************************************************************
+ *
+ * Interrupt handling
+ *
+ *************************************************************************
+ */
+
+@
+@ IRQ stack frame.
+@
+#define S_FRAME_SIZE	72
+
+#define S_OLD_R0	68
+#define S_PSR		64
+#define S_PC		60
+#define S_LR		56
+#define S_SP		52
+
+#define S_IP		48
+#define S_FP		44
+#define S_R10		40
+#define S_R9		36
+#define S_R8		32
+#define S_R7		28
+#define S_R6		24
+#define S_R5		20
+#define S_R4		16
+#define S_R3		12
+#define S_R2		8
+#define S_R1		4
+#define S_R0		0
+
+#define MODE_SVC	0x13
+#define I_BIT		0x80
+
+/*
+ * use bad_save_user_regs for abort/prefetch/undef/swi ...
+ * use irq_save_user_regs / irq_restore_user_regs for IRQ/FIQ handling
+ */
+
+	.macro	bad_save_user_regs
+	@ carve out a frame on current user stack
+	sub	sp, sp, #S_FRAME_SIZE
+	stmia	sp, {r0 - r12}	@ Save user registers (now in svc mode) r0-r12
+
+	ldr	r2, _armboot_start
+	sub	r2, r2, #(CONFIG_STACKSIZE+CONFIG_SYS_MALLOC_LEN)
+	sub	r2, r2, #(CONFIG_SYS_GBL_DATA_SIZE+8)  @ set base 2 words into abort stack
+	@ get values for "aborted" pc and cpsr (into parm regs)
+	ldmia	r2, {r2 - r3}
+	add	r0, sp, #S_FRAME_SIZE		@ grab pointer to old stack
+	add	r5, sp, #S_SP
+	mov	r1, lr
+	stmia	r5, {r0 - r3}	@ save sp_SVC, lr_SVC, pc, cpsr
+	mov	r0, sp		@ save current stack into r0 (param register)
+	.endm
+
+	.macro	irq_save_user_regs
+	sub	sp, sp, #S_FRAME_SIZE
+	stmia	sp, {r0 - r12}			@ Calling r0-r12
+	@ !!!! R8 NEEDS to be saved !!!! a reserved stack spot would be good.
+	add	r8, sp, #S_PC
+	stmdb	r8, {sp, lr}^		@ Calling SP, LR
+	str	lr, [r8, #0]		@ Save calling PC
+	mrs	r6, spsr
+	str	r6, [r8, #4]		@ Save CPSR
+	str	r0, [r8, #8]		@ Save OLD_R0
+	mov	r0, sp
+	.endm
+
+	.macro	irq_restore_user_regs
+	ldmia	sp, {r0 - lr}^			@ Calling r0 - lr
+	mov	r0, r0
+	ldr	lr, [sp, #S_PC]			@ Get PC
+	add	sp, sp, #S_FRAME_SIZE
+	subs	pc, lr, #4		@ return & move spsr_svc into cpsr
+	.endm
+
+	.macro get_bad_stack
+	ldr	r13, _armboot_start		@ setup our mode stack
+	sub	r13, r13, #(CONFIG_STACKSIZE+CONFIG_SYS_MALLOC_LEN)
+	sub	r13, r13, #(CONFIG_SYS_GBL_DATA_SIZE+8) @ reserved a couple spots in abort stack
+
+	str	lr, [r13]	@ save caller lr in position 0 of saved stack
+	mrs	lr, spsr	@ get the spsr
+	str	lr, [r13, #4]	@ save spsr in position 1 of saved stack
+	mov	r13, #MODE_SVC	@ prepare SVC-Mode
+	@ msr	spsr_c, r13
+	msr	spsr, r13	@ switch modes, make sure moves will execute
+	mov	lr, pc		@ capture return pc
+	movs	pc, lr		@ jump to next instruction & switch modes.
+	.endm
+
+	.macro get_irq_stack			@ setup IRQ stack
+	ldr	sp, IRQ_STACK_START
+	.endm
+
+	.macro get_fiq_stack			@ setup FIQ stack
+	ldr	sp, FIQ_STACK_START
+	.endm
+
+/*
+ * exception handlers
+ */
+	.align  5
+undefined_instruction:
+@	get_bad_stack
+@	bad_save_user_regs
+	bl	do_undefined_instruction
+
+	.align	5
+software_interrupt:
+@	get_bad_stack
+@	bad_save_user_regs
+	bl	do_software_interrupt
+
+	.align	5
+prefetch_abort:
+@	get_bad_stack
+@	bad_save_user_regs
+	bl	do_prefetch_abort
+
+	.align	5
+data_abort:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_data_abort
+
+	.align	5
+not_used:
+@	get_bad_stack
+@	bad_save_user_regs
+	bl	do_not_used
+
+#ifdef CONFIG_USE_IRQ
+
+	.align	5
+irq:
+	get_irq_stack
+	irq_save_user_regs
+	bl 	do_irq
+	irq_restore_user_regs
+
+	.align	5
+fiq:
+	get_fiq_stack
+	/* someone ought to write a more effiction fiq_save_user_regs */
+	irq_save_user_regs
+	bl 	do_fiq
+	irq_restore_user_regs
+
+#else
+
+	.align	5
+irq:
+@	get_bad_stack
+@	bad_save_user_regs
+	bl	do_irq
+
+	.align	5
+fiq:
+@	get_bad_stack
+@	bad_save_user_regs
+	bl	do_fiq
+
+#endif
+
+#ifdef CONFIG_PM
+	.align 4
+PMCTL1_ADDR:	.long 0x56000080
+PMST_ADDR:	.long 0x560000B4
+PMSR0_ADDR:	.long 0x560000B8
+GPBCON:		.long 0x56000010
+GPBDAT:		.long 0x56000014
+GPFCON_reg:	.long 0x56000050
+GPFDAT_reg:	.long 0x56000054
+
+	.align 5
+sleep_setting:
+@ prepare the SDRAM self-refresh mode
+	ldr r0, =0x48000024	@ REFRESH Register
+	ldr r1, [r0]
+	orr r1, r1,#(1<<22) @ self-refresh bit set
+
+@ prepare MISCCR[19:17]=111b to make SDRAM signals(SCLK0,SCLK1,SCKE) protected
+	ldr r2,=0x56000080	@ MISCCR Register
+	ldr r3,[r2]
+	orr r3,r3,#((1<<17)|(1<<18)|(1<<19))
+
+@ prepare the Power_Off mode bit in CLKCON Register
+	ldr r4,=0x4c00000c	@ CLKCON Register
+	ldr r5,=(1<<3)
+	b   set_sdram_refresh
+
+	.align 5
+set_sdram_refresh:
+	str r1,[r0]             @ SDRAM self-refresh enable
+
+@ wait until SDRAM into self-refresh
+	mov r1, #64
+1:  subs    r1, r1, #1
+	bne 1b
+
+@ set the MISCCR & CLKCON register for power off
+	str r3,[r2]
+	str r5,[r4]
+	nop                 @ waiting for power off
+	nop
+	nop
+	b   .
+
+	.align 5
+WakeupStart:
+	@ Clear sleep reset bit
+	ldr r0, PMST_ADDR
+	mov r1, #(1<<1) @ PMST_SMR
+	str r1, [r0]
+
+	@ Release the SDRAM signal protections
+	ldr r0, PMCTL1_ADDR
+	ldr r1, [r0]
+	bic r1, r1, #((1<<17)|(1<<18)|(1<<19))  @ (SCLKE | SCLK1 | SCLK0)
+	str r1, [r0]
+
+	@ Max1718_Set();  @for case 135 i.e 300MHz operation
+@	GPBCON = (GPBCON & ~((3 << 20) | (3 << 16) | (3 << 14))) | (1 << 20) | (1 << 16) | (1 << 14);
+	ldr r1, GPBCON
+	ldr r0, [r1]
+	bic r0, r0, #( (3 << 20) | (3 << 16) | (3 << 14) )
+	orr r0, r0, #( (1 << 20) | (1 << 16) | (1 << 14) )
+	str r0, [r1]
+	// GPB7, 8, 10 : Output
+
+@	GPFCON = (GPFCON & ~(0xff << 8)) | (0x55 << 8);	// GPF4~7: Output , shared with LED4~7
+	ldr r1, GPFCON_reg
+	ldr r0, [r1]
+	bic r0, r0, #( (0xff << 8) )
+	orr r0, r0, #( (0x55 << 8) )
+	str r0, [r1]
+
+@	GPBDAT = (GPBDAT & ~(1 << 7)) | (0 << 7);   //D4
+	ldr r1, GPBDAT
+	ldr r0, [r1]
+	bic r0, r0, #( (1 << 7) )
+	orr r0, r0, #( (0 << 7) )
+	str r0, [r1]
+
+@	GPFDAT = (GPFDAT & ~(0xf << 4)) | (1 << 7) | (0 << 6) | (0 << 5) | (0 << 4);    //D3~0
+	ldr r1, GPFDAT_reg
+	ldr r0, [r1]
+	bic r0, r0, #( (0xf << 4) )
+	orr r0, r0, #( (1 << 7) | (0 << 6) | (0 << 5) | (0 << 4) )	@D3~0
+	str r0, [r1]
+
+
+	@ Go...
+	ldr r0, PMSR0_ADDR  @ read a return address
+	ldr r1, [r0]
+	mov pc, r1
+	nop
+	nop
+	1:  b   1b      @ infinite loop
+#endif
+
diff -NBbur u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/u-boot.lds u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/u-boot.lds
--- u-boot-2010.09-orig/arch/arm/cpu/s3c24xx/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/cpu/s3c24xx/u-boot.lds	2011-09-01 15:16:04.000000000 +0800
@@ -0,0 +1,59 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+	  arch/arm/cpu/s3c24xx/start.o	(.text)
+	  arch/arm/cpu/s3c24xx/s3c2416/cpu_init.o	(.text)
+	  board/samsung/smdk2416/lowlevel_init.o	(.text)
+	  arch/arm/cpu/s3c24xx/mmu_table.o	(.text)
+      arch/arm/cpu/s3c24xx/nand_cp.o   (.text)
+	  *(.text)
+	}
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	.mmudata : { *(.mmudata) }
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -NBbur u-boot-2010.09-orig/arch/arm/include/asm/arch-s3c2416/hardware.h u-boot-2010.09-smdk2416/arch/arm/include/asm/arch-s3c2416/hardware.h
--- u-boot-2010.09-orig/arch/arm/include/asm/arch-s3c2416/hardware.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/include/asm/arch-s3c2416/hardware.h	2011-09-01 15:12:27.000000000 +0800
@@ -0,0 +1,42 @@
+#ifndef _ARCH_HARDWARE_H_
+#define _ARCH_HARDWARE_H_
+
+#include <asm/sizes.h>
+
+#ifndef __ASSEMBLY__
+#define UData(Data)	((unsigned long) (Data))
+
+#define __REG(x)	(*(vu_long *)(x))
+#define __REGl(x)	(*(vu_long *)(x))
+#define __REGw(x)	(*(vu_short *)(x))
+#define __REGb(x)	(*(vu_char *)(x))
+#define __REG2(x,y)	(*(vu_long *)((x) + (y)))
+#else
+#define UData(Data)	(Data)
+
+#define __REG(x)	(x)
+#define __REGl(x)	(x)
+#define __REGw(x)	(x)
+#define __REGb(x)	(x)
+#define __REG2(x,y)	((x) + (y))
+#endif
+
+#define Fld(Size, Shft)	(((Size) << 16) + (Shft))
+
+#define FSize(Field)	((Field) >> 16)
+#define FShft(Field)	((Field) & 0x0000FFFF)
+#define FMsk(Field)	(((UData (1) << FSize (Field)) - 1) << FShft (Field))
+#define FAlnMsk(Field)	((UData (1) << FSize (Field)) - 1)
+#define F1stBit(Field)	(UData (1) << FShft (Field))
+
+#define FClrBit(Data, Bit)	(Data = (Data & ~(Bit)))
+#define FClrFld(Data, Field)	(Data = (Data & ~FMsk(Field)))
+
+#define FInsrt(Value, Field) \
+                	(UData (Value) << FShft (Field))
+
+#define FExtr(Data, Field) \
+                	((UData (Data) >> FShft (Field)) & FAlnMsk (Field))
+
+#endif /* _ARCH_HARDWARE_H_ */
+
diff -NBbur u-boot-2010.09-orig/arch/arm/include/asm/arch-s3c2416/memory.h u-boot-2010.09-smdk2416/arch/arm/include/asm/arch-s3c2416/memory.h
--- u-boot-2010.09-orig/arch/arm/include/asm/arch-s3c2416/memory.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/include/asm/arch-s3c2416/memory.h	2011-09-01 15:12:27.000000000 +0800
@@ -0,0 +1,162 @@
+/*
+ * linux/include/asm-arm/arch-s3c2400/memory.h by gj@denx.de
+ * based on
+ * linux/include/asm-arm/arch-sa1100/memory.h
+ *
+ * Copyright (c) 1999 Nicolas Pitre <nico@visuaide.com>
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+
+/*
+ * Task size: 3GB
+ */
+#define TASK_SIZE       (0xc0000000UL)
+#define TASK_SIZE_26	(0x04000000UL)
+
+/*
+ * This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+#define TASK_UNMAPPED_BASE (TASK_SIZE / 3)
+
+/*
+ * Page offset: 3GB
+ */
+#define PAGE_OFFSET     (0xc0000000UL)
+
+/*
+ * Physical DRAM offset is 0x0c000000 on the S3C2400
+ */
+#define PHYS_OFFSET	(0x0c000000UL)
+
+#include <linux/config.h>
+
+
+/* Modified for S3C2400, by chc, 20010509 */
+#define RAM_IN_BANK_0  32*1024*1024
+#define RAM_IN_BANK_1  0
+#define RAM_IN_BANK_2  0
+#define RAM_IN_BANK_3  0
+
+#define MEM_SIZE  (RAM_IN_BANK_0+RAM_IN_BANK_1+RAM_IN_BANK_2+RAM_IN_BANK_3)
+
+
+/* translation macros */
+#define __virt_to_phys__is_a_macro
+#define __phys_to_virt__is_a_macro
+
+#if (RAM_IN_BANK_1 + RAM_IN_BANK_2 + RAM_IN_BANK_3 == 0)
+
+#define __virt_to_phys(x) ( (x) - PAGE_OFFSET + 0x0c000000 )
+#define __phys_to_virt(x) ( (x) - 0x0c000000 + PAGE_OFFSET )
+
+#elif (RAM_IN_BANK_0 == RAM_IN_BANK_1) && \
+      (RAM_IN_BANK_2 + RAM_IN_BANK_3 == 0)
+
+/* Two identical banks */
+#define __virt_to_phys(x) \
+	  ( ((x) < PAGE_OFFSET+RAM_IN_BANK_0) ? \
+	    ((x) - PAGE_OFFSET + _DRAMBnk0) : \
+	    ((x) - PAGE_OFFSET - RAM_IN_BANK_0 + _DRAMBnk1) )
+#define __phys_to_virt(x) \
+	  ( ((x)&0x07ffffff) + \
+	    (((x)&0x08000000) ? PAGE_OFFSET+RAM_IN_BANK_0 : PAGE_OFFSET) )
+#else
+
+/* It's more efficient for all other cases to use the function call */
+#undef __virt_to_phys__is_a_macro
+#undef __phys_to_virt__is_a_macro
+extern unsigned long __virt_to_phys(unsigned long vpage);
+extern unsigned long __phys_to_virt(unsigned long ppage);
+
+#endif
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ *
+ * On the SA1100, bus addresses are equivalent to physical addresses.
+ */
+#define __virt_to_bus__is_a_macro
+#define __virt_to_bus(x)        __virt_to_phys(x)
+#define __bus_to_virt__is_a_macro
+#define __bus_to_virt(x)        __phys_to_virt(x)
+
+
+#ifdef CONFIG_DISCONTIGMEM
+#error "CONFIG_DISCONTIGMEM will not work on S3C2400"
+/*
+ * Because of the wide memory address space between physical RAM banks on the
+ * SA1100, it's much more convenient to use Linux's NUMA support to implement
+ * our memory map representation.  Assuming all memory nodes have equal access
+ * characteristics, we then have generic discontiguous memory support.
+ *
+ * Of course, all this isn't mandatory for SA1100 implementations with only
+ * one used memory bank.  For those, simply undefine CONFIG_DISCONTIGMEM.
+ *
+ * The nodes are matched with the physical memory bank addresses which are
+ * incidentally the same as virtual addresses.
+ *
+ * 	node 0:  0xc0000000 - 0xc7ffffff
+ * 	node 1:  0xc8000000 - 0xcfffffff
+ * 	node 2:  0xd0000000 - 0xd7ffffff
+ * 	node 3:  0xd8000000 - 0xdfffffff
+ */
+
+#define NR_NODES	4
+
+/*
+ * Given a kernel address, find the home node of the underlying memory.
+ */
+#define KVADDR_TO_NID(addr) \
+		(((unsigned long)(addr) - 0xc0000000) >> 27)
+
+/*
+ * Given a physical address, convert it to a node id.
+ */
+#define PHYS_TO_NID(addr) KVADDR_TO_NID(__phys_to_virt(addr))
+
+/*
+ * Given a kaddr, ADDR_TO_MAPBASE finds the owning node of the memory
+ * and returns the mem_map of that node.
+ */
+#define ADDR_TO_MAPBASE(kaddr) \
+			NODE_MEM_MAP(KVADDR_TO_NID((unsigned long)(kaddr)))
+
+/*
+ * Given a kaddr, LOCAL_MEM_MAP finds the owning node of the memory
+ * and returns the index corresponding to the appropriate page in the
+ * node's mem_map.
+ */
+#define LOCAL_MAP_NR(kvaddr) \
+	(((unsigned long)(kvaddr) & 0x07ffffff) >> PAGE_SHIFT)
+
+/*
+ * Given a kaddr, virt_to_page returns a pointer to the corresponding
+ * mem_map entry.
+ */
+#define virt_to_page(kaddr) \
+	(ADDR_TO_MAPBASE(kaddr) + LOCAL_MAP_NR(kaddr))
+
+/*
+ * VALID_PAGE returns a non-zero value if given page pointer is valid.
+ * This assumes all node's mem_maps are stored within the node they refer to.
+ */
+#define VALID_PAGE(page) \
+({ unsigned int node = KVADDR_TO_NID(page); \
+   ( (node < NR_NODES) && \
+     ((unsigned)((page) - NODE_MEM_MAP(node)) < NODE_DATA(node)->node_size) ); \
+})
+
+#else
+
+#define PHYS_TO_NID(addr)	(0)
+
+#endif
+#endif /* __ASM_ARCH_MEMORY_H */
diff -NBbur u-boot-2010.09-orig/arch/arm/include/asm/arch-s3c2416/mmc.h u-boot-2010.09-smdk2416/arch/arm/include/asm/arch-s3c2416/mmc.h
--- u-boot-2010.09-orig/arch/arm/include/asm/arch-s3c2416/mmc.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/include/asm/arch-s3c2416/mmc.h	2011-09-01 15:12:27.000000000 +0800
@@ -0,0 +1,200 @@
+/*
+ *  linux/drivers/mmc/s3c-hsmmc.h
+ *
+ *  Author: Seung-Chull, Suh
+ *  Copyright:  Samsung Electronics
+ *
+ *  $Id: mmc.h,v 1.1 2007/01/08 02:04:06 scsuh Exp $
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+#ifndef __MMC_S3C24XX_H__
+#define __MMC_S3C24XX_H__
+
+/* PXA-250 MMC controller registers */
+
+/* MMC_STRPCL */
+#define MMC_STRPCL_STOP_CLK     	(0x0001UL)
+#define MMC_STRPCL_START_CLK		(0x0002UL)
+
+/* MMC_STAT */
+#define MMC_STAT_END_CMD_RES		(0x0001UL << 13)
+#define MMC_STAT_PRG_DONE       	(0x0001UL << 12)
+#define MMC_STAT_DATA_TRAN_DONE     	(0x0001UL << 11)
+#define MMC_STAT_CLK_EN	 		(0x0001UL << 8)
+#define MMC_STAT_RECV_FIFO_FULL     	(0x0001UL << 7)
+#define MMC_STAT_XMIT_FIFO_EMPTY    	(0x0001UL << 6)
+#define MMC_STAT_RES_CRC_ERROR      	(0x0001UL << 5)
+#define MMC_STAT_SPI_READ_ERROR_TOKEN   (0x0001UL << 4)
+#define MMC_STAT_CRC_READ_ERROR     	(0x0001UL << 3)
+#define MMC_STAT_CRC_WRITE_ERROR    	(0x0001UL << 2)
+#define MMC_STAT_TIME_OUT_RESPONSE  	(0x0001UL << 1)
+#define MMC_STAT_READ_TIME_OUT      	(0x0001UL)
+
+#define MMC_STAT_ERRORS (MMC_STAT_RES_CRC_ERROR|MMC_STAT_SPI_READ_ERROR_TOKEN\
+	|MMC_STAT_CRC_READ_ERROR|MMC_STAT_TIME_OUT_RESPONSE\
+	|MMC_STAT_READ_TIME_OUT|MMC_STAT_CRC_WRITE_ERROR)
+
+/* MMC_CLKRT */
+#define MMC_CLKRT_20MHZ	 		(0x0000UL)
+#define MMC_CLKRT_10MHZ	 		(0x0001UL)
+#define MMC_CLKRT_5MHZ	  		(0x0002UL)
+#define MMC_CLKRT_2_5MHZ		(0x0003UL)
+#define MMC_CLKRT_1_25MHZ       	(0x0004UL)
+#define MMC_CLKRT_0_625MHZ      	(0x0005UL)
+#define MMC_CLKRT_0_3125MHZ     	(0x0006UL)
+
+/* MMC_SPI */
+#define MMC_SPI_DISABLE	 		(0x00UL)
+#define MMC_SPI_EN	  		(0x01UL)
+#define MMC_SPI_CS_EN	   		(0x01UL << 2)
+#define MMC_SPI_CS_ADDRESS      	(0x01UL << 3)
+#define MMC_SPI_CRC_ON	  		(0x01UL << 1)
+
+/* MMC_CMDAT */
+#define MMC_CMDAT_MMC_DMA_EN		(0x0001UL << 7)
+#define MMC_CMDAT_INIT	  		(0x0001UL << 6)
+#define MMC_CMDAT_BUSY	  		(0x0001UL << 5)
+#define MMC_CMDAT_STREAM		(0x0001UL << 4)
+#define MMC_CMDAT_BLOCK	 		(0x0000UL << 4)
+#define MMC_CMDAT_WRITE	 		(0x0001UL << 3)
+#define MMC_CMDAT_READ	  		(0x0000UL << 3)
+#define MMC_CMDAT_DATA_EN       	(0x0001UL << 2)
+#define MMC_CMDAT_R1	    		(0x0001UL)
+#define MMC_CMDAT_R2	    		(0x0002UL)
+#define MMC_CMDAT_R3	    		(0x0003UL)
+
+/* MMC_RESTO */
+#define MMC_RES_TO_MAX	  		(0x007fUL) /* [6:0] */
+
+/* MMC_RDTO */
+#define MMC_READ_TO_MAX	 		(0x0ffffUL) /* [15:0] */
+
+/* MMC_BLKLEN */
+#define MMC_BLK_LEN_MAX	 		(0x03ffUL) /* [9:0] */
+
+/* MMC_PRTBUF */
+#define MMC_PRTBUF_BUF_PART_FULL       	(0x01UL)
+#define MMC_PRTBUF_BUF_FULL		(0x00UL    )
+
+/* MMC_I_MASK */
+#define MMC_I_MASK_TXFIFO_WR_REQ	(0x01UL << 6)
+#define MMC_I_MASK_RXFIFO_RD_REQ	(0x01UL << 5)
+#define MMC_I_MASK_CLK_IS_OFF	   	(0x01UL << 4)
+#define MMC_I_MASK_STOP_CMD	 	(0x01UL << 3)
+#define MMC_I_MASK_END_CMD_RES	  	(0x01UL << 2)
+#define MMC_I_MASK_PRG_DONE	 	(0x01UL << 1)
+#define MMC_I_MASK_DATA_TRAN_DONE       (0x01UL)
+#define MMC_I_MASK_ALL	      		(0x07fUL)
+
+
+/* MMC_I_REG */
+#define MMC_I_REG_TXFIFO_WR_REQ     	(0x01UL << 6)
+#define MMC_I_REG_RXFIFO_RD_REQ     	(0x01UL << 5)
+#define MMC_I_REG_CLK_IS_OFF		(0x01UL << 4)
+#define MMC_I_REG_STOP_CMD      	(0x01UL << 3)
+#define MMC_I_REG_END_CMD_RES       	(0x01UL << 2)
+#define MMC_I_REG_PRG_DONE      	(0x01UL << 1)
+#define MMC_I_REG_DATA_TRAN_DONE    	(0x01UL)
+#define MMC_I_REG_ALL	   		(0x007fUL)
+
+/* MMC_CMD */
+#define MMC_CMD_INDEX_MAX       	(0x006fUL)  /* [5:0] */
+#define CMD(x)  (x)
+
+#define MMC_DEFAULT_RCA			1
+
+#define MMC_BLOCK_SIZE			512
+#define MMC_CMD_RESET			0
+#define MMC_CMD_SEND_OP_COND		1
+#define MMC_CMD_ALL_SEND_CID 		2
+#define MMC_CMD_SET_RCA			3
+#define MMC_CMD_SEND_CSD 		9
+#define MMC_CMD_SEND_CID 		10
+#define MMC_CMD_SEND_STATUS		13
+#define MMC_CMD_SET_BLOCKLEN		16
+#define MMC_CMD_READ_BLOCK		17
+#define MMC_CMD_RD_BLK_MULTI		18
+#define MMC_CMD_WRITE_BLOCK		24
+
+#define MMC_MAX_BLOCK_SIZE		512
+
+#define MMC_R1_IDLE_STATE		0x01
+#define MMC_R1_ERASE_STATE		0x02
+#define MMC_R1_ILLEGAL_CMD		0x04
+#define MMC_R1_COM_CRC_ERR		0x08
+#define MMC_R1_ERASE_SEQ_ERR		0x01
+#define MMC_R1_ADDR_ERR			0x02
+#define MMC_R1_PARAM_ERR		0x04
+
+#define MMC_R1B_WP_ERASE_SKIP		0x0002
+#define MMC_R1B_ERR			0x0004
+#define MMC_R1B_CC_ERR			0x0008
+#define MMC_R1B_CARD_ECC_ERR		0x0010
+#define MMC_R1B_WP_VIOLATION		0x0020
+#define MMC_R1B_ERASE_PARAM		0x0040
+#define MMC_R1B_OOR			0x0080
+#define MMC_R1B_IDLE_STATE		0x0100
+#define MMC_R1B_ERASE_RESET		0x0200
+#define MMC_R1B_ILLEGAL_CMD		0x0400
+#define MMC_R1B_COM_CRC_ERR		0x0800
+#define MMC_R1B_ERASE_SEQ_ERR		0x1000
+#define MMC_R1B_ADDR_ERR		0x2000
+#define MMC_R1B_PARAM_ERR		0x4000
+
+#if 0
+typedef struct mmc_cid
+{
+/* FIXME: BYTE_ORDER */
+   uchar year:4,
+   month:4;
+   uchar sn[3];
+   uchar fwrev:4,
+   hwrev:4;
+   uchar name[6];
+   uchar id[3];
+} mmc_cid_t;
+
+typedef struct mmc_csd
+{
+	uchar	ecc:2,
+		file_format:2,
+		tmp_write_protect:1,
+		perm_write_protect:1,
+		copy:1,
+		file_format_grp:1;
+	uint64_t content_prot_app:1,
+		rsvd3:4,
+		write_bl_partial:1,
+		write_bl_len:4,
+		r2w_factor:3,
+		default_ecc:2,
+		wp_grp_enable:1,
+		wp_grp_size:5,
+		erase_grp_mult:5,
+		erase_grp_size:5,
+		c_size_mult1:3,
+		vdd_w_curr_max:3,
+		vdd_w_curr_min:3,
+		vdd_r_curr_max:3,
+		vdd_r_curr_min:3,
+		c_size:12,
+		rsvd2:2,
+		dsr_imp:1,
+		read_blk_misalign:1,
+		write_blk_misalign:1,
+		read_bl_partial:1;
+
+	ushort	read_bl_len:4,
+		ccc:12;
+	uchar	tran_speed;
+	uchar	nsac;
+	uchar	taac;
+	uchar	rsvd1:2,
+  		spec_vers:4,
+		csd_structure:2;
+} mmc_csd_t;
+#endif
+#endif /* __MMC_S3C24XX_H__ */
diff -NBbur u-boot-2010.09-orig/arch/arm/include/asm/arch-s3c2416/s3c2416.h u-boot-2010.09-smdk2416/arch/arm/include/asm/arch-s3c2416/s3c2416.h
--- u-boot-2010.09-orig/arch/arm/include/asm/arch-s3c2416/s3c2416.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/include/asm/arch-s3c2416/s3c2416.h	2011-09-01 16:08:27.000000000 +0800
@@ -0,0 +1,1150 @@
+/************************************************
+ * NAME	    : s3c2416.h
+ *
+ * Based on S3C2416X User's manual Rev 1.1
+ ************************************************/
+
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __S3C2416_H__
+#define __S3C2416_H__
+
+#ifndef CONFIG_S3C2416
+#define CONFIG_S3C2416		1
+#endif
+
+#define S3C24X0_UART_CHANNELS	3
+#define S3C24X0_SPI_CHANNELS	2
+
+#include <asm/hardware.h>
+
+#ifndef __ASSEMBLY__
+typedef enum {
+	S3C24X0_UART0,
+	S3C24X0_UART1,
+	S3C24X0_UART2,
+} S3C24X0_UARTS_NR;
+
+#include <asm/arch/s3c24xx.h>
+#endif
+
+/* S3C2416 only supports 512 Byte HW ECC */
+#define S3C2410_ECCSIZE		512
+#define S3C2410_ECCBYTES	3
+
+/* S3C2416 device base addresses */
+#define ELFIN_SSTONE_BASE	0x40000000 /* stepping stone on iROM boot */
+#define ELFIN_DMA_BASE		0x4b000000
+#define ELFIN_USB_HOST_BASE	0x49000000
+#define ELFIN_USB_DEVICE_BASE	0x49800000
+#define ELFIN_I2C_BASE		0x54000000
+#define ELFIN_I2S_BASE		0x55000000
+#define ELFIN_ADC_BASE		0x58000000
+#define ELFIN_SPI_BASE		0x59000000
+
+/*
+ * Clock and power management
+ */
+#define ELFIN_CLOCK_POWER_BASE	0x4c000000
+
+/* Clock & Power Controller */
+#define LOCKCON0_OFFSET		0x00
+#define LOCKCON1_OFFSET		0x04
+#define OSCSET_OFFSET		0x08
+#define MPLLCON_OFFSET		0x10
+#define EPLLCON_OFFSET		0x18
+#define CLKSRCCON_OFFSET	0x20
+#define CLKDIV0CON_OFFSET	0x24
+#define CLKDIV1CON_OFFSET	0x28
+#define HCLKCON_OFFSET		0x30
+#define PCLKCON_OFFSET		0x34
+#define SCLKCON_OFFSET		0x38
+#define PWRMODECON_OFFSET	0x40
+#define SWRSTCON_OFFSET		0x44
+#define BUSPRI0_OFFSET		0x50
+#define BUS_MISC_OFFSET		0x58
+#define SYSID_OFFSET		0x5c
+#define PWRCFG_OFFSET		0x60
+#define RSTCON_OFFSET		0x64
+#define RSTSTAT_OFFSET		0x68
+#define WKUPSTAT_OFFSET		0x6c
+#define INFORM0_OFFSET		0x70
+#define INFORM1_OFFSET		0x74
+#define INFORM2_OFFSET		0x78
+#define INFORM3_OFFSET		0x7c
+#define USB_PHYCTRL_OFFSET	0x80
+#define USB_PHYPWR_OFFSET	0x84
+#define USB_RSTCON_OFFSET	0x88
+#define USB_CLKCON_OFFSET	0x8c
+#define USB_TESTTI_OFFSET	0x90
+#define USB_TESTTO_OFFSET	0x94
+
+#define LOCKCON0	(0x4c000000)
+#define LOCKCON1	(0x4c000004)
+#define OSCSET		(0x4c000008)
+#define MPLLCON		(0x4c000010)
+#define EPLLCON		(0x4c000018)
+#define CLKSRCCON	(0x4c000020)
+#define CLKDIV0CON	(0x4c000024)
+#define CLKDIV1CON	(0x4c000028)
+#define HCLKCON		(0x4c000030)
+#define PCLKCON		(0x4c000034)
+#define SCLKCON		(0x4c000038)
+#define PWRMODECON	(0x4c000040)
+#define SWRSTCON	(0x4c000044)
+#define BUSPRI0		(0x4c000050)
+#define BUS_MISC	(0x4c000058)
+#define SYSID		(0x4c00005c)
+#define PWRCFG		(0x4c000060)
+#define RSTCON		(0x4c000064)
+#define RSTSTAT		(0x4c000068)
+#define WKUPSTAT	(0x4c00006c)
+#define INFORM0		(0x4c000070)
+#define INFORM1		(0x4c000074)
+#define INFORM2		(0x4c000078)
+#define INFORM3		(0x4c00007c)
+#define USB_PHYCTRL	(0x4c000080)
+#define USB_PHYPWR	(0x4c000084)
+#define USB_RSTCON	(0x4c000088)
+#define USB_CLKCON	(0x4c00008c)
+#define USB_TESTTI	(0x4c000090)
+#define USB_TESTTO	(0x4c000094)
+
+#define LOCKCON0_REG		__REG(0x4c000000)
+#define LOCKCON1_REG		__REG(0x4c000004)
+#define OSCSET_REG		__REG(0x4c000008)
+#define MPLLCON_REG		__REG(0x4c000010)
+#define EPLLCON_REG		__REG(0x4c000018)
+#define CLKSRCCON_REG		__REG(0x4c000020)
+#define CLKDIV0CON_REG		__REG(0x4c000024)
+#define CLKDIV1CON_REG		__REG(0x4c000028)
+#define HCLKCON_REG		__REG(0x4c000030)
+#define PCLKCON_REG		__REG(0x4c000034)
+#define SCLKCON_REG		__REG(0x4c000038)
+#define PWRMODECON_REG		__REG(0x4c000040)
+#define SWRSTCON_REG		__REG(0x4c000044)
+#define BUSPRI0_REG		__REG(0x4c000050)
+#define BUS_MISC_REG		__REG(0x4c000058)
+#define SYSID_REG		__REG(0x4c00005c)
+#define PWRCFG_REG		__REG(0x4c000060)
+#define RSTCON_REG		__REG(0x4c000064)
+#define RSTSTAT_REG		__REG(0x4c000068)
+#define WKUPSTAT_REG		__REG(0x4c00006c)
+#define INFORM0_REG		__REG(0x4c000070)
+#define INFORM1_REG		__REG(0x4c000074)
+#define INFORM2_REG		__REG(0x4c000078)
+#define INFORM3_REG		__REG(0x4c00007c)
+#define USB_PHYCTRL_REG		__REG(0x4c000080)
+#define USB_PHYPWR_REG		__REG(0x4c000084)
+#define USB_RSTCON_REG		__REG(0x4c000088)
+#define USB_CLKCON_REG		__REG(0x4c00008c)
+#define USB_TESTTI_REG		__REG(0x4c000090)
+#define USB_TESTTO_REG		__REG(0x4c000094)
+
+
+/*
+ * Bus Matrix (chap 3)
+ */
+
+#define ELFIN_BUS_MAT_BASE	0x4e800000
+#define BPRIORITY0		(ELFIN_BUS_MAT_BASE+0x00)
+#define BPRIORITY1		(ELFIN_BUS_MAT_BASE+0x04)
+#define EBICON			(ELFIN_BUS_MAT_BASE+0x08)
+
+
+
+/*
+ * GPIO
+ */
+
+#define ELFIN_GPIO_BASE		0x56000000
+
+#define GPACON_OFFSET		0x00
+#define GPADAT_OFFSET		0x04
+
+#define GPBCON_OFFSET		0x10
+#define GPBDAT_OFFSET		0x14
+#define GPBPU_OFFSET		0x18
+
+#define GPCCON_OFFSET		0x20
+#define GPCDAT_OFFSET		0x24
+#define GPCPU_OFFSET		0x28
+
+#define GPDCON_OFFSET		0x30
+#define GPDDAT_OFFSET		0x34
+#define GPDPU_OFFSET		0x38
+
+#define GPECON_OFFSET		0x40
+#define GPEDAT_OFFSET		0x44
+#define GPEPU_OFFSET		0x48
+
+#define GPFCON_OFFSET		0x50
+#define GPFDAT_OFFSET		0x54
+#define GPFPU_OFFSET		0x58
+
+#define GPGCON_OFFSET		0x60
+#define GPGDAT_OFFSET		0x64
+#define GPGPU_OFFSET		0x68
+
+#define GPHCON_OFFSET		0x70
+#define GPHDAT_OFFSET		0x74
+#define GPHPU_OFFSET		0x78
+
+#define GPJCON_OFFSET		0xd0
+#define GPJDAT_OFFSET		0xd4
+#define GPJPU_OFFSET		0xd8
+
+#define GPKCON_OFFSET		0xe0
+#define GPKDAT_OFFSET		0xe4
+#define GPKPU_OFFSET		0xe8
+
+#define GPLCON_OFFSET		0xf0
+#define GPLDAT_OFFSET		0xf4
+#define GPLPU_OFFSET		0xf8
+
+#define GPMCON_OFFSET		0x100
+#define GPMDAT_OFFSET		0x104
+#define GPMPU_OFFSET		0x108
+
+#define MISCCR_OFFSET		0x80
+#define DCLKCON_OFFSET		0x84
+
+#define EINTCON0_OFFSET		0x88
+#define EINTCON1_OFFSET		0x8c
+#define EINTCON2_OFFSET		0x90
+
+#define EINTFLT0_OFFSET		0x94
+#define EINTFLT1_OFFSET		0x98
+#define EINTFLT2_OFFSET		0x9c
+#define EINTFLT3_OFFSET		0xa0
+
+#define EINTMASK_OFFSET		0xa4
+#define EINTPEND_OFFSET		0xa8
+
+#define GSTATUS0_OFFSET		0xac
+#define GSTATUS1_OFFSET		0xb0
+#define GSTATUS3_OFFSET		0xb8
+#define GSTATUS4_OFFSET		0xbc
+
+#define DSC0_OFFSET		0xc0
+#define DSC1_OFFSET		0xc4
+#define DSC2_OFFSET		0xc8
+
+#define MSLCON_OFFSET		0xcc
+
+#define GPACON		(0x56000000)
+#define GPADAT		(0x56000004)
+
+#define GPBCON		(0x56000010)
+#define GPBDAT		(0x56000014)
+#define GPBPU		(0x56000018)
+
+#define GPCCON		(0x56000020)
+#define GPCDAT		(0x56000024)
+#define GPCPU		(0x56000028)
+
+#define GPDCON		(0x56000030)
+#define GPDDAT		(0x56000034)
+#define GPDPU		(0x56000038)
+
+#define GPECON		(0x56000040)
+#define GPEDAT		(0x56000044)
+#define GPEPU		(0x56000048)
+
+#define GPFCON		(0x56000050)
+#define GPFDAT		(0x56000054)
+#define GPFPU		(0x56000058)
+
+#define GPGCON		(0x56000060)
+#define GPGDAT		(0x56000064)
+#define GPGPU		(0x56000068)
+
+#define GPHCON		(0x56000070)
+#define GPHDAT		(0x56000074)
+#define GPHPU		(0x56000078)
+
+#define GPJCON		(0x560000d0)
+#define GPJDAT		(0x560000d4)
+#define GPJPU		(0x560000d8)
+
+#define GPKCON		(0x560000e0)
+#define GPKDAT		(0x560000e4)
+#define GPKPU		(0x560000e8)
+
+#define GPLCON		(0x560000f0)
+#define GPLDAT		(0x560000f4)
+#define GPLPU		(0x560000f8)
+
+#define GPMCON		(0x56000100)
+#define GPMDAT		(0x56000104)
+#define GPMPU		(0x56000108)
+
+#define MISCCR		(0x56000080)
+#define DCLKCON		(0x56000084)
+
+#define EINTCON0	(0x56000088)
+#define EINTCON1	(0x5600008c)
+#define EINTCON2	(0x56000090)
+
+#define EINTFLT0	(0x56000094)
+#define EINTFLT1	(0x56000098)
+#define EINTFLT2	(0x5600009c)
+#define EINTFLT3	(0x560000a0)
+
+#define EINTMASK	(0x560000a4)
+#define EINTPEND	(0x560000a8)
+
+#define GSTATUS0	(0x560000ac)
+#define GSTATUS1	(0x560000b0)
+#define GSTATUS3	(0x560000b8)
+#define GSTATUS4	(0x560000bc)
+
+#define DSC0		(0x560000c0)
+#define DSC1		(0x560000c4)
+#define DSC2		(0x560000c8)
+
+#define MSLCON		(0x560000cc)
+
+#define GPACON_REG	__REG(0x56000000)
+#define GPADAT_REG	__REG(0x56000004)
+
+#define GPBCON_REG	__REG(0x56000010)
+#define GPBDAT_REG	__REG(0x56000014)
+#define GPBPU_REG	__REG(0x56000018)
+
+#define GPCCON_REG	__REG(0x56000020)
+#define GPCDAT_REG	__REG(0x56000024)
+#define GPCPU_REG	__REG(0x56000028)
+
+#define GPDCON_REG	__REG(0x56000030)
+#define GPDDAT_REG	__REG(0x56000034)
+#define GPDPU_REG	__REG(0x56000038)
+
+#define GPECON_REG	__REG(0x56000040)
+#define GPEDAT_REG	__REG(0x56000044)
+#define GPEPU_REG	__REG(0x56000048)
+
+#define GPFCON_REG	__REG(0x56000050)
+#define GPFDAT_REG	__REG(0x56000054)
+#define GPFPU_REG	__REG(0x56000058)
+
+#define GPGCON_REG	__REG(0x56000060)
+#define GPGDAT_REG	__REG(0x56000064)
+#define GPGPU_REG	__REG(0x56000068)
+
+#define GPHCON_REG	__REG(0x56000070)
+#define GPHDAT_REG	__REG(0x56000074)
+#define GPHPU_REG	__REG(0x56000078)
+
+#define GPJCON_REG	__REG(0x560000d0)
+#define GPJDAT_REG	__REG(0x560000d4)
+#define GPJPU_REG	__REG(0x560000d8)
+
+#define GPKCON_REG	__REG(0x560000e0)
+#define GPKDAT_REG	__REG(0x560000e4)
+#define GPKPU_REG	__REG(0x560000e8)
+
+#define GPLCON_REG	__REG(0x560000f0)
+#define GPLDAT_REG	__REG(0x560000f4)
+#define GPLPU_REG	__REG(0x560000f8)
+
+#define GPMCON_REG	__REG(0x56000100)
+#define GPMDAT_REG	__REG(0x56000104)
+#define GPMPU_REG	__REG(0x56000108)
+
+#define MISCCR_REG	__REG(0x56000080)
+#define DCLKCON_REG	__REG(0x56000084)
+
+#define EINTCON0_REG	__REG(0x56000088)
+#define EINTCON1_REG	__REG(0x5600008c)
+#define EINTCON2_REG	__REG(0x56000090)
+
+#define EINTFLT0_REG	__REG(0x56000094)
+#define EINTFLT1_REG	__REG(0x56000098)
+#define EINTFLT2_REG	__REG(0x5600009c)
+#define EINTFLT3_REG	__REG(0x560000a0)
+
+#define EINTMASK_REG	__REG(0x560000a4)
+#define EINTPEND_REG	__REG(0x560000a8)
+
+#define GSTATUS0_REG	__REG(0x560000ac)
+#define GSTATUS1_REG	__REG(0x560000b0)
+#define GSTATUS3_REG	__REG(0x560000b8)
+#define GSTATUS4_REG	__REG(0x560000bc)
+
+#define DSC0_REG	__REG(0x560000c0)
+#define DSC1_REG	__REG(0x560000c4)
+#define DSC2_REG	__REG(0x560000c8)
+
+#define MSLCON_REG	__REG(0x560000cc)
+
+
+/*
+ * Memory controller
+ */
+
+#define ELFIN_SROM_BASE	0x40c20000
+
+#define SROM_BW_REG	__REG(0x40C20000)
+#define SROM_BC0_REG	__REG(0x40C20004)
+#define SROM_BC1_REG	__REG(0x40C20008)
+#define SROM_BC2_REG	__REG(0x40C2000C)
+
+/*
+ * SDRAM Controller
+ */
+
+#define ELFIN_MEMCTL_BASE	0x48000000
+#define BANKCFG_OFFSET		0x00
+#define BANKCON1_OFFSET		0x04
+#define BANKCON2_OFFSET		0x08
+#define BANKCON3_OFFSET		0x0c
+#define REFRESH_OFFSET		0x10
+#define TIMEOUT_OFFSET		0x14
+
+#define INIT_NORMAL	0x0
+#define INIT_PALL	0x1
+#define INIT_MRS	0x2
+#define INIT_EMRS	0x3
+#define INIT_MASK	0x3
+
+
+/*
+ * Nand flash controller
+ */
+
+#define ELFIN_NAND_BASE	0x4e000000
+
+#define NFCONF_OFFSET		0x00
+#define NFCONT_OFFSET		0x04
+#define NFCMMD_OFFSET		0x08
+#define NFADDR_OFFSET		0x0c
+#define NFDATA_OFFSET		0x10
+#define NFMECCDATA0_OFFSET	0x14
+#define NFMECCDATA1_OFFSET	0x18
+#define NFSECCDATA0_OFFSET	0x1c
+#define NFSBLK_OFFSET		0x20
+#define NFEBLK_OFFSET		0x24
+#define NFSTAT_OFFSET		0x28
+#define NFESTAT0_OFFSET		0x2c
+#define NFESTAT1_OFFSET		0x30
+#define NFMECC0_OFFSET		0x34
+#define NFMECC1_OFFSET		0x38
+#define NFSECC_OFFSET		0x3c
+#define NFMLCBITPT_OFFSET       0x40
+#define NF8ECCERR0_OFFSET	0x44
+#define NF8ECCERR1_OFFSET	0x48
+#define NF8ECCERR2_OFFSET	0x4c
+#define NFM8ECC0_OFFSET		0x50
+#define NFM8ECC1_OFFSET		0x54
+#define NFM8ECC2_OFFSET		0x58
+#define NFM8ECC3_OFFSET		0x5c
+#define NFMLC8BITPT0_OFFSET	0x60
+#define NFMLC8BITPT1_OFFSET	0x64
+
+#define NFCONF		(0x4e000000)
+#define NFCONT		(0x4e000004)
+#define NFCMMD		(0x4e000008)
+#define NFADDR		(0x4e00000c)
+#define NFDATA		(0x4e000010)
+#define NFMECCDATA0	(0x4e000014)
+#define NFMECCDATA1	(0x4e000018)
+#define NFSECCDATA0	(0x4e00001c)
+#define NFSBLK		(0x4e000020)
+#define NFEBLK		(0x4e000024)
+#define NFSTAT		(0x4e000028)
+#define NFESTAT0	(0x4e00002c)
+#define NFESTAT1	(0x4e000030)
+#define NFMECC0		(0x4e000034)
+#define NFMECC1		(0x4e000038)
+#define NFSECC		(0x4e00003c)
+#define NFMLCBITPT	(0x4e000040)
+#define NF8ECCERR0		(0x4e000044)
+#define NF8ECCERR1		(0x4e000048)
+#define NF8ECCERR2		(0x4e00004c)
+#define NFM8ECC0		(0x4e000050)
+#define NFM8ECC1		(0x4e000054)
+#define NFM8ECC2		(0x4e000058)
+#define NFM8ECC3		(0x4e00005c)
+#define NFMLC8BITPT0		(0x4e000060)
+#define NFMLC8BITPT1		(0x4e000064)
+
+#define NFCONF_REG		__REG(0x4e000000)
+#define NFCONT_REG		__REG(0x4e000004)
+#define NFCMD_REG		__REG(0x4e000008)
+#define NFADDR_REG		__REG(0x4e00000c)
+#define NFDATA_REG		__REG(0x4e000010)
+#define NFDATA8_REG		__REGb(0x4e000010)
+#define NFMECCDATA0_REG		__REG(0x4e000014)
+#define NFMECCDATA1_REG		__REG(0x4e000018)
+#define NFSECCDATA0_REG		__REG(0x4e00001c)
+#define NFSBLK_REG		__REG(0x4e000020)
+#define NFEBLK_REG		__REG(0x4e000024)
+#define NFSTAT_REG		__REG(0x4e000028)
+#define NFESTAT0_REG		__REG(0x4e00002c)
+#define NFESTAT1_REG		__REG(0x4e000030)
+#define NFMECC0_REG		__REG(0x4e000034)
+#define NFMECC1_REG		__REG(0x4e000038)
+#define NFSECC_REG		__REG(0x4e00003c)
+#define NFMLCBITPT_REG		__REG(0x4e000040)
+
+#define NFCONF_ECC_MLC		(1<<24)
+
+#define NFCONF_ECC_1BIT		(0<<23)
+#define NFCONF_ECC_4BIT		(2<<23)
+#define NFCONF_ECC_8BIT		(1<<23)
+
+#define NFCONT_ECC_ENC		(1<<18)
+#define NFCONT_WP		(1<<16)
+#define NFCONT_MECCLOCK		(1<<7)
+#define NFCONT_SECCLOCK		(1<<6)
+#define NFCONT_INITMECC		(1<<5)
+#define NFCONT_INITSECC		(1<<4)
+#define NFCONT_INITECC		(NFCONT_INITMECC | NFCONT_INITSECC)
+#define NFCONT_CS_ALT		(1<<1)
+#define NFCONT_CS		(1<<1)
+#define NFSTAT_ECCENCDONE	(1<<7)
+#define NFSTAT_ECCDECDONE	(1<<6)
+#define NFSTAT_RnB		(1<<0)
+#define NFESTAT0_ECCBUSY	(1<<31)
+
+/*
+ * Interrupt
+ */
+#define ELFIN_INTERRUPT_BASE	0x4a000000
+
+#define INTMSK_OFFSET		0x08
+#define INTSUBMSK_OFFSET	0x1c
+#define INTMOD_OFFSET		0x04
+
+#define SRCPND_REG		__REG(0x4a000000)
+#define INTMOD_REG		__REG(0x4a000004)
+#define INTMSK_REG		__REG(0x4a000008)
+#define INTPND_REG		__REG(0x4a000010)
+#define INTOFFSET_REG		__REG(0x4a000014)
+#define SUBSRCPND_REG		__REG(0x4a000018)
+#define INTSUBMSK_REG		__REG(0x4a00001C)
+#define SUBSRCPND2_REG		__REG(0x4a000030)
+#define INTSUBMSK2_REG		__REG(0x4a000034)
+#define PRIORITY_MODE_REG	__REG(0x4a000038)
+#define PRIORITY_UPDATE_REG	__REG(0x4a00003c)
+
+/*
+ * LCD Controller
+ */
+#define ELFIN_LCD_BASE	0x4c800000
+
+#define VIDCON0		(0x4c800000)
+#define VIDCON1		(0x4c800004)
+#define VIDTCON0	(0x4c800008)
+#define VIDTCON1	(0x4c80000C)
+#define VIDTCON2	(0x4c800010)
+#define WINCON0		(0x4c800014)
+#define WINCON1		(0x4c800018)
+#define VIDOSD0A	(0x4c800028)
+#define VIDOSD0B	(0x4c80002C)
+#define VIDOSD0C	(0x4c800030)
+#define VIDOSD1A	(0x4c800034)
+#define VIDOSD1B	(0x4c800038)
+#define VIDOSD1C	(0x4c80003C)
+#define VIDW00ADD0B0	(0x4c800064)
+#define VIDW00ADD0B1	(0x4c800068)
+#define VIDW01ADD0	(0x4c80006C)
+#define VIDW00ADD1B0	(0x4c80007C)
+#define VIDW00ADD1B1	(0x4c800080)
+#define VIDW01ADD1	(0x4c800084)
+#define VIDW00ADD2B0	(0x4c800094)
+#define VIDW00ADD2B1	(0x4c800098)
+#define VIDW01ADD2	(0x4c80009C)
+#define VIDINTCON	(0x4c8000AC)
+#define W1KEYCON0	(0x4c8000B0)
+#define W1KEYCON1	(0x4c8000B4)
+#define W2KEYCON0	(0x4c8000B8)
+#define W2KEYCON1	(0x4c8000BC)
+#define W3KEYCON0	(0x4c8000C0)
+#define W3KEYCON1	(0x4c8000C4)
+#define W4KEYCON0	(0x4c8000C8)
+#define W4KEYCON1	(0x4c8000CC)
+#define WIN0MAP		(0x4c8000D0)
+#define WIN1MAP		(0x4c8000D4)
+#define WPALCON		(0x4c8000E4)
+#define SYSIFCON0	(0x4c800130)
+#define SYSIFCON1	(0x4c800134)
+#define DITHMODE1	(0x4c800138)
+#define SIFCCON0	(0x4c80013C)
+#define SIFCCON1	(0x4c800140)
+#define SIFCCON2	(0x4c800144)
+#define CPUTRIGCON1	(0x4c80015C)
+#define CPUTRIGCON2	(0x4c800160)
+#define VIDW00ADD0B1	(0x4c800068)
+#define VIDW01ADD0	(0x4c80006C)
+
+
+/*
+ * Watchdog timer
+ */
+#define ELFIN_WATCHDOG_BASE	0x53000000
+
+#define WTCON_REG		__REG(0x53000000)
+#define WTDAT_REG		__REG(0x53000004)
+#define WTCNT_REG		__REG(0x53000008)
+
+/*
+ * EBI(External Bus Interface)
+ */
+#define EBIPR_REG		__REG(0x48800000)
+#define BANK_CFG_REG		__REG(0x48800004)
+
+/*
+ * SSMC
+ */
+#define SMBIDCYR0_REG	__REG(0x4F000000)
+#define SMBIDCYR1_REG	__REG(0x4F000020)
+#define SMBIDCYR2_REG	__REG(0x4F000040)
+#define SMBIDCYR3_REG	__REG(0x4F000060)
+#define SMBIDCYR4_REG	__REG(0x4F000080)
+#define SMBIDCYR5_REG	__REG(0x4F0000A0)
+
+#define SMBWSTRDR0_REG	__REG(0x4F000004)
+#define SMBWSTRDR1_REG	__REG(0x4F000024)
+#define SMBWSTRDR2_REG	__REG(0x4F000044)
+#define SMBWSTRDR3_REG	__REG(0x4F000064)
+#define SMBWSTRDR4_REG	__REG(0x4F000084)
+#define SMBWSTRDR5_REG	__REG(0x4F0000A4)
+
+#define SMBWSTWRR0_REG	__REG(0x4F000008)
+#define SMBWSTWRR1_REG	__REG(0x4F000028)
+#define SMBWSTWRR2_REG	__REG(0x4F000048)
+#define SMBWSTWRR3_REG	__REG(0x4F000068)
+#define SMBWSTWRR4_REG	__REG(0x4F000088)
+#define SMBWSTWRR5_REG	__REG(0x4F0000A8)
+
+#define SMBWSTOENR0_REG __REG(0x4F00000C)
+#define SMBWSTOENR1_REG __REG(0x4F00002C)
+#define SMBWSTOENR2_REG __REG(0x4F00004C)
+#define SMBWSTOENR3_REG __REG(0x4F00006C)
+#define SMBWSTOENR4_REG __REG(0x4F00008C)
+#define SMBWSTOENR5_REG __REG(0x4F0000AC)
+
+#define SMBWSTWENR0_REG	__REG(0x4F000010)
+#define SMBWSTWENR1_REG	__REG(0x4F000030)
+#define SMBWSTWENR2_REG	__REG(0x4F000050)
+#define SMBWSTWENR3_REG __REG(0x4F000070)
+#define SMBWSTWENR4_REG __REG(0x4F000090)
+#define SMBWSTWENR5_REG __REG(0x4F0000B0)
+
+#define SMBCR0_REG	__REG(0x4F000014)
+#define SMBCR1_REG	__REG(0x4F000034)
+#define SMBCR2_REG	__REG(0x4F000054)
+#define SMBCR3_REG	__REG(0x4F000074)
+#define SMBCR4_REG	__REG(0x4F000094)
+#define SMBCR5_REG	__REG(0x4F0000B4)
+
+#define SMBSR0_REG	__REG(0x4F000018)
+#define SMBSR1_REG	__REG(0x4F000038)
+#define SMBSR2_REG	__REG(0x4F000058)
+#define SMBSR3_REG	__REG(0x4F000078)
+#define SMBSR4_REG	__REG(0x4F000098)
+#define SMBSR5_REG	__REG(0x4F0000B8)
+
+#define SMBWSTBDR0_REG	__REG(0x4F00001C)
+#define SMBWSTBDR1_REG	__REG(0x4F00003C)
+#define SMBWSTBDR2_REG	__REG(0x4F00005C)
+#define SMBWSTBDR3_REG	__REG(0x4F00007C)
+#define SMBWSTBDR4_REG	__REG(0x4F00009C)
+#define SMBWSTBDR5_REG	__REG(0x4F0000BC)
+
+#define SSMCSR_REG	__REG(0x4F000200)
+#define SSMCCR_REG	__REG(0x4F000204)
+
+/*
+ * UART
+ */
+#define ELFIN_UART_BASE	0x50000000
+
+#define ULCON0_REG		__REG(0x50000000)
+#define UCON0_REG		__REG(0x50000004)
+#define UFCON0_REG		__REG(0x50000008)
+#define UMCON0_REG		__REG(0x5000000C)
+#define UTRSTAT0_REG		__REG(0x50000010)
+#define UERSTAT0_REG		__REG(0x50000014)
+#define UFSTAT0_REG		__REG(0x50000018)
+#define UMSTAT0_REG		__REG(0x5000001C)
+#define UTXH0_REG		__REG(0x50000020)
+#define URXH0_REG		__REG(0x50000024)
+#define UBRDIV0_REG		__REG(0x50000028)
+
+#define ULCON1_REG		__REG(0x50004000)
+#define UCON1_REG		__REG(0x50004004)
+#define UFCON1_REG		__REG(0x50004008)
+#define UMCON1_REG		__REG(0x5000400C)
+#define UTRSTAT1_REG		__REG(0x50004010)
+#define UERSTAT1_REG		__REG(0x50004014)
+#define UFSTAT1_REG		__REG(0x50004018)
+#define UMSTAT1_REG		__REG(0x5000401C)
+#define UTXH1_REG		__REG(0x50004020)
+#define URXH1_REG		__REG(0x50004024)
+#define UBRDIV1_REG		__REG(0x50004028)
+
+#define ULCON2_REG		__REG(0x50008000)
+#define UCON2_REG		__REG(0x50008004)
+#define UFCON2_REG		__REG(0x50008008)
+#define UMCON2_REG		__REG(0x5000800C)
+#define UTRSTAT2_REG		__REG(0x50008010)
+#define UERSTAT2_REG		__REG(0x50008014)
+#define UFSTAT2_REG		__REG(0x50008018)
+#define UMSTAT2_REG		__REG(0x5000801C)
+#define UTXH2_REG		__REG(0x50008020)
+#define URXH2_REG		__REG(0x50008024)
+#define UBRDIV2_REG		__REG(0x50008028)
+
+#define ULCON_OFFSET		0x00
+#define UCON_OFFSET		0x04
+#define UFCON_OFFSET		0x08
+#define UMCON_OFFSET		0x0C
+#define UTRSTAT_OFFSET		0x10
+#define UERSTAT_OFFSET		0x14
+#define UFSTAT_OFFSET		0x18
+#define UMSTAT_OFFSET		0x1C
+#define UTXH_OFFSET		0x20
+#define URXH_OFFSET		0x24
+#define UBRDIV_OFFSET		0x28
+#define UDIVSLOT_OFFSET		0x2c
+
+
+#define UTRSTAT_TX_EMPTY	(1 << 2)
+#define UTRSTAT_RX_READY	(1 << 0)
+#define UART_ERR_MASK		0xF
+
+/*
+ * PWM timer
+ */
+#define ELFIN_TIMER_BASE	0x51000000
+
+#define TCFG0_REG		__REG(0x51000000)
+#define TCFG1_REG		__REG(0x51000004)
+#define TCON_REG		__REG(0x51000008)
+#define TCNTB0_REG		__REG(0x5100000C)
+#define TCMPB0_REG		__REG(0x51000010)
+#define TCNTO0_REG		__REG(0x51000014)
+#define TCNTB1_REG		__REG(0x51000018)
+#define TCMPB1_REG		__REG(0x5100001C)
+#define TCNTO1_REG		__REG(0x51000020)
+#define TCNTB2_REG		__REG(0x51000024)
+#define TCMPB2_REG		__REG(0x51000028)
+#define TCNTO2_REG		__REG(0x5100002C)
+#define TCNTB3_REG		__REG(0x51000030)
+#define TCMPB3_REG		__REG(0x51000034)
+#define TCNTO3_REG		__REG(0x51000038)
+#define TCNTB4_REG		__REG(0x5100003C)
+#define TCNTO4_REG		__REG(0x51000040)
+
+/* Fields */
+#define fTCFG0_DZONE		Fld(8,16)       /* the dead zone length (= timer 0) */
+#define fTCFG0_PRE1		Fld(8,8)        /* prescaler value for time 2,3,4 */
+#define fTCFG0_PRE0		Fld(8,0)        /* prescaler value for time 0,1 */
+#define fTCFG1_MUX4		Fld(4,16)
+/* bits */
+#define TCFG0_DZONE(x)		FInsrt((x), fTCFG0_DZONE)
+#define TCFG0_PRE1(x)		FInsrt((x), fTCFG0_PRE1)
+#define TCFG0_PRE0(x)		FInsrt((x), fTCFG0_PRE0)
+#define TCON_4_AUTO		(1 << 22)       /* auto reload on/off for Timer 4 */
+#define TCON_4_UPDATE		(1 << 21)       /* manual Update TCNTB4 */
+#define TCON_4_ONOFF		(1 << 20)       /* 0: Stop, 1: start Timer 4 */
+#define COUNT_4_ON		(TCON_4_ONOFF*1)
+#define COUNT_4_OFF		(TCON_4_ONOFF*0)
+#define TCON_3_AUTO		(1 << 19)       /* auto reload on/off for Timer 3 */
+#define TIMER3_ATLOAD_ON	(TCON_3_AUTO*1)
+#define TIMER3_ATLAOD_OFF	FClrBit(TCON, TCON_3_AUTO)
+#define TCON_3_INVERT		(1 << 18)       /* 1: Inverter on for TOUT3 */
+#define TIMER3_IVT_ON		(TCON_3_INVERT*1)
+#define TIMER3_IVT_OFF		(FClrBit(TCON, TCON_3_INVERT))
+#define TCON_3_MAN		(1 << 17)       /* manual Update TCNTB3,TCMPB3 */
+#define TIMER3_MANUP		(TCON_3_MAN*1)
+#define TIMER3_NOP		(FClrBit(TCON, TCON_3_MAN))
+#define TCON_3_ONOFF		(1 << 16)       /* 0: Stop, 1: start Timer 3 */
+#define TIMER3_ON		(TCON_3_ONOFF*1)
+#define TIMER3_OFF		(FClrBit(TCON, TCON_3_ONOFF))
+/* macros */
+#define GET_PRESCALE_TIMER4(x)	FExtr((x), fTCFG0_PRE1)
+#define GET_DIVIDER_TIMER4(x)	FExtr((x), fTCFG1_MUX4)
+
+/*
+ * RTC Controller
+ */
+#define ELFIN_RTC_BASE		0x57000000
+#define RTCCON_REG		__REG(0x57000040)
+#define TICNT_REG		__REG(0x57000044)
+#define RTCALM_REG		__REG(0x57000050)
+#define ALMSEC_REG		__REG(0x57000054)
+#define ALMMIN_REG		__REG(0x57000058)
+#define ALMHOUR_REG		__REG(0x5700005c)
+#define ALMDATE_REG		__REG(0x57000060)
+#define ALMMON_REG		__REG(0x57000064)
+#define ALMYEAR_REG		__REG(0x57000068)
+#define BCDSEC_REG		__REG(0x57000070)
+#define BCDMIN_REG		__REG(0x57000074)
+#define BCDHOUR_REG		__REG(0x57000078)
+#define BCDDATE_REG		__REG(0x5700007c)
+#define BCDDAY_REG		__REG(0x57000080)
+#define BCDMON_REG		__REG(0x57000084)
+#define BCDYEAR_REG		__REG(0x57000088)
+
+/*
+ * HS MMC Interface (chapter 28)
+ */
+#define ELFIN_HSMMC_BASE	0x4a800000
+
+#define HM_SYSAD	(ELFIN_HSMMC_BASE+0x00)
+#define HM_BLKSIZE	(ELFIN_HSMMC_BASE+0x04)
+#define HM_BLKCNT	(ELFIN_HSMMC_BASE+0x06)
+#define HM_ARGUMENT	(ELFIN_HSMMC_BASE+0x08)
+#define HM_TRNMOD	(ELFIN_HSMMC_BASE+0x0c)
+#define HM_CMDREG	(ELFIN_HSMMC_BASE+0x0e)
+#define HM_RSPREG0	(ELFIN_HSMMC_BASE+0x10)
+#define HM_RSPREG1	(ELFIN_HSMMC_BASE+0x14)
+#define HM_RSPREG2	(ELFIN_HSMMC_BASE+0x18)
+#define HM_RSPREG3	(ELFIN_HSMMC_BASE+0x1c)
+#define HM_BDATA	(ELFIN_HSMMC_BASE+0x20)
+#define HM_PRNSTS	(ELFIN_HSMMC_BASE+0x24)
+#define HM_HOSTCTL	(ELFIN_HSMMC_BASE+0x28)
+#define HM_PWRCON	(ELFIN_HSMMC_BASE+0x29)
+#define HM_BLKGAP	(ELFIN_HSMMC_BASE+0x2a)
+#define HM_WAKCON	(ELFIN_HSMMC_BASE+0x2b)
+#define HM_CLKCON	(ELFIN_HSMMC_BASE+0x2c)
+#define HM_TIMEOUTCON	(ELFIN_HSMMC_BASE+0x2e)
+#define HM_SWRST	(ELFIN_HSMMC_BASE+0x2f)
+#define HM_NORINTSTS	(ELFIN_HSMMC_BASE+0x30)
+#define HM_ERRINTSTS	(ELFIN_HSMMC_BASE+0x32)
+#define HM_NORINTSTSEN	(ELFIN_HSMMC_BASE+0x34)
+#define HM_ERRINTSTSEN	(ELFIN_HSMMC_BASE+0x36)
+#define HM_NORINTSIGEN	(ELFIN_HSMMC_BASE+0x38)
+#define HM_ERRINTSIGEN	(ELFIN_HSMMC_BASE+0x3a)
+#define HM_ACMD12ERRSTS	(ELFIN_HSMMC_BASE+0x3c)
+#define HM_CAPAREG	(ELFIN_HSMMC_BASE+0x40)
+#define HM_MAXCURR	(ELFIN_HSMMC_BASE+0x48)
+#define HM_CONTROL2	(ELFIN_HSMMC_BASE+0x80)
+#define HM_CONTROL3	(ELFIN_HSMMC_BASE+0x84)
+#define HM_CONTROL4	(ELFIN_HSMMC_BASE+0x8C)
+#define HM_HCVER	(ELFIN_HSMMC_BASE+0xfe)
+
+#define ELFIN_CFCON_BASE	0x4B800000
+
+#define ATA_MUX			(ELFIN_CFCON_BASE+0x1800)
+#define ELFIN_ATA_BASE		(ELFIN_CFCON_BASE+0x1900)
+
+/*
+ * ATA Register (chapter 8)
+ */
+#define ATA_CONTROL	(ELFIN_ATA_BASE + 0x00)
+#define ATA_STATUS	(ELFIN_ATA_BASE + 0x04)
+#define ATA_COMMAND	(ELFIN_ATA_BASE + 0x08)
+#define ATA_SWRST	(ELFIN_ATA_BASE + 0x0c)
+#define ATA_IRQ		(ELFIN_ATA_BASE + 0x10)
+#define ATA_IRQ_MASK	(ELFIN_ATA_BASE + 0x14)
+#define ATA_CFG		(ELFIN_ATA_BASE + 0x18)
+
+#define ATA_PIO_TIME	(ELFIN_ATA_BASE + 0x2c)
+#define ATA_UDMA_TIME	(ELFIN_ATA_BASE + 0x30)
+#define ATA_XFR_NUM	(ELFIN_ATA_BASE + 0x34)
+#define ATA_XFR_CNT	(ELFIN_ATA_BASE + 0x38)
+#define ATA_TBUF_START	(ELFIN_ATA_BASE + 0x3c)
+#define ATA_TBUF_SIZE	(ELFIN_ATA_BASE + 0x40)
+#define ATA_SBUF_START	(ELFIN_ATA_BASE + 0x44)
+#define ATA_SBUF_SIZE	(ELFIN_ATA_BASE + 0x48)
+#define ATA_CADR_TBUF	(ELFIN_ATA_BASE + 0x4c)
+#define ATA_CADR_SBUF	(ELFIN_ATA_BASE + 0x50)
+#define ATA_PIO_DTR	(ELFIN_ATA_BASE + 0x54)
+#define ATA_PIO_FED	(ELFIN_ATA_BASE + 0x58)
+#define ATA_PIO_SCR	(ELFIN_ATA_BASE + 0x5c)
+#define ATA_PIO_LLR	(ELFIN_ATA_BASE + 0x60)
+#define ATA_PIO_LMR	(ELFIN_ATA_BASE + 0x64)
+#define ATA_PIO_LHR	(ELFIN_ATA_BASE + 0x68)
+#define ATA_PIO_DVR	(ELFIN_ATA_BASE + 0x6c)
+#define ATA_PIO_CSD	(ELFIN_ATA_BASE + 0x70)
+#define ATA_PIO_DAD	(ELFIN_ATA_BASE + 0x74)
+#define ATA_PIO_READY	(ELFIN_ATA_BASE + 0x78)
+#define ATA_PIO_RDATA	(ELFIN_ATA_BASE + 0x7c)
+#define BUS_FIFO_STATUS	(ELFIN_ATA_BASE + 0x90)
+#define ATA_FIFO_STATUS	(ELFIN_ATA_BASE + 0x94)
+
+/*
+ * SD/MMC Interface (chapter 27)
+ */
+#define ELFIN_SDI_BASE		0x5a000000
+
+#define SDICON		(ELFIN_SDI_BASE+0x00)	/* SDI Control */
+#define SDIPRE		(ELFIN_SDI_BASE+0x04)	/* SDI baud rate prescaler */
+#define SDICARG		(ELFIN_SDI_BASE+0x08)	/* SDI command argument */
+#define SDICCON		(ELFIN_SDI_BASE+0x0c)	/* SDI command control */
+#define SDICSTA		(ELFIN_SDI_BASE+0x10)	/* SDI command status */
+#define SDIRSP0		(ELFIN_SDI_BASE+0x14)	/* SDI response 0 */
+#define SDIRSP1		(ELFIN_SDI_BASE+0x18)	/* SDI response 1 */
+#define SDIRSP2		(ELFIN_SDI_BASE+0x1c)	/* SDI response 2 */
+#define SDIRSP3		(ELFIN_SDI_BASE+0x20)	/* SDI response 3 */
+#define SDIDTIMER	(ELFIN_SDI_BASE+0x24)	/* SDI data/busy timer */
+#define SDIBSIZE	(ELFIN_SDI_BASE+0x28)	/* SDI block size */
+#define SDIDCON		(ELFIN_SDI_BASE+0x2c)	/* SDI data control */
+#define SDIDCNT		(ELFIN_SDI_BASE+0x30)	/* SDI data remain counter */
+#define SDIDSTA		(ELFIN_SDI_BASE+0x34)	/* SDI data status */
+#define SDIFSTA		(ELFIN_SDI_BASE+0x38)	/* SDI FIFO status */
+#define SDIIMSK		(ELFIN_SDI_BASE+0x3c)	/* SDI Interrupt Mask */
+#define SDIDAT		(ELFIN_SDI_BASE+0x40)	/* SDI Data register */
+
+
+/*
+ * USB Device (Chapter 17)
+ */
+#define USB_DEVICE_PHYS_ADR	0x49800000
+#define bUD(Nb)		__REG(USB_DEVICE_PHYS_ADR + (Nb))
+
+#define UD_INDEX_REG			bUD(0x00) /* Index register */
+#define UD_EP_INT_REG			bUD(0x04) /* EP Interrupt pending and clear */
+#define UD_EP_INT_EN_REG		bUD(0x08) /* EP Interrupt enable */
+#define UD_FUNC_ADDR_REG		bUD(0x0c) /* Function address */
+#define UD_FRAME_NUM_REG		bUD(0x10) /* Frame number */
+#define UD_EP_DIR_REG			bUD(0x14) /* Endpoint direction */
+#define UD_TEST_REG			bUD(0x18) /* Test register */
+#define UD_SYS_STATUS_REG		bUD(0x1c) /* System status */
+#define UD_SYS_CON_REG			bUD(0x20) /* System control */
+#define UD_EP0_STATUS_REG		bUD(0x24) /* Endpoint 0 status */
+#define UD_EP0_CON_REG			bUD(0x28) /* Endpoint 0 control */
+#define UD_EP0_BUF_REG			bUD(0x60) /* Endpoint 0 Buffer */
+#define UD_EP1_BUF_REG			bUD(0x64) /* Endpoint 1 Buffer */
+#define UD_EP2_BUF_REG			bUD(0x68) /* Endpoint 2 Buffer */
+#define UD_EP3_BUF_REG			bUD(0x6c) /* Endpoint 3 Buffer */
+#define UD_EP4_BUF_REG			bUD(0x70) /* Endpoint 4 Buffer */
+#define UD_EP5_BUF_REG			bUD(0x74) /* Endpoint 5 Buffer */
+#define UD_EP6_BUF_REG			bUD(0x78) /* Endpoint 6 Buffer */
+#define UD_EP7_BUF_REG			bUD(0x7c) /* Endpoint 7 Buffer */
+#define UD_EP8_BUF_REG			bUD(0x80) /* Endpoint 8 Buffer */
+#define UD_FIFO_CON_REG			bUD(0x100) /* Burst FIFO-DMA Control */
+#define UD_FIFO_STATUS_REG		bUD(0x104) /* Burst FIFO Status */
+
+#define UD_EP_STATUS_REG		bUD(0x2c) /* Endpoints status */
+#define UD_EP_CON_REG			bUD(0x30) /* Endpoints control */
+#define UD_BYTE_READ_CNT_REG		bUD(0x34) /* Byte read count */
+#define UD_BYTE_WRITE_CNT_REG		bUD(0x38) /* Byte write count */
+#define UD_MAX_PKT_REG			bUD(0x3c) /* Max packet size */
+#define UD_DMA_CON_REG			bUD(0x40) /* DMA control */
+#define UD_DMA_CNT_REG			bUD(0x44) /* DMA count */
+#define UD_DMA_FIFO_CNT_REG		bUD(0x48) /* DMA FIFO count */
+#define UD_DMA_TOTAL_CNT1_REG		bUD(0x4c) /* DMA Total Transfer count1 */
+#define UD_DMA_TOTAL_CNT2_REG		bUD(0x50) /* DMA Total Transfer count2 */
+#define UD_DMA_IF_CON_REG		bUD(0x84) /* DMA interface Control */
+#define UD_DMA_MEM_BASE_ADDR_REG	bUD(0x88) /* Mem Base Addr */
+#define UD_DMA_MEM_CURRENT_ADDR_REG	bUD(0x8c) /* Mem current Addr */
+
+/* index register set */
+#define UD_INDEX_EP0		0
+#define UD_INDEX_EP1		1
+#define UD_INDEX_EP2		2
+#define UD_INDEX_EP3		3
+#define UD_INDEX_EP4		4
+
+/* endpoint interrupt flag */
+#define UD_INT_EP4		(1<<4)	// R/C
+#define UD_INT_EP3		(1<<3)	// R/C
+#define UD_INT_EP2		(1<<2)	// R/C
+#define UD_INT_EP1		(1<<1)	// R/C
+#define UD_INT_EP0		(1<<0)	// R/C
+
+/* endpoint interrupt enable flag */
+#define UD_INT_EN_EP4		(1<<4)
+#define UD_INT_EN_EP3		(1<<3)
+#define UD_INT_EN_EP2		(1<<2)
+#define UD_INT_EN_EP1		(1<<1)
+#define UD_INT_EN_EP0		(1<<0)
+
+/* system status register Bits */
+#define UD_INT_ERR		(0xff80)
+#define UD_INT_VBUSON		(1<<8)
+#define UD_INT_HSP		(1<<4) /* Host SPeed */
+#define UD_INT_SDE		(1<<3) /* Speed Detection Dnd */
+#define UD_INT_RESUME		(1<<2)
+#define UD_INT_SUSPEND		(1<<1)
+#define UD_INT_RESET		(1<<0)
+
+/* system control register Bits */
+#define UD_RRD_EN		(1<<5)
+#define UD_SUS_EN		(1<<1)
+#define UD_RST_EN		(1<<0)
+
+/* EP0 status register Bits */
+#define UD_EP0_SENT_STALL              (0x01<<4)
+#define UD_EP0_DATA_END                (0x01<<3)
+#define UD_EP0_SETUP_END               (0x03<<2)
+#define UD_EP0_TX_SUCCESS              (0x01<<1)
+#define UD_EP0_RX_SUCCESS              (0x01<<0)
+
+/* Endpoint Status Register Bits */
+#define UD_DMA_TOTAL_COUNT_ZERO        (0x1<<9)
+#define UD_SHORT_PKT_RECEIVED          (0x1<<8)
+#define UD_EP_FIFO_FLUSH               (0x1<<6)
+#define UD_EP_SENT_STALL               (0x1<<5)
+#define UD_EP_TX_SUCCESS               (0x1<<1)
+#define UD_EP_RX_SUCCESS               (0x1<<0)
+
+// USB Dma Operation
+#define UD_DMA_AUTO_RX_DISABLE         (0x1<<5)
+#define UD_DMA_FLY_ENABLE              (0x1<<4)
+#define UD_DMA_FLY_DISABLE             (0x0<<4)
+#define UD_DMA_DEMEND_ENABLE           (0x1<<3)
+#define UD_DMA_DEMEND_DISABLE          (0x0<<3)
+#define UD_DMA_TX_START                (0x1<<2)
+#define UD_DMA_TX_STOP                 (0x0<<2)
+#define UD_DMA_RX_START                (0x1<<1)
+#define UD_DMA_RX_STOP                 (0x0<<1)
+#define UD_USB_DMA_MODE                (0x1<<0)
+#define UD_USB_INT_MODE                (0x0<<0)
+
+/* DMA Interface Control Register Bits */
+#define UD_MAX_BURST_INCR16            (0x3<<0)
+#define UD_MAX_BURST_INCR8             (0x2<<0)
+#define UD_MAX_BURST_INCR4             (0x1<<0)
+
+/*Burst FIFO Control Register Bits */
+#define UD_DMA_ENABLE                  (0x1<<8)
+#define UD_DMA_DISABLE                 (0x0<<8)
+
+/* include common stuff */
+#ifndef __ASSEMBLY__
+static inline S3C24X0_MEMCTL * S3C24X0_GetBase_MEMCTL(void)
+{
+	return (S3C24X0_MEMCTL *)(ELFIN_MEMCTL_BASE);
+}
+static inline S3C24X0_USB_HOST * S3C24X0_GetBase_USB_HOST(void)
+{
+	return (S3C24X0_USB_HOST *)ELFIN_USB_HOST_BASE;
+}
+static inline S3C24X0_INTERRUPT * S3C24X0_GetBase_INTERRUPT(void)
+{
+	return (S3C24X0_INTERRUPT *)ELFIN_INTERRUPT_BASE;
+}
+static inline S3C24X0_DMAS * S3C24X0_GetBase_DMAS(void)
+{
+	return (S3C24X0_DMAS *)ELFIN_DMA_BASE;
+}
+static inline S3C24X0_CLOCK_POWER * S3C24X0_GetBase_CLOCK_POWER(void)
+{
+	return (S3C24X0_CLOCK_POWER *)ELFIN_CLOCK_POWER_BASE;
+}
+static inline S3C24X0_LCD * S3C24X0_GetBase_LCD(void)
+{
+	return (S3C24X0_LCD *)ELFIN_LCD_BASE;
+}
+static inline S3C2410_NAND * S3C2410_GetBase_NAND(void)
+{
+	return (S3C2410_NAND *)ELFIN_NAND_BASE;
+}
+static inline S3C24X0_UART * S3C24X0_GetBase_UART(S3C24X0_UARTS_NR nr)
+{
+	return (S3C24X0_UART *)(ELFIN_UART_BASE + (nr * 0x4000));
+}
+static inline S3C24X0_TIMERS * S3C24X0_GetBase_TIMERS(void)
+{
+	return (S3C24X0_TIMERS *)ELFIN_TIMER_BASE;
+}
+static inline S3C24X0_USB_DEVICE * S3C24X0_GetBase_USB_DEVICE(void)
+{
+	return (S3C24X0_USB_DEVICE *)ELFIN_USB_DEVICE_BASE;
+}
+static inline S3C24X0_WATCHDOG * S3C24X0_GetBase_WATCHDOG(void)
+{
+	return (S3C24X0_WATCHDOG *)ELFIN_WATCHDOG_BASE;
+}
+static inline S3C24X0_I2C * S3C24X0_GetBase_I2C(void)
+{
+	return (S3C24X0_I2C *)ELFIN_I2C_BASE;
+}
+static inline S3C24X0_I2S * S3C24X0_GetBase_I2S(void)
+{
+	return (S3C24X0_I2S *)ELFIN_I2S_BASE;
+}
+static inline S3C24X0_GPIO * S3C24X0_GetBase_GPIO(void)
+{
+	return (S3C24X0_GPIO *)ELFIN_GPIO_BASE;
+}
+static inline S3C24X0_RTC * S3C24X0_GetBase_RTC(void)
+{
+	return (S3C24X0_RTC *)ELFIN_RTC_BASE;
+}
+static inline S3C2410_ADC * S3C2410_GetBase_ADC(void)
+{
+	return (S3C2410_ADC *)ELFIN_ADC_BASE;
+}
+static inline S3C24X0_SPI * S3C24X0_GetBase_SPI(void)
+{
+	return (S3C24X0_SPI *)ELFIN_SPI_BASE;
+}
+#else /* #ifndef __ASSEMBLY__ */
+
+/* watchdog */
+#define WTCON_OFFSET		0x00
+
+/* LCD controller */
+#define LCDBGCON_OFFSET		0x5c
+
+#endif /* #ifndef __ASSEMBLY__ */
+
+/* PENDING BIT */
+#define BIT_EINT0		(0x1)
+#define BIT_EINT1		(0x1<<1)
+#define BIT_EINT2		(0x1<<2)
+#define BIT_EINT3		(0x1<<3)
+#define BIT_EINT4_7		(0x1<<4)
+#define BIT_EINT8_23		(0x1<<5)
+#define BIT_BAT_FLT		(0x1<<7)
+#define BIT_TICK		(0x1<<8)
+#define BIT_WDT			(0x1<<9)
+#define BIT_TIMER0		(0x1<<10)
+#define BIT_TIMER1		(0x1<<11)
+#define BIT_TIMER2		(0x1<<12)
+#define BIT_TIMER3		(0x1<<13)
+#define BIT_TIMER4		(0x1<<14)
+#define BIT_UART2		(0x1<<15)
+#define BIT_LCD			(0x1<<16)
+#define BIT_DMA0		(0x1<<17)
+#define BIT_DMA1		(0x1<<18)
+#define BIT_DMA2		(0x1<<19)
+#define BIT_DMA3		(0x1<<20)
+#define BIT_SDI			(0x1<<21)
+#define BIT_SPI0		(0x1<<22)
+#define BIT_UART1		(0x1<<23)
+#define BIT_USBD		(0x1<<25)
+#define BIT_USBH		(0x1<<26)
+#define BIT_IIC			(0x1<<27)
+#define BIT_UART0		(0x1<<28)
+#define BIT_SPI1		(0x1<<29)
+#define BIT_RTC			(0x1<<30)
+#define BIT_ADC			(0x1<<31)
+#define BIT_ALLMSK		(0xFFFFFFFF)
+
+#define S3C_USBD_DETECT_IRQ()	(SRCPND_REG & BIT_USBD)
+#define S3C_USBD_CLEAR_IRQ()	do { \
+					SRCPND_REG = BIT_USBD; \
+				} while (0)
+#define ClearPending(bit) {\
+                rSRCPND = bit;\
+                rINTPND = bit;\
+                rINTPND;\
+                }
+
+/* Wait until rINTPND is changed for the case that the ISR is very short. */
+
+#endif /*__S3C2416_H__*/
diff -NBbur u-boot-2010.09-orig/arch/arm/include/asm/arch-s3c2416/s3c24xx.h u-boot-2010.09-smdk2416/arch/arm/include/asm/arch-s3c2416/s3c24xx.h
--- u-boot-2010.09-orig/arch/arm/include/asm/arch-s3c2416/s3c24xx.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/include/asm/arch-s3c2416/s3c24xx.h	2011-09-01 15:13:00.000000000 +0800
@@ -0,0 +1,1135 @@
+/*
+ * (C) Copyright 2003
+ * David Mller ELSOFT AG Switzerland. d.mueller@elsoft.ch
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/************************************************
+ * NAME	    : s3c24x0.h
+ * Version  : 31.3.2003
+ *
+ * common stuff for SAMSUNG S3C24X0 SoC
+ ************************************************/
+
+#ifndef __S3C24X0_H__
+#define __S3C24X0_H__
+
+typedef volatile u8	S3C24X0_REG8;
+typedef volatile u16	S3C24X0_REG16;
+typedef volatile u32	S3C24X0_REG32;
+
+/* Memory controller (see manual chapter 5) */
+typedef struct {
+	S3C24X0_REG32	BWSCON;
+	S3C24X0_REG32	BANKCON[8];
+	S3C24X0_REG32	REFRESH;
+	S3C24X0_REG32	BANKSIZE;
+	S3C24X0_REG32	MRSRB6;
+	S3C24X0_REG32	MRSRB7;
+} /*__attribute__((__packed__))*/ S3C24X0_MEMCTL;
+
+
+/* USB HOST (see manual chapter 12) */
+typedef struct {
+	S3C24X0_REG32	HcRevision;
+	S3C24X0_REG32	HcControl;
+	S3C24X0_REG32	HcCommonStatus;
+	S3C24X0_REG32	HcInterruptStatus;
+	S3C24X0_REG32	HcInterruptEnable;
+	S3C24X0_REG32	HcInterruptDisable;
+	S3C24X0_REG32	HcHCCA;
+	S3C24X0_REG32	HcPeriodCuttendED;
+	S3C24X0_REG32	HcControlHeadED;
+	S3C24X0_REG32	HcControlCurrentED;
+	S3C24X0_REG32	HcBulkHeadED;
+	S3C24X0_REG32	HcBuldCurrentED;
+	S3C24X0_REG32	HcDoneHead;
+	S3C24X0_REG32	HcRmInterval;
+	S3C24X0_REG32	HcFmRemaining;
+	S3C24X0_REG32	HcFmNumber;
+	S3C24X0_REG32	HcPeriodicStart;
+	S3C24X0_REG32	HcLSThreshold;
+	S3C24X0_REG32	HcRhDescriptorA;
+	S3C24X0_REG32	HcRhDescriptorB;
+	S3C24X0_REG32	HcRhStatus;
+	S3C24X0_REG32	HcRhPortStatus1;
+	S3C24X0_REG32	HcRhPortStatus2;
+} /*__attribute__((__packed__))*/ S3C24X0_USB_HOST;
+
+
+/* INTERRUPT (see manual chapter 14) */
+typedef struct {
+	S3C24X0_REG32	SRCPND;
+	S3C24X0_REG32	INTMOD;
+	S3C24X0_REG32	INTMSK;
+	S3C24X0_REG32	PRIORITY;
+	S3C24X0_REG32	INTPND;
+	S3C24X0_REG32	INTOFFSET;
+#ifdef CONFIG_S3C2410
+	S3C24X0_REG32	SUBSRCPND;
+	S3C24X0_REG32	INTSUBMSK;
+#endif
+} /*__attribute__((__packed__))*/ S3C24X0_INTERRUPT;
+
+
+/* DMAS (see manual chapter 8) */
+typedef struct {
+	S3C24X0_REG32	DISRC;
+#ifdef CONFIG_S3C2410
+	S3C24X0_REG32	DISRCC;
+#endif
+	S3C24X0_REG32	DIDST;
+#ifdef CONFIG_S3C2410
+	S3C24X0_REG32	DIDSTC;
+#endif
+	S3C24X0_REG32	DCON;
+	S3C24X0_REG32	DSTAT;
+	S3C24X0_REG32	DCSRC;
+	S3C24X0_REG32	DCDST;
+	S3C24X0_REG32	DMASKTRIG;
+#ifdef CONFIG_S3C2400
+	S3C24X0_REG32	res[1];
+#endif
+#ifdef CONFIG_S3C2410
+	S3C24X0_REG32	res[7];
+#endif
+} /*__attribute__((__packed__))*/ S3C24X0_DMA;
+
+typedef struct {
+	S3C24X0_DMA	dma[4];
+} /*__attribute__((__packed__))*/ S3C24X0_DMAS;
+
+
+/* CLOCK & POWER MANAGEMENT (see S3C2400 manual chapter 6) */
+/*                          (see S3C2410 manual chapter 7) */
+typedef struct {
+	S3C24X0_REG32	LOCKTIME;
+	S3C24X0_REG32	MPLLCON;
+	S3C24X0_REG32	UPLLCON;
+	S3C24X0_REG32	CLKCON;
+	S3C24X0_REG32	CLKSLOW;
+	S3C24X0_REG32	CLKDIVN;
+} /*__attribute__((__packed__))*/ S3C24X0_CLOCK_POWER;
+
+
+/* LCD CONTROLLER (see manual chapter 15) */
+typedef struct {
+	S3C24X0_REG32	LCDCON1;
+	S3C24X0_REG32	LCDCON2;
+	S3C24X0_REG32	LCDCON3;
+	S3C24X0_REG32	LCDCON4;
+	S3C24X0_REG32	LCDCON5;
+	S3C24X0_REG32	LCDSADDR1;
+	S3C24X0_REG32	LCDSADDR2;
+	S3C24X0_REG32	LCDSADDR3;
+	S3C24X0_REG32	REDLUT;
+	S3C24X0_REG32	GREENLUT;
+	S3C24X0_REG32	BLUELUT;
+	S3C24X0_REG32	res[8];
+	S3C24X0_REG32	DITHMODE;
+	S3C24X0_REG32	TPAL;
+#ifdef CONFIG_S3C2410
+	S3C24X0_REG32	LCDINTPND;
+	S3C24X0_REG32	LCDSRCPND;
+	S3C24X0_REG32	LCDINTMSK;
+	S3C24X0_REG32	LPCSEL;
+#endif
+} /*__attribute__((__packed__))*/ S3C24X0_LCD;
+
+
+/* NAND FLASH (see S3C2410 manual chapter 6) */
+typedef struct {
+	S3C24X0_REG32	NFCONF;
+	S3C24X0_REG32	NFCMD;
+	S3C24X0_REG32	NFADDR;
+	S3C24X0_REG32	NFDATA;
+	S3C24X0_REG32	NFSTAT;
+	S3C24X0_REG32	NFECC;
+} /*__attribute__((__packed__))*/ S3C2410_NAND;
+
+
+/* UART (see manual chapter 11) */
+typedef struct {
+	S3C24X0_REG32	ULCON;
+	S3C24X0_REG32	UCON;
+	S3C24X0_REG32	UFCON;
+	S3C24X0_REG32	UMCON;
+	S3C24X0_REG32	UTRSTAT;
+	S3C24X0_REG32	UERSTAT;
+	S3C24X0_REG32	UFSTAT;
+	S3C24X0_REG32	UMSTAT;
+#ifdef __BIG_ENDIAN
+	S3C24X0_REG8	res1[3];
+	S3C24X0_REG8	UTXH;
+	S3C24X0_REG8	res2[3];
+	S3C24X0_REG8	URXH;
+#else /* Little Endian */
+	S3C24X0_REG8	UTXH;
+	S3C24X0_REG8	res1[3];
+	S3C24X0_REG8	URXH;
+	S3C24X0_REG8	res2[3];
+#endif
+	S3C24X0_REG32	UBRDIV;
+} /*__attribute__((__packed__))*/ S3C24X0_UART;
+
+
+/* PWM TIMER (see manual chapter 10) */
+typedef struct {
+	S3C24X0_REG32	TCNTB;
+	S3C24X0_REG32	TCMPB;
+	S3C24X0_REG32	TCNTO;
+} /*__attribute__((__packed__))*/ S3C24X0_TIMER;
+
+typedef struct {
+	S3C24X0_REG32	TCFG0;
+	S3C24X0_REG32	TCFG1;
+	S3C24X0_REG32	TCON;
+	S3C24X0_TIMER	ch[4];
+	S3C24X0_REG32	TCNTB4;
+	S3C24X0_REG32	TCNTO4;
+} /*__attribute__((__packed__))*/ S3C24X0_TIMERS;
+
+
+/* USB DEVICE (see manual chapter 13) */
+typedef struct {
+#ifdef __BIG_ENDIAN
+	S3C24X0_REG8	res[3];
+	S3C24X0_REG8	EP_FIFO_REG;
+#else /*  little endian */
+	S3C24X0_REG8	EP_FIFO_REG;
+	S3C24X0_REG8	res[3];
+#endif
+} /*__attribute__((__packed__))*/ S3C24X0_USB_DEV_FIFOS;
+
+typedef struct {
+#ifdef __BIG_ENDIAN
+	S3C24X0_REG8	res1[3];
+	S3C24X0_REG8	EP_DMA_CON;
+	S3C24X0_REG8	res2[3];
+	S3C24X0_REG8	EP_DMA_UNIT;
+	S3C24X0_REG8	res3[3];
+	S3C24X0_REG8	EP_DMA_FIFO;
+	S3C24X0_REG8	res4[3];
+	S3C24X0_REG8	EP_DMA_TTC_L;
+	S3C24X0_REG8	res5[3];
+	S3C24X0_REG8	EP_DMA_TTC_M;
+	S3C24X0_REG8	res6[3];
+	S3C24X0_REG8	EP_DMA_TTC_H;
+#else /*  little endian */
+	S3C24X0_REG8	EP_DMA_CON;
+	S3C24X0_REG8	res1[3];
+	S3C24X0_REG8	EP_DMA_UNIT;
+	S3C24X0_REG8	res2[3];
+	S3C24X0_REG8	EP_DMA_FIFO;
+	S3C24X0_REG8	res3[3];
+	S3C24X0_REG8	EP_DMA_TTC_L;
+	S3C24X0_REG8	res4[3];
+	S3C24X0_REG8	EP_DMA_TTC_M;
+	S3C24X0_REG8	res5[3];
+	S3C24X0_REG8	EP_DMA_TTC_H;
+	S3C24X0_REG8	res6[3];
+#endif
+} /*__attribute__((__packed__))*/ S3C24X0_USB_DEV_DMAS;
+
+typedef struct {
+#ifdef __BIG_ENDIAN
+	S3C24X0_REG8	res1[3];
+	S3C24X0_REG8	FUNC_ADDR_REG;
+	S3C24X0_REG8	res2[3];
+	S3C24X0_REG8	PWR_REG;
+	S3C24X0_REG8	res3[3];
+	S3C24X0_REG8	EP_INT_REG;
+	S3C24X0_REG8	res4[15];
+	S3C24X0_REG8	USB_INT_REG;
+	S3C24X0_REG8	res5[3];
+	S3C24X0_REG8	EP_INT_EN_REG;
+	S3C24X0_REG8	res6[15];
+	S3C24X0_REG8	USB_INT_EN_REG;
+	S3C24X0_REG8	res7[3];
+	S3C24X0_REG8	FRAME_NUM1_REG;
+	S3C24X0_REG8	res8[3];
+	S3C24X0_REG8	FRAME_NUM2_REG;
+	S3C24X0_REG8	res9[3];
+	S3C24X0_REG8	INDEX_REG;
+	S3C24X0_REG8	res10[7];
+	S3C24X0_REG8	MAXP_REG;
+	S3C24X0_REG8	res11[3];
+	S3C24X0_REG8	EP0_CSR_IN_CSR1_REG;
+	S3C24X0_REG8	res12[3];
+	S3C24X0_REG8	IN_CSR2_REG;
+	S3C24X0_REG8	res13[7];
+	S3C24X0_REG8	OUT_CSR1_REG;
+	S3C24X0_REG8	res14[3];
+	S3C24X0_REG8	OUT_CSR2_REG;
+	S3C24X0_REG8	res15[3];
+	S3C24X0_REG8	OUT_FIFO_CNT1_REG;
+	S3C24X0_REG8	res16[3];
+	S3C24X0_REG8	OUT_FIFO_CNT2_REG;
+#else /*  little endian */
+	S3C24X0_REG8	FUNC_ADDR_REG;
+	S3C24X0_REG8	res1[3];
+	S3C24X0_REG8	PWR_REG;
+	S3C24X0_REG8	res2[3];
+	S3C24X0_REG8	EP_INT_REG;
+	S3C24X0_REG8	res3[15];
+	S3C24X0_REG8	USB_INT_REG;
+	S3C24X0_REG8	res4[3];
+	S3C24X0_REG8	EP_INT_EN_REG;
+	S3C24X0_REG8	res5[15];
+	S3C24X0_REG8	USB_INT_EN_REG;
+	S3C24X0_REG8	res6[3];
+	S3C24X0_REG8	FRAME_NUM1_REG;
+	S3C24X0_REG8	res7[3];
+	S3C24X0_REG8	FRAME_NUM2_REG;
+	S3C24X0_REG8	res8[3];
+	S3C24X0_REG8	INDEX_REG;
+	S3C24X0_REG8	res9[7];
+	S3C24X0_REG8	MAXP_REG;
+	S3C24X0_REG8	res10[7];
+	S3C24X0_REG8	EP0_CSR_IN_CSR1_REG;
+	S3C24X0_REG8	res11[3];
+	S3C24X0_REG8	IN_CSR2_REG;
+	S3C24X0_REG8	res12[3];
+	S3C24X0_REG8	OUT_CSR1_REG;
+	S3C24X0_REG8	res13[7];
+	S3C24X0_REG8	OUT_CSR2_REG;
+	S3C24X0_REG8	res14[3];
+	S3C24X0_REG8	OUT_FIFO_CNT1_REG;
+	S3C24X0_REG8	res15[3];
+	S3C24X0_REG8	OUT_FIFO_CNT2_REG;
+	S3C24X0_REG8	res16[3];
+#endif /*  __BIG_ENDIAN */
+	S3C24X0_USB_DEV_FIFOS	fifo[5];
+	S3C24X0_USB_DEV_DMAS	dma[5];
+} /*__attribute__((__packed__))*/ S3C24X0_USB_DEVICE;
+
+
+/* WATCH DOG TIMER (see manual chapter 18) */
+typedef struct {
+	S3C24X0_REG32	WTCON;
+	S3C24X0_REG32	WTDAT;
+	S3C24X0_REG32	WTCNT;
+} /*__attribute__((__packed__))*/ S3C24X0_WATCHDOG;
+
+
+/* IIC (see manual chapter 20) */
+typedef struct {
+	S3C24X0_REG32	IICCON;
+	S3C24X0_REG32	IICSTAT;
+	S3C24X0_REG32	IICADD;
+	S3C24X0_REG32	IICDS;
+} /*__attribute__((__packed__))*/ S3C24X0_I2C;
+
+
+/* IIS (see manual chapter 21) */
+typedef struct {
+#ifdef __BIG_ENDIAN
+	S3C24X0_REG16	res1;
+	S3C24X0_REG16	IISCON;
+	S3C24X0_REG16	res2;
+	S3C24X0_REG16	IISMOD;
+	S3C24X0_REG16	res3;
+	S3C24X0_REG16	IISPSR;
+	S3C24X0_REG16	res4;
+	S3C24X0_REG16	IISFCON;
+	S3C24X0_REG16	res5;
+	S3C24X0_REG16	IISFIFO;
+#else /*  little endian */
+	S3C24X0_REG16	IISCON;
+	S3C24X0_REG16	res1;
+	S3C24X0_REG16	IISMOD;
+	S3C24X0_REG16	res2;
+	S3C24X0_REG16	IISPSR;
+	S3C24X0_REG16	res3;
+	S3C24X0_REG16	IISFCON;
+	S3C24X0_REG16	res4;
+	S3C24X0_REG16	IISFIFO;
+	S3C24X0_REG16	res5;
+#endif
+} /*__attribute__((__packed__))*/ S3C24X0_I2S;
+
+
+/* I/O PORT (see manual chapter 9) */
+typedef struct {
+#ifdef CONFIG_S3C2400
+	S3C24X0_REG32	PACON;
+	S3C24X0_REG32	PADAT;
+
+	S3C24X0_REG32	PBCON;
+	S3C24X0_REG32	PBDAT;
+	S3C24X0_REG32	PBUP;
+
+	S3C24X0_REG32	PCCON;
+	S3C24X0_REG32	PCDAT;
+	S3C24X0_REG32	PCUP;
+
+	S3C24X0_REG32	PDCON;
+	S3C24X0_REG32	PDDAT;
+	S3C24X0_REG32	PDUP;
+
+	S3C24X0_REG32	PECON;
+	S3C24X0_REG32	PEDAT;
+	S3C24X0_REG32	PEUP;
+
+	S3C24X0_REG32	PFCON;
+	S3C24X0_REG32	PFDAT;
+	S3C24X0_REG32	PFUP;
+
+	S3C24X0_REG32	PGCON;
+	S3C24X0_REG32	PGDAT;
+	S3C24X0_REG32	PGUP;
+
+	S3C24X0_REG32	OPENCR;
+
+	S3C24X0_REG32	MISCCR;
+	S3C24X0_REG32	EXTINT;
+#endif
+#ifdef CONFIG_S3C2410
+	S3C24X0_REG32	GPACON;
+	S3C24X0_REG32	GPADAT;
+	S3C24X0_REG32	res1[2];
+	S3C24X0_REG32	GPBCON;
+	S3C24X0_REG32	GPBDAT;
+	S3C24X0_REG32	GPBUP;
+	S3C24X0_REG32	res2;
+	S3C24X0_REG32	GPCCON;
+	S3C24X0_REG32	GPCDAT;
+	S3C24X0_REG32	GPCUP;
+	S3C24X0_REG32	res3;
+	S3C24X0_REG32	GPDCON;
+	S3C24X0_REG32	GPDDAT;
+	S3C24X0_REG32	GPDUP;
+	S3C24X0_REG32	res4;
+	S3C24X0_REG32	GPECON;
+	S3C24X0_REG32	GPEDAT;
+	S3C24X0_REG32	GPEUP;
+	S3C24X0_REG32	res5;
+	S3C24X0_REG32	GPFCON;
+	S3C24X0_REG32	GPFDAT;
+	S3C24X0_REG32	GPFUP;
+	S3C24X0_REG32	res6;
+	S3C24X0_REG32	GPGCON;
+	S3C24X0_REG32	GPGDAT;
+	S3C24X0_REG32	GPGUP;
+	S3C24X0_REG32	res7;
+	S3C24X0_REG32	GPHCON;
+	S3C24X0_REG32	GPHDAT;
+	S3C24X0_REG32	GPHUP;
+	S3C24X0_REG32	res8;
+
+	S3C24X0_REG32	MISCCR;
+	S3C24X0_REG32	DCLKCON;
+	S3C24X0_REG32	EXTINT0;
+	S3C24X0_REG32	EXTINT1;
+	S3C24X0_REG32	EXTINT2;
+	S3C24X0_REG32	EINTFLT0;
+	S3C24X0_REG32	EINTFLT1;
+	S3C24X0_REG32	EINTFLT2;
+	S3C24X0_REG32	EINTFLT3;
+	S3C24X0_REG32	EINTMASK;
+	S3C24X0_REG32	EINTPEND;
+	S3C24X0_REG32	GSTATUS0;
+	S3C24X0_REG32	GSTATUS1;
+	S3C24X0_REG32	GSTATUS2;
+	S3C24X0_REG32	GSTATUS3;
+	S3C24X0_REG32	GSTATUS4;
+#endif
+} /*__attribute__((__packed__))*/ S3C24X0_GPIO;
+
+
+/* RTC (see manual chapter 17) */
+typedef struct {
+#ifdef __BIG_ENDIAN
+	S3C24X0_REG8	res1[67];
+	S3C24X0_REG8	RTCCON;
+	S3C24X0_REG8	res2[3];
+	S3C24X0_REG8	TICNT;
+	S3C24X0_REG8	res3[11];
+	S3C24X0_REG8	RTCALM;
+	S3C24X0_REG8	res4[3];
+	S3C24X0_REG8	ALMSEC;
+	S3C24X0_REG8	res5[3];
+	S3C24X0_REG8	ALMMIN;
+	S3C24X0_REG8	res6[3];
+	S3C24X0_REG8	ALMHOUR;
+	S3C24X0_REG8	res7[3];
+	S3C24X0_REG8	ALMDATE;
+	S3C24X0_REG8	res8[3];
+	S3C24X0_REG8	ALMMON;
+	S3C24X0_REG8	res9[3];
+	S3C24X0_REG8	ALMYEAR;
+	S3C24X0_REG8	res10[3];
+	S3C24X0_REG8	RTCRST;
+	S3C24X0_REG8	res11[3];
+	S3C24X0_REG8	BCDSEC;
+	S3C24X0_REG8	res12[3];
+	S3C24X0_REG8	BCDMIN;
+	S3C24X0_REG8	res13[3];
+	S3C24X0_REG8	BCDHOUR;
+	S3C24X0_REG8	res14[3];
+	S3C24X0_REG8	BCDDATE;
+	S3C24X0_REG8	res15[3];
+	S3C24X0_REG8	BCDDAY;
+	S3C24X0_REG8	res16[3];
+	S3C24X0_REG8	BCDMON;
+	S3C24X0_REG8	res17[3];
+	S3C24X0_REG8	BCDYEAR;
+#else /*  little endian */
+	S3C24X0_REG8	res0[64];
+	S3C24X0_REG8	RTCCON;
+	S3C24X0_REG8	res1[3];
+	S3C24X0_REG8	TICNT;
+	S3C24X0_REG8	res2[11];
+	S3C24X0_REG8	RTCALM;
+	S3C24X0_REG8	res3[3];
+	S3C24X0_REG8	ALMSEC;
+	S3C24X0_REG8	res4[3];
+	S3C24X0_REG8	ALMMIN;
+	S3C24X0_REG8	res5[3];
+	S3C24X0_REG8	ALMHOUR;
+	S3C24X0_REG8	res6[3];
+	S3C24X0_REG8	ALMDATE;
+	S3C24X0_REG8	res7[3];
+	S3C24X0_REG8	ALMMON;
+	S3C24X0_REG8	res8[3];
+	S3C24X0_REG8	ALMYEAR;
+	S3C24X0_REG8	res9[3];
+	S3C24X0_REG8	RTCRST;
+	S3C24X0_REG8	res10[3];
+	S3C24X0_REG8	BCDSEC;
+	S3C24X0_REG8	res11[3];
+	S3C24X0_REG8	BCDMIN;
+	S3C24X0_REG8	res12[3];
+	S3C24X0_REG8	BCDHOUR;
+	S3C24X0_REG8	res13[3];
+	S3C24X0_REG8	BCDDATE;
+	S3C24X0_REG8	res14[3];
+	S3C24X0_REG8	BCDDAY;
+	S3C24X0_REG8	res15[3];
+	S3C24X0_REG8	BCDMON;
+	S3C24X0_REG8	res16[3];
+	S3C24X0_REG8	BCDYEAR;
+	S3C24X0_REG8	res17[3];
+#endif
+} /*__attribute__((__packed__))*/ S3C24X0_RTC;
+
+
+/* ADC (see manual chapter 16) */
+typedef struct {
+	S3C24X0_REG32	ADCCON;
+	S3C24X0_REG32	ADCDAT;
+} /*__attribute__((__packed__))*/ S3C2400_ADC;
+
+
+/* ADC (see manual chapter 16) */
+typedef struct {
+	S3C24X0_REG32	ADCCON;
+	S3C24X0_REG32	ADCTSC;
+	S3C24X0_REG32	ADCDLY;
+	S3C24X0_REG32	ADCDAT0;
+	S3C24X0_REG32	ADCDAT1;
+} /*__attribute__((__packed__))*/ S3C2410_ADC;
+
+
+/* SPI (see manual chapter 22) */
+typedef struct {
+	S3C24X0_REG32	SPCON;
+	S3C24X0_REG32	SPSTA;
+	S3C24X0_REG32	SPPIN;
+	S3C24X0_REG32	SPPRE;
+	S3C24X0_REG32	SPTDAT;
+	S3C24X0_REG32	SPRDAT;
+	S3C24X0_REG32	res[2];
+} __attribute__((__packed__)) S3C24X0_SPI_CHANNEL;
+
+typedef struct {
+	S3C24X0_SPI_CHANNEL	ch[S3C24X0_SPI_CHANNELS];
+} /*__attribute__((__packed__))*/ S3C24X0_SPI;
+
+
+/* MMC INTERFACE (see S3C2400 manual chapter 19) */
+typedef struct {
+#ifdef __BIG_ENDIAN
+	S3C24X0_REG8	res1[3];
+	S3C24X0_REG8	MMCON;
+	S3C24X0_REG8	res2[3];
+	S3C24X0_REG8	MMCRR;
+	S3C24X0_REG8	res3[3];
+	S3C24X0_REG8	MMFCON;
+	S3C24X0_REG8	res4[3];
+	S3C24X0_REG8	MMSTA;
+	S3C24X0_REG16	res5;
+	S3C24X0_REG16	MMFSTA;
+	S3C24X0_REG8	res6[3];
+	S3C24X0_REG8	MMPRE;
+	S3C24X0_REG16	res7;
+	S3C24X0_REG16	MMLEN;
+	S3C24X0_REG8	res8[3];
+	S3C24X0_REG8	MMCR7;
+	S3C24X0_REG32	MMRSP[4];
+	S3C24X0_REG8	res9[3];
+	S3C24X0_REG8	MMCMD0;
+	S3C24X0_REG32	MMCMD1;
+	S3C24X0_REG16	res10;
+	S3C24X0_REG16	MMCR16;
+	S3C24X0_REG8	res11[3];
+	S3C24X0_REG8	MMDAT;
+#else
+	S3C24X0_REG8	MMCON;
+	S3C24X0_REG8	res1[3];
+	S3C24X0_REG8	MMCRR;
+	S3C24X0_REG8	res2[3];
+	S3C24X0_REG8	MMFCON;
+	S3C24X0_REG8	res3[3];
+	S3C24X0_REG8	MMSTA;
+	S3C24X0_REG8	res4[3];
+	S3C24X0_REG16	MMFSTA;
+	S3C24X0_REG16	res5;
+	S3C24X0_REG8	MMPRE;
+	S3C24X0_REG8	res6[3];
+	S3C24X0_REG16	MMLEN;
+	S3C24X0_REG16	res7;
+	S3C24X0_REG8	MMCR7;
+	S3C24X0_REG8	res8[3];
+	S3C24X0_REG32	MMRSP[4];
+	S3C24X0_REG8	MMCMD0;
+	S3C24X0_REG8	res9[3];
+	S3C24X0_REG32	MMCMD1;
+	S3C24X0_REG16	MMCR16;
+	S3C24X0_REG16	res10;
+	S3C24X0_REG8	MMDAT;
+	S3C24X0_REG8	res11[3];
+#endif
+} /*__attribute__((__packed__))*/ S3C2400_MMC;
+
+
+/* SD INTERFACE (see S3C2410 manual chapter 19) */
+typedef struct {
+	S3C24X0_REG32	SDICON;
+	S3C24X0_REG32	SDIPRE;
+	S3C24X0_REG32	SDICARG;
+	S3C24X0_REG32	SDICCON;
+	S3C24X0_REG32	SDICSTA;
+	S3C24X0_REG32	SDIRSP0;
+	S3C24X0_REG32	SDIRSP1;
+	S3C24X0_REG32	SDIRSP2;
+	S3C24X0_REG32	SDIRSP3;
+	S3C24X0_REG32	SDIDTIMER;
+	S3C24X0_REG32	SDIBSIZE;
+	S3C24X0_REG32	SDIDCON;
+	S3C24X0_REG32	SDIDCNT;
+	S3C24X0_REG32	SDIDSTA;
+	S3C24X0_REG32	SDIFSTA;
+#ifdef __BIG_ENDIAN
+	S3C24X0_REG8	res[3];
+	S3C24X0_REG8	SDIDAT;
+#else
+	S3C24X0_REG8	SDIDAT;
+	S3C24X0_REG8	res[3];
+#endif
+	S3C24X0_REG32	SDIIMSK;
+} /*__attribute__((__packed__))*/ S3C2410_SDI;
+
+
+#if 0
+/* Memory control */
+#define rBWSCON			(*(volatile unsigned *)0x48000000)
+#define rBANKCON0		(*(volatile unsigned *)0x48000004)
+#define rBANKCON1		(*(volatile unsigned *)0x48000008)
+#define rBANKCON2		(*(volatile unsigned *)0x4800000C)
+#define rBANKCON3		(*(volatile unsigned *)0x48000010)
+#define rBANKCON4		(*(volatile unsigned *)0x48000014)
+#define rBANKCON5		(*(volatile unsigned *)0x48000018)
+#define rBANKCON6		(*(volatile unsigned *)0x4800001C)
+#define rBANKCON7		(*(volatile unsigned *)0x48000020)
+#define rREFRESH		(*(volatile unsigned *)0x48000024)
+#define rBANKSIZE		(*(volatile unsigned *)0x48000028)
+#define rMRSRB6			(*(volatile unsigned *)0x4800002C)
+#define rMRSRB7			(*(volatile unsigned *)0x48000030)
+
+
+/* USB HOST */
+#define rHcRevision		(*(volatile unsigned *)0x49000000)
+#define rHcControl		(*(volatile unsigned *)0x49000004)
+#define rHcCommonStatus		(*(volatile unsigned *)0x49000008)
+#define rHcInterruptStatus	(*(volatile unsigned *)0x4900000C)
+#define rHcInterruptEnable	(*(volatile unsigned *)0x49000010)
+#define rHcInterruptDisable	(*(volatile unsigned *)0x49000014)
+#define rHcHCCA			(*(volatile unsigned *)0x49000018)
+#define rHcPeriodCuttendED	(*(volatile unsigned *)0x4900001C)
+#define rHcControlHeadED	(*(volatile unsigned *)0x49000020)
+#define rHcControlCurrentED	(*(volatile unsigned *)0x49000024)
+#define rHcBulkHeadED		(*(volatile unsigned *)0x49000028)
+#define rHcBuldCurrentED	(*(volatile unsigned *)0x4900002C)
+#define rHcDoneHead		(*(volatile unsigned *)0x49000030)
+#define rHcRmInterval		(*(volatile unsigned *)0x49000034)
+#define rHcFmRemaining		(*(volatile unsigned *)0x49000038)
+#define rHcFmNumber		(*(volatile unsigned *)0x4900003C)
+#define rHcPeriodicStart	(*(volatile unsigned *)0x49000040)
+#define rHcLSThreshold		(*(volatile unsigned *)0x49000044)
+#define rHcRhDescriptorA	(*(volatile unsigned *)0x49000048)
+#define rHcRhDescriptorB	(*(volatile unsigned *)0x4900004C)
+#define rHcRhStatus		(*(volatile unsigned *)0x49000050)
+#define rHcRhPortStatus1	(*(volatile unsigned *)0x49000054)
+#define rHcRhPortStatus2	(*(volatile unsigned *)0x49000058)
+
+
+/* INTERRUPT */
+#define rSRCPND			(*(volatile unsigned *)0x4A000000)
+#define rINTMOD			(*(volatile unsigned *)0x4A000004)
+#define rINTMSK			(*(volatile unsigned *)0x4A000008)
+#define rPRIORITY		(*(volatile unsigned *)0x4A00000C)
+#define rINTPND			(*(volatile unsigned *)0x4A000010)
+#define rINTOFFSET		(*(volatile unsigned *)0x4A000014)
+#define rSUBSRCPND		(*(volatile unsigned *)0x4A000018)
+#define rINTSUBMSK		(*(volatile unsigned *)0x4A00001C)
+
+
+/* DMA */
+#define rDISRC0			(*(volatile unsigned *)0x4B000000)
+#define rDISRCC0		(*(volatile unsigned *)0x4B000004)
+#define rDIDST0			(*(volatile unsigned *)0x4B000008)
+#define rDIDSTC0		(*(volatile unsigned *)0x4B00000C)
+#define rDCON0			(*(volatile unsigned *)0x4B000010)
+#define rDSTAT0			(*(volatile unsigned *)0x4B000014)
+#define rDCSRC0			(*(volatile unsigned *)0x4B000018)
+#define rDCDST0			(*(volatile unsigned *)0x4B00001C)
+#define rDMASKTRIG0		(*(volatile unsigned *)0x4B000020)
+#define rDISRC1			(*(volatile unsigned *)0x4B000040)
+#define rDISRCC1		(*(volatile unsigned *)0x4B000044)
+#define rDIDST1			(*(volatile unsigned *)0x4B000048)
+#define rDIDSTC1		(*(volatile unsigned *)0x4B00004C)
+#define rDCON1			(*(volatile unsigned *)0x4B000050)
+#define rDSTAT1			(*(volatile unsigned *)0x4B000054)
+#define rDCSRC1			(*(volatile unsigned *)0x4B000058)
+#define rDCDST1			(*(volatile unsigned *)0x4B00005C)
+#define rDMASKTRIG1		(*(volatile unsigned *)0x4B000060)
+#define rDISRC2			(*(volatile unsigned *)0x4B000080)
+#define rDISRCC2		(*(volatile unsigned *)0x4B000084)
+#define rDIDST2			(*(volatile unsigned *)0x4B000088)
+#define rDIDSTC2		(*(volatile unsigned *)0x4B00008C)
+#define rDCON2			(*(volatile unsigned *)0x4B000090)
+#define rDSTAT2			(*(volatile unsigned *)0x4B000094)
+#define rDCSRC2			(*(volatile unsigned *)0x4B000098)
+#define rDCDST2			(*(volatile unsigned *)0x4B00009C)
+#define rDMASKTRIG2		(*(volatile unsigned *)0x4B0000A0)
+#define rDISRC3			(*(volatile unsigned *)0x4B0000C0)
+#define rDISRCC3		(*(volatile unsigned *)0x4B0000C4)
+#define rDIDST3			(*(volatile unsigned *)0x4B0000C8)
+#define rDIDSTC3		(*(volatile unsigned *)0x4B0000CC)
+#define rDCON3			(*(volatile unsigned *)0x4B0000D0)
+#define rDSTAT3			(*(volatile unsigned *)0x4B0000D4)
+#define rDCSRC3			(*(volatile unsigned *)0x4B0000D8)
+#define rDCDST3			(*(volatile unsigned *)0x4B0000DC)
+#define rDMASKTRIG3		(*(volatile unsigned *)0x4B0000E0)
+
+
+/* CLOCK & POWER MANAGEMENT */
+#define rLOCKTIME		(*(volatile unsigned *)0x4C000000)
+#define rMPLLCON		(*(volatile unsigned *)0x4C000004)
+#define rUPLLCON		(*(volatile unsigned *)0x4C000008)
+#define rCLKCON			(*(volatile unsigned *)0x4C00000C)
+#define rCLKSLOW		(*(volatile unsigned *)0x4C000010)
+#define rCLKDIVN		(*(volatile unsigned *)0x4C000014)
+
+
+/* LCD CONTROLLER */
+#define rLCDCON1		(*(volatile unsigned *)0x4D000000)
+#define rLCDCON2		(*(volatile unsigned *)0x4D000004)
+#define rLCDCON3		(*(volatile unsigned *)0x4D000008)
+#define rLCDCON4		(*(volatile unsigned *)0x4D00000C)
+#define rLCDCON5		(*(volatile unsigned *)0x4D000010)
+#define rLCDSADDR1		(*(volatile unsigned *)0x4D000014)
+#define rLCDSADDR2		(*(volatile unsigned *)0x4D000018)
+#define rLCDSADDR3		(*(volatile unsigned *)0x4D00001C)
+#define rREDLUT			(*(volatile unsigned *)0x4D000020)
+#define rGREENLUT		(*(volatile unsigned *)0x4D000024)
+#define rBLUELUT		(*(volatile unsigned *)0x4D000028)
+#define rDITHMODE		(*(volatile unsigned *)0x4D00004C)
+#define rTPAL			(*(volatile unsigned *)0x4D000050)
+#define rLCDINTPND		(*(volatile unsigned *)0x4D000054)
+#define rLCDSRCPND		(*(volatile unsigned *)0x4D000058)
+#define rLCDINTMSK		(*(volatile unsigned *)0x4D00005C)
+
+
+/* NAND FLASH */
+#define rNFCONF			(*(volatile unsigned *)0x4E000000)
+#define rNFCMD			(*(volatile unsigned *)0x4E000004)
+#define rNFADDR			(*(volatile unsigned *)0x4E000008)
+#define rNFDATA			(*(volatile unsigned *)0x4E00000C)
+#define rNFSTAT			(*(volatile unsigned *)0x4E000010)
+#define rNFECC			(*(volatile unsigned *)0x4E000014)
+
+
+/* UART */
+#define rULCON0			(*(volatile unsigned *)0x50000000)
+#define rUCON0			(*(volatile unsigned *)0x50000004)
+#define rUFCON0			(*(volatile unsigned *)0x50000008)
+#define rUMCON0			(*(volatile unsigned *)0x5000000C)
+#define rUTRSTAT0		(*(volatile unsigned *)0x50000010)
+#define rUERSTAT0		(*(volatile unsigned *)0x50000014)
+#define rUFSTAT0		(*(volatile unsigned *)0x50000018)
+#define rUMSTAT0		(*(volatile unsigned *)0x5000001C)
+#define rUBRDIV0		(*(volatile unsigned *)0x50000028)
+
+#define rULCON1			(*(volatile unsigned *)0x50004000)
+#define rUCON1			(*(volatile unsigned *)0x50004004)
+#define rUFCON1			(*(volatile unsigned *)0x50004008)
+#define rUMCON1			(*(volatile unsigned *)0x5000400C)
+#define rUTRSTAT1		(*(volatile unsigned *)0x50004010)
+#define rUERSTAT1		(*(volatile unsigned *)0x50004014)
+#define rUFSTAT1		(*(volatile unsigned *)0x50004018)
+#define rUMSTAT1		(*(volatile unsigned *)0x5000401C)
+#define rUBRDIV1		(*(volatile unsigned *)0x50004028)
+
+#define rULCON2			(*(volatile unsigned *)0x50008000)
+#define rUCON2			(*(volatile unsigned *)0x50008004)
+#define rUFCON2			(*(volatile unsigned *)0x50008008)
+#define rUTRSTAT2		(*(volatile unsigned *)0x50008010)
+#define rUERSTAT2		(*(volatile unsigned *)0x50008014)
+#define rUFSTAT2		(*(volatile unsigned *)0x50008018)
+#define rUBRDIV2		(*(volatile unsigned *)0x50008028)
+
+#ifdef __BIG_ENDIAN
+#define rUTXH0			(*(volatile unsigned char *)0x50000023)
+#define rURXH0			(*(volatile unsigned char *)0x50000027)
+#define rUTXH1			(*(volatile unsigned char *)0x50004023)
+#define rURXH1			(*(volatile unsigned char *)0x50004027)
+#define rUTXH2			(*(volatile unsigned char *)0x50008023)
+#define rURXH2			(*(volatile unsigned char *)0x50008027)
+
+#define WrUTXH0(ch)		(*(volatile unsigned char *)0x50000023)=(unsigned char)(ch)
+#define RdURXH0()		(*(volatile unsigned char *)0x50000027)
+#define WrUTXH1(ch)		(*(volatile unsigned char *)0x50004023)=(unsigned char)(ch)
+#define RdURXH1()		(*(volatile unsigned char *)0x50004027)
+#define WrUTXH2(ch)		(*(volatile unsigned char *)0x50008023)=(unsigned char)(ch)
+#define RdURXH2()		(*(volatile unsigned char *)0x50008027)
+
+#define UTXH0			(0x50000020+3)  /* byte_access address by DMA */
+#define URXH0			(0x50000024+3)
+#define UTXH1			(0x50004020+3)
+#define URXH1			(0x50004024+3)
+#define UTXH2			(0x50008020+3)
+#define URXH2			(0x50008024+3)
+
+#else /* Little Endian */
+#define rUTXH0			(*(volatile unsigned char *)0x50000020)
+#define rURXH0			(*(volatile unsigned char *)0x50000024)
+#define rUTXH1			(*(volatile unsigned char *)0x50004020)
+#define rURXH1			(*(volatile unsigned char *)0x50004024)
+#define rUTXH2			(*(volatile unsigned char *)0x50008020)
+#define rURXH2			(*(volatile unsigned char *)0x50008024)
+
+#define WrUTXH0(ch)		(*(volatile unsigned char *)0x50000020)=(unsigned char)(ch)
+#define RdURXH0()		(*(volatile unsigned char *)0x50000024)
+#define WrUTXH1(ch)		(*(volatile unsigned char *)0x50004020)=(unsigned char)(ch)
+#define RdURXH1()		(*(volatile unsigned char *)0x50004024)
+#define WrUTXH2(ch)		(*(volatile unsigned char *)0x50008020)=(unsigned char)(ch)
+#define RdURXH2()		(*(volatile unsigned char *)0x50008024)
+
+#define UTXH0			(0x50000020)    /* byte_access address by DMA */
+#define URXH0			(0x50000024)
+#define UTXH1			(0x50004020)
+#define URXH1			(0x50004024)
+#define UTXH2			(0x50008020)
+#define URXH2			(0x50008024)
+#endif
+
+
+/* PWM TIMER */
+#define rTCFG0			(*(volatile unsigned *)0x51000000)
+#define rTCFG1			(*(volatile unsigned *)0x51000004)
+#define rTCON			(*(volatile unsigned *)0x51000008)
+#define rTCNTB0			(*(volatile unsigned *)0x5100000C)
+#define rTCMPB0			(*(volatile unsigned *)0x51000010)
+#define rTCNTO0			(*(volatile unsigned *)0x51000014)
+#define rTCNTB1			(*(volatile unsigned *)0x51000018)
+#define rTCMPB1			(*(volatile unsigned *)0x5100001C)
+#define rTCNTO1			(*(volatile unsigned *)0x51000020)
+#define rTCNTB2			(*(volatile unsigned *)0x51000024)
+#define rTCMPB2			(*(volatile unsigned *)0x51000028)
+#define rTCNTO2			(*(volatile unsigned *)0x5100002C)
+#define rTCNTB3			(*(volatile unsigned *)0x51000030)
+#define rTCMPB3			(*(volatile unsigned *)0x51000034)
+#define rTCNTO3			(*(volatile unsigned *)0x51000038)
+#define rTCNTB4			(*(volatile unsigned *)0x5100003C)
+#define rTCNTO4			(*(volatile unsigned *)0x51000040)
+
+
+/* USB DEVICE */
+#ifdef __BIG_ENDIAN
+#define rFUNC_ADDR_REG		(*(volatile unsigned char *)0x52000143)
+#define rPWR_REG		(*(volatile unsigned char *)0x52000147)
+#define rEP_INT_REG		(*(volatile unsigned char *)0x5200014B)
+#define rUSB_INT_REG		(*(volatile unsigned char *)0x5200015B)
+#define rEP_INT_EN_REG		(*(volatile unsigned char *)0x5200015F)
+#define rUSB_INT_EN_REG		(*(volatile unsigned char *)0x5200016F)
+#define rFRAME_NUM1_REG		(*(volatile unsigned char *)0x52000173)
+#define rFRAME_NUM2_REG		(*(volatile unsigned char *)0x52000177)
+#define rINDEX_REG		(*(volatile unsigned char *)0x5200017B)
+#define rMAXP_REG		(*(volatile unsigned char *)0x52000183)
+#define rEP0_CSR		(*(volatile unsigned char *)0x52000187)
+#define rIN_CSR1_REG		(*(volatile unsigned char *)0x52000187)
+#define rIN_CSR2_REG		(*(volatile unsigned char *)0x5200018B)
+#define rOUT_CSR1_REG		(*(volatile unsigned char *)0x52000193)
+#define rOUT_CSR2_REG		(*(volatile unsigned char *)0x52000197)
+#define rOUT_FIFO_CNT1_REG	(*(volatile unsigned char *)0x5200019B)
+#define rOUT_FIFO_CNT2_REG	(*(volatile unsigned char *)0x5200019F)
+#define rEP0_FIFO		(*(volatile unsigned char *)0x520001C3)
+#define rEP1_FIFO		(*(volatile unsigned char *)0x520001C7)
+#define rEP2_FIFO		(*(volatile unsigned char *)0x520001CB)
+#define rEP3_FIFO		(*(volatile unsigned char *)0x520001CF)
+#define rEP4_FIFO		(*(volatile unsigned char *)0x520001D3)
+#define rEP1_DMA_CON		(*(volatile unsigned char *)0x52000203)
+#define rEP1_DMA_UNIT		(*(volatile unsigned char *)0x52000207)
+#define rEP1_DMA_FIFO		(*(volatile unsigned char *)0x5200020B)
+#define rEP1_DMA_TX_LO		(*(volatile unsigned char *)0x5200020F)
+#define rEP1_DMA_TX_MD		(*(volatile unsigned char *)0x52000213)
+#define rEP1_DMA_TX_HI		(*(volatile unsigned char *)0x52000217)
+#define rEP2_DMA_CON		(*(volatile unsigned char *)0x5200021B)
+#define rEP2_DMA_UNIT		(*(volatile unsigned char *)0x5200021F)
+#define rEP2_DMA_FIFO		(*(volatile unsigned char *)0x52000223)
+#define rEP2_DMA_TX_LO		(*(volatile unsigned char *)0x52000227)
+#define rEP2_DMA_TX_MD		(*(volatile unsigned char *)0x5200022B)
+#define rEP2_DMA_TX_HI		(*(volatile unsigned char *)0x5200022F)
+#define rEP3_DMA_CON		(*(volatile unsigned char *)0x52000243)
+#define rEP3_DMA_UNIT		(*(volatile unsigned char *)0x52000247)
+#define rEP3_DMA_FIFO		(*(volatile unsigned char *)0x5200024B)
+#define rEP3_DMA_TX_LO		(*(volatile unsigned char *)0x5200024F)
+#define rEP3_DMA_TX_MD		(*(volatile unsigned char *)0x52000253)
+#define rEP3_DMA_TX_HI		(*(volatile unsigned char *)0x52000257)
+#define rEP4_DMA_CON		(*(volatile unsigned char *)0x5200025B)
+#define rEP4_DMA_UNIT		(*(volatile unsigned char *)0x5200025F)
+#define rEP4_DMA_FIFO		(*(volatile unsigned char *)0x52000263)
+#define rEP4_DMA_TX_LO		(*(volatile unsigned char *)0x52000267)
+#define rEP4_DMA_TX_MD		(*(volatile unsigned char *)0x5200026B)
+#define rEP4_DMA_TX_HI		(*(volatile unsigned char *)0x5200026F)
+#else /*  little endian */
+#define rFUNC_ADDR_REG		(*(volatile unsigned char *)0x52000140)
+#define rPWR_REG		(*(volatile unsigned char *)0x52000144)
+#define rEP_INT_REG		(*(volatile unsigned char *)0x52000148)
+#define rUSB_INT_REG		(*(volatile unsigned char *)0x52000158)
+#define rEP_INT_EN_REG		(*(volatile unsigned char *)0x5200015C)
+#define rUSB_INT_EN_REG		(*(volatile unsigned char *)0x5200016C)
+#define rFRAME_NUM1_REG		(*(volatile unsigned char *)0x52000170)
+#define rFRAME_NUM2_REG		(*(volatile unsigned char *)0x52000174)
+#define rINDEX_REG		(*(volatile unsigned char *)0x52000178)
+#define rMAXP_REG		(*(volatile unsigned char *)0x52000180)
+#define rEP0_CSR		(*(volatile unsigned char *)0x52000184)
+#define rIN_CSR1_REG		(*(volatile unsigned char *)0x52000184)
+#define rIN_CSR2_REG		(*(volatile unsigned char *)0x52000188)
+#define rOUT_CSR1_REG		(*(volatile unsigned char *)0x52000190)
+#define rOUT_CSR2_REG		(*(volatile unsigned char *)0x52000194)
+#define rOUT_FIFO_CNT1_REG	(*(volatile unsigned char *)0x52000198)
+#define rOUT_FIFO_CNT2_REG	(*(volatile unsigned char *)0x5200019C)
+#define rEP0_FIFO		(*(volatile unsigned char *)0x520001C0)
+#define rEP1_FIFO		(*(volatile unsigned char *)0x520001C4)
+#define rEP2_FIFO		(*(volatile unsigned char *)0x520001C8)
+#define rEP3_FIFO		(*(volatile unsigned char *)0x520001CC)
+#define rEP4_FIFO		(*(volatile unsigned char *)0x520001D0)
+#define rEP1_DMA_CON		(*(volatile unsigned char *)0x52000200)
+#define rEP1_DMA_UNIT		(*(volatile unsigned char *)0x52000204)
+#define rEP1_DMA_FIFO		(*(volatile unsigned char *)0x52000208)
+#define rEP1_DMA_TX_LO		(*(volatile unsigned char *)0x5200020C)
+#define rEP1_DMA_TX_MD		(*(volatile unsigned char *)0x52000210)
+#define rEP1_DMA_TX_HI		(*(volatile unsigned char *)0x52000214)
+#define rEP2_DMA_CON		(*(volatile unsigned char *)0x52000218)
+#define rEP2_DMA_UNIT		(*(volatile unsigned char *)0x5200021C)
+#define rEP2_DMA_FIFO		(*(volatile unsigned char *)0x52000220)
+#define rEP2_DMA_TX_LO		(*(volatile unsigned char *)0x52000224)
+#define rEP2_DMA_TX_MD		(*(volatile unsigned char *)0x52000228)
+#define rEP2_DMA_TX_HI		(*(volatile unsigned char *)0x5200022C)
+#define rEP3_DMA_CON		(*(volatile unsigned char *)0x52000240)
+#define rEP3_DMA_UNIT		(*(volatile unsigned char *)0x52000244)
+#define rEP3_DMA_FIFO		(*(volatile unsigned char *)0x52000248)
+#define rEP3_DMA_TX_LO		(*(volatile unsigned char *)0x5200024C)
+#define rEP3_DMA_TX_MD		(*(volatile unsigned char *)0x52000250)
+#define rEP3_DMA_TX_HI		(*(volatile unsigned char *)0x52000254)
+#define rEP4_DMA_CON		(*(volatile unsigned char *)0x52000258)
+#define rEP4_DMA_UNIT		(*(volatile unsigned char *)0x5200025C)
+#define rEP4_DMA_FIFO		(*(volatile unsigned char *)0x52000260)
+#define rEP4_DMA_TX_LO		(*(volatile unsigned char *)0x52000264)
+#define rEP4_DMA_TX_MD		(*(volatile unsigned char *)0x52000268)
+#define rEP4_DMA_TX_HI		(*(volatile unsigned char *)0x5200026C)
+#endif /*  __BIG_ENDIAN */
+
+
+/* WATCH DOG TIMER */
+#define rWTCON			(*(volatile unsigned *)0x53000000)
+#define rWTDAT			(*(volatile unsigned *)0x53000004)
+#define rWTCNT			(*(volatile unsigned *)0x53000008)
+
+
+/* IIC */
+#define rIICCON			(*(volatile unsigned *)0x54000000)
+#define rIICSTAT		(*(volatile unsigned *)0x54000004)
+#define rIICADD			(*(volatile unsigned *)0x54000008)
+#define rIICDS			(*(volatile unsigned *)0x5400000C)
+
+
+/* IIS */
+#define rIISCON			(*(volatile unsigned *)0x55000000)
+#define rIISMOD			(*(volatile unsigned *)0x55000004)
+#define rIISPSR			(*(volatile unsigned *)0x55000008)
+#define rIISFCON		(*(volatile unsigned *)0x5500000C)
+
+#ifdef __BIG_ENDIAN
+#define IISFIF			((volatile unsigned short *)0x55000012)
+#else /*  little endian */
+#define IISFIF			((volatile unsigned short *)0x55000010)
+#endif
+
+
+/* I/O PORT */
+#define rGPACON			(*(volatile unsigned *)0x56000000)
+#define rGPADAT			(*(volatile unsigned *)0x56000004)
+
+#define rGPBCON			(*(volatile unsigned *)0x56000010)
+#define rGPBDAT			(*(volatile unsigned *)0x56000014)
+#define rGPBUP			(*(volatile unsigned *)0x56000018)
+
+#define rGPCCON			(*(volatile unsigned *)0x56000020)
+#define rGPCDAT			(*(volatile unsigned *)0x56000024)
+#define rGPCUP			(*(volatile unsigned *)0x56000028)
+
+#define rGPDCON			(*(volatile unsigned *)0x56000030)
+#define rGPDDAT			(*(volatile unsigned *)0x56000034)
+#define rGPDUP			(*(volatile unsigned *)0x56000038)
+
+#define rGPECON			(*(volatile unsigned *)0x56000040)
+#define rGPEDAT			(*(volatile unsigned *)0x56000044)
+#define rGPEUP			(*(volatile unsigned *)0x56000048)
+
+#define rGPFCON			(*(volatile unsigned *)0x56000050)
+#define rGPFDAT			(*(volatile unsigned *)0x56000054)
+#define rGPFUP			(*(volatile unsigned *)0x56000058)
+
+#define rGPGCON			(*(volatile unsigned *)0x56000060)
+#define rGPGDAT			(*(volatile unsigned *)0x56000064)
+#define rGPGUP			(*(volatile unsigned *)0x56000068)
+
+#define rGPHCON			(*(volatile unsigned *)0x56000070)
+#define rGPHDAT			(*(volatile unsigned *)0x56000074)
+#define rGPHUP			(*(volatile unsigned *)0x56000078)
+
+#define rMISCCR			(*(volatile unsigned *)0x56000080)
+#define rDCLKCON		(*(volatile unsigned *)0x56000084)
+#define rEXTINT0		(*(volatile unsigned *)0x56000088)
+#define rEXTINT1		(*(volatile unsigned *)0x5600008C)
+#define rEXTINT2		(*(volatile unsigned *)0x56000090)
+#define rEINTFLT0		(*(volatile unsigned *)0x56000094)
+#define rEINTFLT1		(*(volatile unsigned *)0x56000098)
+#define rEINTFLT2		(*(volatile unsigned *)0x5600009C)
+#define rEINTFLT3		(*(volatile unsigned *)0x560000A0)
+#define rEINTMASK		(*(volatile unsigned *)0x560000A4)
+#define rEINTPEND		(*(volatile unsigned *)0x560000A8)
+#define rGSTATUS0		(*(volatile unsigned *)0x560000AC)
+#define rGSTATUS1		(*(volatile unsigned *)0x560000B0)
+
+
+/* RTC */
+#ifdef __BIG_ENDIAN
+#define rRTCCON			(*(volatile unsigned char *)0x57000043)
+#define rTICNT			(*(volatile unsigned char *)0x57000047)
+#define rRTCALM			(*(volatile unsigned char *)0x57000053)
+#define rALMSEC			(*(volatile unsigned char *)0x57000057)
+#define rALMMIN			(*(volatile unsigned char *)0x5700005B)
+#define rALMHOUR		(*(volatile unsigned char *)0x5700005F)
+#define rALMDATE		(*(volatile unsigned char *)0x57000063)
+#define rALMMON			(*(volatile unsigned char *)0x57000067)
+#define rALMYEAR		(*(volatile unsigned char *)0x5700006B)
+#define rRTCRST			(*(volatile unsigned char *)0x5700006F)
+#define rBCDSEC			(*(volatile unsigned char *)0x57000073)
+#define rBCDMIN			(*(volatile unsigned char *)0x57000077)
+#define rBCDHOUR		(*(volatile unsigned char *)0x5700007B)
+#define rBCDDATE		(*(volatile unsigned char *)0x5700007F)
+#define rBCDDAY			(*(volatile unsigned char *)0x57000083)
+#define rBCDMON			(*(volatile unsigned char *)0x57000087)
+#define rBCDYEAR		(*(volatile unsigned char *)0x5700008B)
+#else /*  little endian */
+#define rRTCCON			(*(volatile unsigned char *)0x57000040)
+#define rTICNT			(*(volatile unsigned char *)0x57000044)
+#define rRTCALM			(*(volatile unsigned char *)0x57000050)
+#define rALMSEC			(*(volatile unsigned char *)0x57000054)
+#define rALMMIN			(*(volatile unsigned char *)0x57000058)
+#define rALMHOUR		(*(volatile unsigned char *)0x5700005C)
+#define rALMDATE		(*(volatile unsigned char *)0x57000060)
+#define rALMMON			(*(volatile unsigned char *)0x57000064)
+#define rALMYEAR		(*(volatile unsigned char *)0x57000068)
+#define rRTCRST			(*(volatile unsigned char *)0x5700006C)
+#define rBCDSEC			(*(volatile unsigned char *)0x57000070)
+#define rBCDMIN			(*(volatile unsigned char *)0x57000074)
+#define rBCDHOUR		(*(volatile unsigned char *)0x57000078)
+#define rBCDDATE		(*(volatile unsigned char *)0x5700007C)
+#define rBCDDAY			(*(volatile unsigned char *)0x57000080)
+#define rBCDMON			(*(volatile unsigned char *)0x57000084)
+#define rBCDYEAR		(*(volatile unsigned char *)0x57000088)
+#endif
+
+
+/* ADC */
+#define rADCCON			(*(volatile unsigned *)0x58000000)
+#define rADCTSC			(*(volatile unsigned *)0x58000004)
+#define rADCDLY			(*(volatile unsigned *)0x58000008)
+#define rADCDAT0		(*(volatile unsigned *)0x5800000C)
+#define rADCDAT1		(*(volatile unsigned *)0x58000010)
+
+
+/* SPI */
+#define rSPCON0			(*(volatile unsigned *)0x59000000)
+#define rSPSTA0			(*(volatile unsigned *)0x59000004)
+#define rSPPIN0			(*(volatile unsigned *)0x59000008)
+#define rSPPRE0			(*(volatile unsigned *)0x5900000C)
+#define rSPTDAT0		(*(volatile unsigned *)0x59000010)
+#define rSPRDAT0		(*(volatile unsigned *)0x59000014)
+#define rSPCON1			(*(volatile unsigned *)0x59000020)
+#define rSPSTA1			(*(volatile unsigned *)0x59000024)
+#define rSPPIN1			(*(volatile unsigned *)0x59000028)
+#define rSPPRE1			(*(volatile unsigned *)0x5900002C)
+#define rSPTDAT1		(*(volatile unsigned *)0x59000030)
+#define rSPRDAT1		(*(volatile unsigned *)0x59000034)
+
+
+/* SD INTERFACE */
+#define rSDICON			(*(volatile unsigned *)0x5A000000)
+#define rSDIPRE			(*(volatile unsigned *)0x5A000004)
+#define rSDICmdArg		(*(volatile unsigned *)0x5A000008)
+#define rSDICmdCon		(*(volatile unsigned *)0x5A00000C)
+#define rSDICmdSta		(*(volatile unsigned *)0x5A000010)
+#define rSDIRSP0		(*(volatile unsigned *)0x5A000014)
+#define rSDIRSP1		(*(volatile unsigned *)0x5A000018)
+#define rSDIRSP2		(*(volatile unsigned *)0x5A00001C)
+#define rSDIRSP3		(*(volatile unsigned *)0x5A000020)
+#define rSDIDTimer		(*(volatile unsigned *)0x5A000024)
+#define rSDIBSize		(*(volatile unsigned *)0x5A000028)
+#define rSDIDatCon		(*(volatile unsigned *)0x5A00002C)
+#define rSDIDatCnt		(*(volatile unsigned *)0x5A000030)
+#define rSDIDatSta		(*(volatile unsigned *)0x5A000034)
+#define rSDIFSTA		(*(volatile unsigned *)0x5A000038)
+#ifdef __BIG_ENDIAN
+#define rSDIDAT			(*(volatile unsigned char *)0x5A00003F)
+#else
+#define rSDIDAT			(*(volatile unsigned char *)0x5A00003C)
+#endif
+#define rSDIIntMsk		(*(volatile unsigned *)0x5A000040)
+
+#endif
+
+#endif /*__S3C24X0_H__*/
diff -NBbur u-boot-2010.09-orig/arch/arm/include/asm/arch-s3c24x0/s3c2410.h u-boot-2010.09-smdk2416/arch/arm/include/asm/arch-s3c24x0/s3c2410.h
--- u-boot-2010.09-orig/arch/arm/include/asm/arch-s3c24x0/s3c2410.h	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/include/asm/arch-s3c24x0/s3c2410.h	2011-09-01 17:52:28.000000000 +0800
@@ -66,7 +66,7 @@
 
 
 /* include common stuff */
-#include <asm/arch/s3c24x0.h>
+#include <asm/arch-s3c24x0/s3c24x0.h>
 
 
 static inline struct s3c24x0_memctl *s3c24x0_get_base_memctl(void)
diff -NBbur u-boot-2010.09-orig/arch/arm/lib/board.c u-boot-2010.09-smdk2416/arch/arm/lib/board.c
--- u-boot-2010.09-orig/arch/arm/lib/board.c	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-smdk2416/arch/arm/lib/board.c	2011-09-02 08:34:32.000000000 +0800
@@ -242,7 +242,7 @@
 #if defined(CONFIG_USE_IRQ)
 	interrupt_init,		/* set up exceptions */
 #endif
-	timer_init,		/* initialize timer */
+	/* timer_init,*/		/* initialize timer */ /* do not neet it */
 #ifdef CONFIG_FSL_ESDHC
 	get_clocks,
 #endif
diff -NBbur u-boot-2010.09-orig/board/samsung/smdk2416/config.mk u-boot-2010.09-smdk2416/board/samsung/smdk2416/config.mk
--- u-boot-2010.09-orig/board/samsung/smdk2416/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/board/samsung/smdk2416/config.mk	2011-09-01 15:14:32.000000000 +0800
@@ -0,0 +1,27 @@
+#
+# (C) Copyright 2006
+# Seung-Chull, Suh, Samsung Electronics, <sc.suh@samsung.com>
+#
+# SAMSUNG SMDK2416 board with S3C2416(ARM926EJT) cpu
+#
+# see http://www.samsung.com/ for more information on SAMSUNG
+#
+
+#
+# SMDK2416 has 1 bank of 64 MB DRAM
+# 3000'0000 to 3400'0000 : TEXT_BASE=0x33e00000
+#
+# Linux-Kernel is expected to be at 3000'8000, entry 3000'8000
+# optionally with a ramdisk at 3080'0000
+#
+# we load ourself to 33e0'0000 without MMU
+# with MMU, load address is changed to 0xc3e0_0000
+#
+# download area is 3000'0000
+#
+
+
+ifndef TEXT_BASE
+TEXT_BASE = 0xc3e00000
+endif
+
Binary files u-boot-2010.09-orig/board/samsung/smdk2416/cscope.in.out and u-boot-2010.09-smdk2416/board/samsung/smdk2416/cscope.in.out differ
diff -NBbur u-boot-2010.09-orig/board/samsung/smdk2416/cscope.out u-boot-2010.09-smdk2416/board/samsung/smdk2416/cscope.out
--- u-boot-2010.09-orig/board/samsung/smdk2416/cscope.out	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/board/samsung/smdk2416/cscope.out	2011-09-01 15:14:32.000000000 +0800
@@ -0,0 +1,7252 @@
+cscope 15 /usr/.devices_group/guoqingdong/s3c2416/bootloader/u-boot-2010.09-smdk2416/board/samsung/smdk2416 -q 0000000592 0000039499
+	@nand.c
+
+23 
+	~<comm.h
+>
+
+25 #i
+defed
+(
+CONFIG_CMD_NAND
+)
+
+26 
+	~<nd.h
+>
+
+27 
+	~<gs.h
+>
+
+29 
+	~<asm/io.h
+>
+
+30 
+	~<asm/o.h
+>
+
+33 
+	gbo_nd
+ = 0;
+
+36 
+	#S3C_NAND_TYPE_UNKNOWN
+ 0x0
+
+	)
+
+37 
+	#S3C_NAND_TYPE_SLC
+ 0x1
+
+	)
+
+38 
+	#S3C_NAND_TYPE_MLC
+ 0x2
+
+	)
+
+39 #unde
+S3C_NAND_DEBUG
+
+
+42 
+	gcur_ecc_mode
+ = 0;
+
+43 
+	gnd_ty
+ = 
+S3C_NAND_TYPE_UNKNOWN
+;
+
+46 
+nd_ecayout
+ 
+	gs3c_nd_oob_16
+ = {
+
+47 .
+uecc
+ = 
+MTD_NANDECC_AUTOPLACE
+,
+
+48 .
+	geccbys
+ = 4,
+
+49 .
+	gecos
+ = {1, 2, 3, 4},
+
+50 .
+	goob
+ = {
+
+51 {.
+offt
+ = 6,
+
+52 . 
+	gngth
+ = 10}}
+
+56 
+nd_ecayout
+ 
+	gs3c_nd_oob_64
+ = {
+
+57 .
+uecc
+ = 
+MTD_NANDECC_AUTOPLACE
+,
+
+58 .
+	geccbys
+ = 16,
+
+59 .
+	gecos
+ = {40, 41, 42, 43, 44, 45, 46, 47,
+
+61 .
+	goob
+ = {
+
+62 {.
+offt
+ = 2,
+
+63 .
+	gngth
+ = 38}}
+
+67 
+nd_ecayout
+ 
+	gs3c_nd_oob_mlc_64
+ = {
+
+68 .
+uecc
+ = 
+MTD_NANDECC_AUTOPLACE
+,
+
+69 .
+	geccbys
+ = 32,
+
+70 .
+	gecos
+ = {
+
+75 .
+	goob
+ = {
+
+76 {.
+offt
+ = 2,
+
+77 .
+	gngth
+ = 28}}
+
+80 #i
+defed
+(
+S3C_NAND_DEBUG
+)
+
+85 
+	$t_oob
+(c *
+hd
+, 
+mtd_fo
+ *
+mtd
+)
+
+87 
+i
+;
+
+88 
+nd_ch
+ *
+ch
+ = 
+mtd
+->
+iv
+;
+
+90 
+	`tk
+("%s:\t", 
+hd
+);
+
+92 
+i
+ = 0; i < 64; i++)
+
+93 
+	`tk
+("%02x ", 
+ch
+->
+oob_poi
+[
+i
+]);
+
+95 
+	`tk
+("\n");
+
+96 
+	}
+}
+
+103 
+	$s3c_nd_hwc
+(
+mtd_fo
+ *
+mtd
+, 
+d
+, 
+
+)
+
+105 
+cur
+;
+
+107 i(
+
+ & 
+NAND_CTRL_CHANGE
+) {
+
+108 i(
+
+ & 
+NAND_NCE
+) {
+
+109 i(
+d
+ !
+NAND_CMD_NONE
+) {
+
+110 
+cur
+ = 
+	`adl
+(
+NFCONT
+);
+
+112 i(
+bo_nd
+)
+
+113 
+cur
+ &~
+NFCONT_CS
+;
+
+115 
+cur
+ &~
+NFCONT_CS_ALT
+;
+
+117 
+	`wr
+(
+cur
+, 
+NFCONT
+);
+
+120 
+cur
+ = 
+	`adl
+(
+NFCONT
+);
+
+122 i(
+bo_nd
+)
+
+123 
+cur
+ |
+NFCONT_CS
+;
+
+125 
+cur
+ |
+NFCONT_CS_ALT
+;
+
+127 
+	`wr
+(
+cur
+, 
+NFCONT
+);
+
+131 i(
+d
+ !
+NAND_CMD_NONE
+) {
+
+132 i(
+
+ & 
+NAND_CLE
+)
+
+133 
+	`wreb
+(
+d
+, 
+NFCMMD
+);
+
+134 i(
+
+ & 
+NAND_ALE
+)
+
+135 
+	`wreb
+(
+d
+, 
+NFADDR
+);
+
+137 
+	}
+}
+
+143 
+	$s3c_nd_devi_ady
+(
+mtd_fo
+ *
+mtdfo
+)
+
+145 !(
+	`adl
+(
+NFSTAT
+& 
+NFSTAT_RnB
+)) {}
+
+147 
+	}
+}
+
+152 
+	$s3c_nd_sn_bbt
+(
+mtd_fo
+ *
+mtdfo
+)
+
+154  
+	`nd_deu_bbt
+(
+mtdfo
+);
+
+155 
+	}
+}
+
+157 #i
+defed
+(
+CFG_NAND_HWECC
+)
+
+163 
+	$s3c_nd__
+(
+mtd_fo
+ *
+mtd
+)
+
+165 
+nd_ch
+ *
+ch
+ = 
+mtd
+->
+iv
+;
+
+167 
+ch
+->
+	`cmd_
+(
+mtd
+, 0x0, 
+NAND_NCE
+ | 
+NAND_CTRL_CHANGE
+);
+
+168 
+	`nd_wa_ady
+(
+mtd
+);
+
+169 
+	}
+}
+
+175 
+	$s3c_nd__off
+(
+mtd_fo
+ *
+mtd
+)
+
+177 
+nd_ch
+ *
+ch
+ = 
+mtd
+->
+iv
+;
+
+179 
+ch
+->
+	`cmd_
+(
+mtd
+, 
+NAND_CMD_NONE
+, 
+NAND_CTRL_CHANGE
+);
+
+180 
+	`nd_wa_ady
+(
+mtd
+);
+
+181 
+	}
+}
+
+188 
+	$s3c_nd_wa_c
+()
+
+191 #i
+	`defed
+(
+CONFIG_S3C2450
+|| defed(
+CONFIG_S3C2416
+|| defed(
+CONFIG_S3C2443
+)
+
+192 !(
+	`adl
+(
+NFSTAT
+& 
+NFSTAT_ECCENCDONE
+)) {}
+
+196 
+	}
+}
+
+202 
+	$s3c_nd_wa_dec
+()
+
+204 #i
+	`defed
+(
+CONFIG_S3C2450
+|| defed(
+CONFIG_S3C2416
+|| defed(
+CONFIG_S3C2443
+|| defed(
+CONFIG_S3C2412
+)
+
+205 !(
+	`adl
+(
+NFSTAT
+& 
+NFSTAT_ECCDECDONE
+)) {}
+
+209 
+	}
+}
+
+215 
+	$s3c_nd_wa_ecc_busy
+()
+
+217 #i
+	`defed
+(
+CONFIG_S3C2450
+|| defed(
+CONFIG_S3C2416
+|| defed(
+CONFIG_S3C2443
+|| defed(
+CONFIG_S3C2412
+)
+
+218 
+	`adl
+(
+NFESTAT0
+& 
+NFESTAT0_ECCBUSY
+) {}
+
+220 
+	}
+}
+
+226 
+	$s3c_nd_ab_hwecc
+(
+mtd_fo
+ *
+mtd
+, 
+mode
+)
+
+228 
+u_lg
+ 
+nfct
+;
+
+229 
+cur_ecc_mode
+ = 
+mode
+;
+
+231 #i
+	`defed
+(
+CONFIG_S3C2450
+|| defed(
+CONFIG_S3C2416
+|| defed(
+CONFIG_S3C2443
+|| defed(
+CONFIG_S3C2412
+)
+
+232 
+u_lg
+ 
+nfcf
+;
+
+234 
+nfcf
+ = 
+	`adl
+(
+NFCONF
+);
+
+236 #i
+	`defed
+(
+CONFIG_S3C2450
+|| defed(
+CONFIG_S3C2416
+)
+
+237 
+nfcf
+ &= ~(0x3 << 23);
+
+239 i(
+nd_ty
+ =
+S3C_NAND_TYPE_SLC
+)
+
+240 
+nfcf
+ |
+NFCONF_ECC_1BIT
+;
+
+242 
+nfcf
+ |
+NFCONF_ECC_4BIT
+;
+
+244 i(
+nd_ty
+ =
+S3C_NAND_TYPE_SLC
+)
+
+245 
+nfcf
+ &~
+NFCONF_ECC_MLC
+;
+
+247 
+nfcf
+ |
+NFCONF_ECC_MLC
+;
+
+250 
+	`wr
+(
+nfcf
+, 
+NFCONF
+);
+
+253 
+nfct
+ = 
+	`adl
+(
+NFCONT
+);
+
+254 
+nfct
+ |
+NFCONT_INITMECC
+;
+
+255 
+nfct
+ &~
+NFCONT_MECCLOCK
+;
+
+257 #i
+	`defed
+(
+CONFIG_S3C2450
+|| defed(
+CONFIG_S3C2416
+|| defed(
+CONFIG_S3C2443
+|| defed(
+CONFIG_S3C2412
+)
+
+258 i(
+nd_ty
+ =
+S3C_NAND_TYPE_MLC
+) {
+
+259 i(
+mode
+ =
+NAND_ECC_WRITE
+)
+
+260 
+nfct
+ |
+NFCONT_ECC_ENC
+;
+
+261 i(
+mode
+ =
+NAND_ECC_READ
+)
+
+262 
+nfct
+ &~
+NFCONT_ECC_ENC
+;
+
+265 
+	`wr
+(
+nfct
+, 
+NFCONT
+);
+
+266 
+	}
+}
+
+273 
+	$s3c_nd_lcu_ecc
+(
+mtd_fo
+ *
+mtd
+, c 
+u_ch
+ *
+d
+, u_ch *
+ecc_code
+)
+
+275 
+u_lg
+ 
+nfct
+, 
+nfmecc0
+, 
+nfmecc1
+;
+
+278 
+nfct
+ = 
+	`adl
+(
+NFCONT
+);
+
+279 
+nfct
+ |
+NFCONT_MECCLOCK
+;
+
+280 
+	`wr
+(
+nfct
+, 
+NFCONT
+);
+
+282 i(
+nd_ty
+ =
+S3C_NAND_TYPE_SLC
+) {
+
+283 
+nfmecc0
+ = 
+	`adl
+(
+NFMECC0
+);
+
+285 
+ecc_code
+[0] = 
+nfmecc0
+ & 0xff;
+
+286 
+ecc_code
+[1] = (
+nfmecc0
+ >> 8) & 0xff;
+
+287 
+ecc_code
+[2] = (
+nfmecc0
+ >> 16) & 0xff;
+
+288 
+ecc_code
+[3] = (
+nfmecc0
+ >> 24) & 0xff;
+
+290 i(
+cur_ecc_mode
+ =
+NAND_ECC_READ
+)
+
+291 
+	`s3c_nd_wa_dec
+();
+
+293 
+	`s3c_nd_wa_c
+();
+
+295 
+nfmecc0
+ = 
+	`adl
+(
+NFMECC0
+);
+
+296 
+nfmecc1
+ = 
+	`adl
+(
+NFMECC1
+);
+
+298 
+ecc_code
+[0] = 
+nfmecc0
+ & 0xff;
+
+299 
+ecc_code
+[1] = (
+nfmecc0
+ >> 8) & 0xff;
+
+300 
+ecc_code
+[2] = (
+nfmecc0
+ >> 16) & 0xff;
+
+301 
+ecc_code
+[3] = (
+nfmecc0
+ >> 24) & 0xff;
+
+302 
+ecc_code
+[4] = 
+nfmecc1
+ & 0xff;
+
+303 
+ecc_code
+[5] = (
+nfmecc1
+ >> 8) & 0xff;
+
+304 
+ecc_code
+[6] = (
+nfmecc1
+ >> 16) & 0xff;
+
+305 
+ecc_code
+[7] = (
+nfmecc1
+ >> 24) & 0xff;
+
+310 
+	}
+}
+
+321 
+	$s3c_nd_c_da
+(
+mtd_fo
+ *
+mtd
+, 
+u_ch
+ *
+d
+, u_ch *
+ad_ecc
+, u_ch *
+lc_ecc
+)
+
+323 
+t
+ = -1;
+
+324 
+u_lg
+ 
+n0
+, 
+n1
+, 
+nfmeccda0
+, 
+nfmeccda1
+, 
+nfmlcb
+;
+
+325 
+u_ch
+ 
+r_ty
+;
+
+327 i(
+nd_ty
+ =
+S3C_NAND_TYPE_SLC
+) {
+
+329 
+nfmeccda0
+ = (
+ad_ecc
+[1] << 16) |ead_ecc[0];
+
+330 
+nfmeccda1
+ = (
+ad_ecc
+[3] << 16) |ead_ecc[2];
+
+331 
+	`wr
+(
+nfmeccda0
+, 
+NFMECCDATA0
+);
+
+332 
+	`wr
+(
+nfmeccda1
+, 
+NFMECCDATA1
+);
+
+335 
+n0
+ = 
+	`adl
+(
+NFESTAT0
+);
+
+336 
+r_ty
+ = 
+n0
+ & 0x3;
+
+338 
+r_ty
+) {
+
+340 
+t
+ = 0;
+
+346 
+	`tk
+("s3c-nand: 1 bitrror detectedt byte %ld, correcting from "
+
+347 "0x%02x ", (
+n0
+ >> 7& 0x7ff, 
+d
+[(nfestat0 >> 7) & 0x7ff]);
+
+348 
+d
+[(
+n0
+ >> 7) & 0x7ff] ^= (1 << ((nfestat0 >> 4) & 0x7));
+
+349 
+	`tk
+("t0x%02x...OK\n", 
+d
+[(
+n0
+ >> 7) & 0x7ff]);
+
+350 
+t
+ = 1;
+
+355 
+	`tk
+("s3c-nand: ECC uncorrectablerror detected\n");
+
+356 
+t
+ = -1;
+
+361 
+	`s3c_nd_wa_ecc_busy
+();
+
+363 
+n0
+ = 
+	`adl
+(
+NFESTAT0
+);
+
+364 
+n1
+ = 
+	`adl
+(
+NFESTAT1
+);
+
+366 #i
+	`defed
+(
+CONFIG_S3C2450
+|| defed(
+CONFIG_S3C2416
+|| defed(
+CONFIG_S3C2443
+|| defed(
+CONFIG_S3C2412
+)
+
+367 
+nfmlcb
+ = 
+	`adl
+(
+NFMLCBITPT
+);
+
+370 
+r_ty
+ = (
+n0
+ >> 26) & 0x7;
+
+373 i((
+n0
+ >> 29) & 0x1) {
+
+374 
+r_ty
+ = 0;
+
+377 i(
+d
+) {
+
+378 i(
+d
+[17] == 0xff && dat[26] == 0xff && dat[35] == 0xff && dat[44] == 0xff && dat[54] == 0xff)
+
+379 
+r_ty
+ = 0;
+
+383 
+r_ty
+) {
+
+385 
+	`tk
+("s3c-nand: ECC uncorrectablerror detected\n");
+
+386 
+t
+ = -1;
+
+390 
+d
+[(
+n1
+ >> 16& 0x3ff] ^((
+nfmlcb
+ >> 24) & 0xff);
+
+393 
+d
+[
+n1
+ & 0x3ff] ^((
+nfmlcb
+ >> 16) & 0xff);
+
+396 
+d
+[(
+n0
+ >> 16& 0x3ff] ^((
+nfmlcb
+ >> 8) & 0xff);
+
+399 
+	`tk
+("s3c-nd: %d b(sr deed, ced sucssfuy\n", 
+r_ty
+);
+
+400 
+d
+[
+n0
+ & 0x3ff] ^(
+nfmlcb
+ & 0xff);
+
+401 
+t
+ = 
+r_ty
+;
+
+405 
+t
+ = 0;
+
+410  
+t
+;
+
+411 
+	}
+}
+
+413 #i
+defed
+(
+CONFIG_NAND_BL1_8BIT_ECC
+&& (defed(
+CONFIG_S3C2450
+|| defed(
+CONFIG_S3C2416
+))
+
+417 
+	$s3c_nd_wa_ecc_busy_8b
+()
+
+419 
+	`adl
+(
+NF8ECCERR0
+& 
+NFESTAT0_ECCBUSY
+) {}
+
+420 
+	}
+}
+
+422 
+	$s3c_nd_ab_hwecc_8b
+(
+mtd_fo
+ *
+mtd
+, 
+mode
+)
+
+424 
+u_lg
+ 
+nfct
+, 
+nfcf
+;
+
+426 
+cur_ecc_mode
+ = 
+mode
+;
+
+429 
+nfcf
+ = 
+	`adl
+(
+NFCONF
+);
+
+431 
+nfcf
+ &= ~(0x3 << 23);
+
+432 
+nfcf
+ |= (0x1 << 23);
+
+434 
+	`wr
+(
+nfcf
+, 
+NFCONF
+);
+
+437 
+nfct
+ = 
+	`adl
+(
+NFCONT
+);
+
+438 
+nfct
+ |
+NFCONT_INITECC
+;
+
+439 
+nfct
+ &~
+NFCONT_MECCLOCK
+;
+
+441 i(
+mode
+ =
+NAND_ECC_WRITE
+)
+
+442 
+nfct
+ |
+NFCONT_ECC_ENC
+;
+
+443 i(
+mode
+ =
+NAND_ECC_READ
+)
+
+444 
+nfct
+ &~
+NFCONT_ECC_ENC
+;
+
+446 
+	`wr
+(
+nfct
+, 
+NFCONT
+);
+
+447 
+	}
+}
+
+449 
+	$s3c_nd_lcu_ecc_8b
+(
+mtd_fo
+ *
+mtd
+, c 
+u_ch
+ *
+d
+, u_ch *
+ecc_code
+)
+
+451 
+u_lg
+ 
+nfct
+, 
+nfm8ecc0
+, 
+nfm8ecc1
+, 
+nfm8ecc2
+, 
+nfm8ecc3
+;
+
+454 
+nfct
+ = 
+	`adl
+(
+NFCONT
+);
+
+455 
+nfct
+ |
+NFCONT_MECCLOCK
+;
+
+456 
+	`wr
+(
+nfct
+, 
+NFCONT
+);
+
+458 i(
+cur_ecc_mode
+ =
+NAND_ECC_READ
+)
+
+459 
+	`s3c_nd_wa_dec
+();
+
+461 
+	`s3c_nd_wa_c
+();
+
+463 
+nfm8ecc0
+ = 
+	`adl
+(
+NFM8ECC0
+);
+
+464 
+nfm8ecc1
+ = 
+	`adl
+(
+NFM8ECC1
+);
+
+465 
+nfm8ecc2
+ = 
+	`adl
+(
+NFM8ECC2
+);
+
+466 
+nfm8ecc3
+ = 
+	`adl
+(
+NFM8ECC3
+);
+
+468 
+ecc_code
+[0] = 
+nfm8ecc0
+ & 0xff;
+
+469 
+ecc_code
+[1] = (
+nfm8ecc0
+ >> 8) & 0xff;
+
+470 
+ecc_code
+[2] = (
+nfm8ecc0
+ >> 16) & 0xff;
+
+471 
+ecc_code
+[3] = (
+nfm8ecc0
+ >> 24) & 0xff;
+
+472 
+ecc_code
+[4] = 
+nfm8ecc1
+ & 0xff;
+
+473 
+ecc_code
+[5] = (
+nfm8ecc1
+ >> 8) & 0xff;
+
+474 
+ecc_code
+[6] = (
+nfm8ecc1
+ >> 16) & 0xff;
+
+475 
+ecc_code
+[7] = (
+nfm8ecc1
+ >> 24) & 0xff;
+
+476 
+ecc_code
+[8] = 
+nfm8ecc2
+ & 0xff;
+
+477 
+ecc_code
+[9] = (
+nfm8ecc2
+ >> 8) & 0xff;
+
+478 
+ecc_code
+[10] = (
+nfm8ecc2
+ >> 16) & 0xff;
+
+479 
+ecc_code
+[11] = (
+nfm8ecc2
+ >> 24) & 0xff;
+
+480 
+ecc_code
+[12] = 
+nfm8ecc3
+ & 0xff;
+
+484 
+	}
+}
+
+486 
+	$s3c_nd_c_da_8b
+(
+mtd_fo
+ *
+mtd
+, 
+u_ch
+ *
+d
+, u_ch *
+ad_ecc
+, u_ch *
+lc_ecc
+)
+
+488 
+t
+ = -1;
+
+489 
+u_lg
+ 
+nf8ec0
+, 
+nf8ec1
+, 
+nf8ec2
+, 
+nfmlc8b0
+, 
+nfmlc8b1
+;
+
+490 
+u_ch
+ 
+r_ty
+;
+
+492 
+	`s3c_nd_wa_ecc_busy_8b
+();
+
+494 
+nf8ec0
+ = 
+	`adl
+(
+NF8ECCERR0
+);
+
+495 
+nf8ec1
+ = 
+	`adl
+(
+NF8ECCERR1
+);
+
+496 
+nf8ec2
+ = 
+	`adl
+(
+NF8ECCERR2
+);
+
+497 
+nfmlc8b0
+ = 
+	`adl
+(
+NFMLC8BITPT0
+);
+
+498 
+nfmlc8b1
+ = 
+	`adl
+(
+NFMLC8BITPT1
+);
+
+500 
+r_ty
+ = (
+nf8ec0
+ >> 25) & 0xf;
+
+503 i((
+nf8ec0
+ >> 29) & 0x1)
+
+504 
+r_ty
+ = 0;
+
+506 
+r_ty
+) {
+
+508 
+	`tk
+("s3c-nand: ECC uncorrectablerror detected\n");
+
+509 
+t
+ = -1;
+
+513 
+d
+[(
+nf8ec2
+ >> 22& 0x3ff] ^((
+nfmlc8b1
+ >> 24) & 0xff);
+
+516 
+d
+[(
+nf8ec2
+ >> 11& 0x3ff] ^((
+nfmlc8b1
+ >> 16) & 0xff);
+
+519 
+d
+[
+nf8ec2
+ & 0x3ff] ^((
+nfmlc8b1
+ >> 8) & 0xff);
+
+522 
+d
+[(
+nf8ec1
+ >> 22& 0x3ff] ^(
+nfmlc8b1
+ & 0xff);
+
+525 
+d
+[(
+nf8ec1
+ >> 11& 0x3ff] ^((
+nfmlc8b0
+ >> 24) & 0xff);
+
+528 
+d
+[
+nf8ec1
+ & 0x3ff] ^((
+nfmlc8b0
+ >> 16) & 0xff);
+
+531 
+d
+[(
+nf8ec0
+ >> 15& 0x3ff] ^((
+nfmlc8b0
+ >> 8) & 0xff);
+
+534 
+	`tk
+("s3c-nd: %d b(sr deed, ced sucssfuy\n", 
+r_ty
+);
+
+535 
+d
+[
+nf8ec0
+ & 0x3ff] ^(
+nfmlc8b0
+ & 0xff);
+
+536 
+t
+ = 
+r_ty
+;
+
+540 
+t
+ = 0;
+
+544  
+t
+;
+
+545 
+	}
+}
+
+547 
+	$s3c_nd_wre_ge_8b
+(
+mtd_fo
+ *
+mtd
+, 
+nd_ch
+ *
+ch
+,
+
+548 c 
+ut8_t
+ *
+buf
+)
+
+550 
+i
+, 
+eccsize
+ = 512;
+
+551 
+eccbys
+ = 13;
+
+552 
+eccs
+ = 
+mtd
+->
+wresize
+ / 
+eccsize
+;
+
+553 
+ut8_t
+ *
+ecc_lc
+ = 
+ch
+->
+bufrs
+->
+ecclc
+;
+
+554 c 
+ut8_t
+ *
+p
+ = 
+buf
+;
+
+556 
+i
+ = 0; 
+eccs
+;ccs--, i +
+eccbys
+, 
+p
+ +
+eccsize
+) {
+
+557 
+	`s3c_nd_ab_hwecc_8b
+(
+mtd
+, 
+NAND_ECC_WRITE
+);
+
+558 
+ch
+->
+	`wre_buf
+(
+mtd
+, 
+p
+, 
+eccsize
+);
+
+559 
+	`s3c_nd_lcu_ecc_8b
+(
+mtd
+, 
+p
+, &
+ecc_lc
+[
+i
+]);
+
+562 
+i
+ = 0; i < 
+eccbys
+ * (
+mtd
+->
+wresize
+ / 
+eccsize
+); i++)
+
+563 
+ch
+->
+oob_poi
+[
+i
+] = 
+ecc_lc
+[i];
+
+565 
+ch
+->
+	`wre_buf
+(
+mtd
+, ch->
+oob_poi
+, mtd->
+oobsize
+);
+
+566 
+	}
+}
+
+568 
+	$s3c_nd_ad_ge_8b
+(
+mtd_fo
+ *
+mtd
+, 
+nd_ch
+ *
+ch
+,
+
+569 
+ut8_t
+ *
+buf
+)
+
+571 
+i
+, 
+
+, 
+eccsize
+ = 512;
+
+572 
+eccbys
+ = 13;
+
+573 
+eccs
+ = 
+mtd
+->
+wresize
+ / 
+eccsize
+;
+
+574 
+c
+ = 0;
+
+575 
+ut8_t
+ *
+p
+ = 
+buf
+;
+
+578 
+c
+ = 
+mtd
+->
+wresize
+;
+
+579 
+ch
+->
+	`cmdfunc
+(
+mtd
+, 
+NAND_CMD_RNDOUT
+, 
+c
+, -1);
+
+580 
+ch
+->
+	`ad_buf
+(
+mtd
+, ch->
+oob_poi
+, mtd->
+oobsize
+);
+
+582 
+c
+ = 0;
+
+583 
+i
+ = 0; 
+eccs
+;ccs--, i +
+eccbys
+, 
+p
+ +
+eccsize
+) {
+
+584 
+ch
+->
+	`cmdfunc
+(
+mtd
+, 
+NAND_CMD_RNDOUT
+, 
+c
+, -1);
+
+585 
+	`s3c_nd_ab_hwecc_8b
+(
+mtd
+, 
+NAND_ECC_READ
+);
+
+586 
+ch
+->
+	`ad_buf
+(
+mtd
+, 
+p
+, 
+eccsize
+);
+
+587 
+ch
+->
+	`wre_buf
+(
+mtd
+, ch->
+oob_poi
+ + (((mtd->
+wresize
+ / 
+eccsize
+- 
+eccs
+* 
+eccbys
+),ccbytes);
+
+588 
+	`s3c_nd_lcu_ecc_8b
+(
+mtd
+, 0, 0);
+
+589 
+
+ = 
+	`s3c_nd_c_da_8b
+(
+mtd
+, 
+p
+, 0, 0);
+
+591 i(
+
+ == -1)
+
+592 
+mtd
+->
+ecc_s
+.
+ed
+++;
+
+594 
+c
+ = 
+eccsize
+ * ((
+mtd
+->
+wresize
+ /ccsize+ 1 - 
+eccs
+);
+
+598 
+	}
+}
+
+603 
+	$s3c_nd_wre_oob_1b
+(
+mtd_fo
+ *
+mtd
+, 
+nd_ch
+ *
+ch
+,
+
+604 
+ge
+)
+
+606 
+ut8_t
+ *
+ecc_lc
+ = 
+ch
+->
+bufrs
+->
+ecclc
+;
+
+607 
+us
+ = 0;
+
+608 
+eccbys
+ = 
+ch
+->
+ecc
+.
+bys
+;
+
+609 
+cc_t
+ = 
+mtd
+->
+oobsize
+ - 
+eccbys
+;
+
+610 
+i
+;
+
+612 
+ch
+->
+	`cmdfunc
+(
+mtd
+, 
+NAND_CMD_SEQIN
+, mtd->
+wresize
+, 
+ge
+);
+
+615 
+ch
+->
+ecc
+.
+	`hwl
+(
+mtd
+, 
+NAND_ECC_WRITE
+);
+
+616 
+ch
+->
+	`wre_buf
+(
+mtd
+, ch->
+oob_poi
+, 
+cc_t
+);
+
+617 
+ch
+->
+ecc
+.
+	`lcu
+(
+mtd
+, 0, &
+ecc_lc
+[ch->ecc.
+t
+]);
+
+619 
+i
+ = 0; i < 
+eccbys
+; i++)
+
+620 
+ch
+->
+oob_poi
+[
+cc_t
+ + 
+i
+] = 
+ecc_lc
+[ch->
+ecc
+.
+t
+ + i];
+
+622 
+ch
+->
+	`wre_buf
+(
+mtd
+, ch->
+oob_poi
+ + 
+cc_t
+, 
+eccbys
+);
+
+625 
+ch
+->
+	`cmdfunc
+(
+mtd
+, 
+NAND_CMD_PAGEPROG
+, -1, -1);
+
+627 
+us
+ = 
+ch
+->
+	`wafunc
+(
+mtd
+, chip);
+
+629  
+us
+ & 
+NAND_STATUS_FAIL
+ ? -
+EIO
+ : 0;
+
+630 
+	}
+}
+
+632 
+	$s3c_nd_ad_oob_1b
+(
+mtd_fo
+ *
+mtd
+, 
+nd_ch
+ *
+ch
+,
+
+633 
+ge
+, 
+dcmd
+)
+
+635 
+ut8_t
+ *
+ecc_lc
+ = 
+ch
+->
+bufrs
+->
+ecclc
+;
+
+636 
+eccbys
+ = 
+ch
+->
+ecc
+.
+bys
+;
+
+637 
+cc_t
+ = 
+mtd
+->
+oobsize
+ - 
+eccbys
+;
+
+639 i(
+dcmd
+) {
+
+640 
+ch
+->
+	`cmdfunc
+(
+mtd
+, 
+NAND_CMD_READOOB
+, 0, 
+ge
+);
+
+641 
+dcmd
+ = 0;
+
+644 
+ch
+->
+ecc
+.
+	`hwl
+(
+mtd
+, 
+NAND_ECC_READ
+);
+
+645 
+ch
+->
+	`ad_buf
+(
+mtd
+, ch->
+oob_poi
+, 
+cc_t
+);
+
+646 
+ch
+->
+ecc
+.
+	`lcu
+(
+mtd
+, 0, &
+ecc_lc
+[ch->ecc.
+t
+]);
+
+647 
+ch
+->
+	`ad_buf
+(
+mtd
+, ch->
+oob_poi
+ + 
+cc_t
+, 
+eccbys
+);
+
+650 i(!(
+ch
+->
+oob_poi
+[2] == 0x85 && chip->oob_poi[3] == 0x19))
+
+651 
+ch
+->
+ecc
+.
+	`c
+(
+mtd
+, ch->
+oob_poi
+, ch->oob_po+ 
+cc_t
+, 0);
+
+653  
+dcmd
+;
+
+654 
+	}
+}
+
+656 
+	$s3c_nd_wre_ge_1b
+(
+mtd_fo
+ *
+mtd
+, 
+nd_ch
+ *
+ch
+,
+
+657 c 
+ut8_t
+ *
+buf
+)
+
+659 
+i
+, 
+eccsize
+ = 
+ch
+->
+ecc
+.
+size
+;
+
+660 
+eccbys
+ = 
+ch
+->
+ecc
+.
+bys
+;
+
+661 
+eccs
+ = 
+ch
+->
+ecc
+.
+s
+;
+
+662 
+cc_t
+ = 
+mtd
+->
+oobsize
+ - 
+eccbys
+;
+
+663 
+ut8_t
+ *
+ecc_lc
+ = 
+ch
+->
+bufrs
+->
+ecclc
+;
+
+664 c 
+ut8_t
+ *
+p
+ = 
+buf
+;
+
+666 
+ut32_t
+ *
+ecos
+ = 
+ch
+->
+ecc
+.
+yout
+->eccpos;
+
+669 
+i
+ = 0; 
+eccs
+;ccs--, i +
+eccbys
+, 
+p
+ +
+eccsize
+) {
+
+670 
+ch
+->
+ecc
+.
+	`hwl
+(
+mtd
+, 
+NAND_ECC_WRITE
+);
+
+671 
+ch
+->
+	`wre_buf
+(
+mtd
+, 
+p
+, 
+eccsize
+);
+
+672 
+ch
+->
+ecc
+.
+	`lcu
+(
+mtd
+, 
+p
+, &
+ecc_lc
+[
+i
+]);
+
+675 
+i
+ = 0; i < 
+ch
+->
+ecc
+.
+t
+; i++)
+
+676 
+ch
+->
+oob_poi
+[
+ecos
+[
+i
+]] = 
+ecc_lc
+[i];
+
+679 
+ch
+->
+ecc
+.
+	`hwl
+(
+mtd
+, 
+NAND_ECC_WRITE
+);
+
+680 
+ch
+->
+	`wre_buf
+(
+mtd
+, ch->
+oob_poi
+, 
+cc_t
+);
+
+681 
+ch
+->
+ecc
+.
+	`lcu
+(
+mtd
+, 
+p
+, &
+ecc_lc
+[ch->ecc.
+t
+]);
+
+683 
+i
+ = 0; i < 
+eccbys
+; i++)
+
+684 
+ch
+->
+oob_poi
+[
+cc_t
+ + 
+i
+] = 
+ecc_lc
+[ch->
+ecc
+.
+t
+ + i];
+
+686 
+ch
+->
+	`wre_buf
+(
+mtd
+, ch->
+oob_poi
+ + 
+cc_t
+, 
+eccbys
+);
+
+687 
+	}
+}
+
+689 
+	$s3c_nd_ad_ge_1b
+(
+mtd_fo
+ *
+mtd
+, 
+nd_ch
+ *
+ch
+,
+
+690 
+ut8_t
+ *
+buf
+, 
+ge
+)
+
+692 
+i
+, 
+
+, 
+eccsize
+ = 
+ch
+->
+ecc
+.
+size
+;
+
+693 
+eccbys
+ = 
+ch
+->
+ecc
+.
+bys
+;
+
+694 
+eccs
+ = 
+ch
+->
+ecc
+.
+s
+;
+
+695 
+cc_t
+ = 
+mtd
+->
+oobsize
+ - 
+eccbys
+;
+
+696 
+c
+ = 0;
+
+697 
+ut8_t
+ *
+p
+ = 
+buf
+;
+
+698 
+ut32_t
+ *
+mecc_pos
+ = 
+ch
+->
+ecc
+.
+yout
+->
+ecos
+;
+
+699 
+ut8_t
+ *
+ecc_lc
+ = 
+ch
+->
+bufrs
+->
+ecclc
+;
+
+701 
+c
+ = 
+mtd
+->
+wresize
+;
+
+702 
+ch
+->
+	`cmdfunc
+(
+mtd
+, 
+NAND_CMD_RNDOUT
+, 
+c
+, 
+ge
+);
+
+705 
+ch
+->
+ecc
+.
+	`hwl
+(
+mtd
+, 
+NAND_ECC_READ
+);
+
+706 
+ch
+->
+	`ad_buf
+(
+mtd
+, ch->
+oob_poi
+, 
+cc_t
+);
+
+707 
+ch
+->
+ecc
+.
+	`lcu
+(
+mtd
+, 
+p
+, &
+ecc_lc
+[ch->ecc.
+t
+]);
+
+708 
+ch
+->
+	`ad_buf
+(
+mtd
+, ch->
+oob_poi
+ + 
+cc_t
+, 
+eccbys
+);
+
+711 i(!(
+ch
+->
+oob_poi
+[2] == 0x85 && chip->oob_poi[3] == 0x19))
+
+712 
+ch
+->
+ecc
+.
+	`c
+(
+mtd
+, ch->
+oob_poi
+, ch->oob_po+ 
+cc_t
+, 0);
+
+714 
+c
+ = 0;
+
+717 
+i
+ = 0; 
+eccs
+;ccs--, i +
+eccbys
+, 
+p
+ +
+eccsize
+) {
+
+718 
+ch
+->
+	`cmdfunc
+(
+mtd
+, 
+NAND_CMD_RNDOUT
+, 
+c
+, 
+ge
+);
+
+719 
+ch
+->
+ecc
+.
+	`hwl
+(
+mtd
+, 
+NAND_ECC_READ
+);
+
+720 
+ch
+->
+	`ad_buf
+(
+mtd
+, 
+p
+, 
+eccsize
+);
+
+721 
+ch
+->
+ecc
+.
+	`lcu
+(
+mtd
+, 
+p
+, &
+ecc_lc
+[
+i
+]);
+
+723 
+
+ = 
+ch
+->
+ecc
+.
+	`c
+(
+mtd
+, 
+p
+, ch->
+oob_poi
+ + 
+mecc_pos
+[0] + ((ch->ecc.
+s
+ - 
+eccs
+* 
+eccbys
+), 0);
+
+724 i(
+
+ == -1)
+
+725 
+mtd
+->
+ecc_s
+.
+ed
+++;
+
+727 
+c
+ = 
+eccsize
+ * (
+ch
+->
+ecc
+.
+s
+ + 1 - 
+eccs
+);
+
+731 
+	}
+}
+
+737 
+	$s3c_nd_ad_ge_4b
+(
+mtd_fo
+ *
+mtd
+, 
+nd_ch
+ *
+ch
+,
+
+738 
+ut8_t
+ *
+buf
+, 
+ge
+)
+
+740 
+i
+, 
+
+, 
+eccsize
+ = 
+ch
+->
+ecc
+.
+size
+;
+
+741 
+eccbys
+ = 
+ch
+->
+ecc
+.
+bys
+;
+
+742 
+eccs
+ = 
+ch
+->
+ecc
+.
+s
+;
+
+743 
+c
+ = 0;
+
+744 
+ut8_t
+ *
+p
+ = 
+buf
+;
+
+745 
+ut32_t
+ *
+mecc_pos
+ = 
+ch
+->
+ecc
+.
+yout
+->
+ecos
+;
+
+748 
+c
+ = 
+mtd
+->
+wresize
+;
+
+749 
+ch
+->
+	`cmdfunc
+(
+mtd
+, 
+NAND_CMD_RNDOUT
+, 
+c
+, 
+ge
+);
+
+750 
+ch
+->
+	`ad_buf
+(
+mtd
+, ch->
+oob_poi
+, mtd->
+oobsize
+);
+
+752 
+c
+ = 0;
+
+753 
+i
+ = 0; 
+eccs
+;ccs--, i +
+eccbys
+, 
+p
+ +
+eccsize
+) {
+
+754 
+ch
+->
+	`cmdfunc
+(
+mtd
+, 
+NAND_CMD_RNDOUT
+, 
+c
+, 
+ge
+);
+
+755 
+ch
+->
+ecc
+.
+	`hwl
+(
+mtd
+, 
+NAND_ECC_READ
+);
+
+756 
+ch
+->
+	`ad_buf
+(
+mtd
+, 
+p
+, 
+eccsize
+);
+
+757 
+ch
+->
+	`wre_buf
+(
+mtd
+, ch->
+oob_poi
+ + 
+mecc_pos
+[0] + ((ch->
+ecc
+.
+s
+ - 
+eccs
+* 
+eccbys
+),ccbytes);
+
+758 
+ch
+->
+ecc
+.
+	`lcu
+(
+mtd
+, 0, 0);
+
+759 
+
+ = 
+ch
+->
+ecc
+.
+	`c
+(
+mtd
+, 
+p
+, 0, 0);
+
+761 i(
+
+ == -1)
+
+762 
+mtd
+->
+ecc_s
+.
+ed
+++;
+
+764 
+c
+ = 
+eccsize
+ * (
+ch
+->
+ecc
+.
+s
+ + 1 - 
+eccs
+);
+
+768 
+	}
+}
+
+774 
+	$s3c_nd_wre_ge_4b
+(
+mtd_fo
+ *
+mtd
+, 
+nd_ch
+ *
+ch
+,
+
+775 c 
+ut8_t
+ *
+buf
+)
+
+777 
+i
+, 
+eccsize
+ = 
+ch
+->
+ecc
+.
+size
+;
+
+778 
+eccbys
+ = 
+ch
+->
+ecc
+.
+bys
+;
+
+779 
+eccs
+ = 
+ch
+->
+ecc
+.
+s
+;
+
+780 c 
+ut8_t
+ *
+p
+ = 
+buf
+;
+
+781 
+ut8_t
+ *
+ecc_lc
+ = 
+ch
+->
+bufrs
+->
+ecclc
+;
+
+782 
+ut32_t
+ *
+mecc_pos
+ = 
+ch
+->
+ecc
+.
+yout
+->
+ecos
+;
+
+785 
+i
+ = 0; 
+eccs
+;ccs--, i +
+eccbys
+, 
+p
+ +
+eccsize
+) {
+
+786 
+ch
+->
+ecc
+.
+	`hwl
+(
+mtd
+, 
+NAND_ECC_WRITE
+);
+
+787 
+ch
+->
+	`wre_buf
+(
+mtd
+, 
+p
+, 
+eccsize
+);
+
+788 
+ch
+->
+ecc
+.
+	`lcu
+(
+mtd
+, 
+p
+, &
+ecc_lc
+[
+i
+]);
+
+792 
+i
+ = 0; i < 
+ch
+->
+ecc
+.
+t
+; i++)
+
+793 
+ch
+->
+oob_poi
+[
+mecc_pos
+[
+i
+]] = 
+ecc_lc
+[i];
+
+795 
+ch
+->
+	`wre_buf
+(
+mtd
+, ch->
+oob_poi
+, mtd->
+oobsize
+);
+
+796 
+	}
+}
+
+817 
+	$brd_nd_
+(
+nd_ch
+ *
+nd
+)
+
+819 #i
+	`defed
+(
+CFG_NAND_HWECC
+)
+
+820 
+i
+;
+
+821 
+u_ch
+ 
+tmp
+;
+
+822 
+nd_ash_dev
+ *
+ty
+ = 
+NULL
+;
+
+825 i(
+NFCONF_REG
+ & 0x80000000)
+
+826 
+bo_nd
+ = 1;
+
+828 
+bo_nd
+ = 0;
+
+830 
+NFCONT_REG
+ &~
+NFCONT_WP
+;
+
+831 
+nd
+->
+IO_ADDR_R
+ = (
+__iomem
+ *)(
+NFDATA
+);
+
+832 
+nd
+->
+IO_ADDR_W
+ = (
+__iomem
+ *)(
+NFDATA
+);
+
+833 
+nd
+->
+cmd_
+ = 
+s3c_nd_hwc
+;
+
+834 
+nd
+->
+dev_ady
+ = 
+s3c_nd_devi_ady
+;
+
+835 
+nd
+->
+sn_bbt
+ = 
+s3c_nd_sn_bbt
+;
+
+836 
+nd
+->
+tis
+ = 0;
+
+838 #i
+	`defed
+(
+CFG_NAND_FLASH_BBT
+)
+
+839 
+nd
+->
+tis
+ |
+NAND_USE_FLASH_BBT
+;
+
+841 
+nd
+->
+tis
+ |
+NAND_SKIP_BBTSCAN
+;
+
+844 #i
+	`defed
+(
+CFG_NAND_HWECC
+)
+
+845 
+nd
+->
+ecc
+.
+mode
+ = 
+NAND_ECC_HW
+;
+
+846 
+nd
+->
+ecc
+.
+hwl
+ = 
+s3c_nd_ab_hwecc
+;
+
+847 
+nd
+->
+ecc
+.
+lcu
+ = 
+s3c_nd_lcu_ecc
+;
+
+848 
+nd
+->
+ecc
+.
+c
+ = 
+s3c_nd_c_da
+;
+
+850 
+	`s3c_nd_hwc
+(0, 
+NAND_CMD_READID
+, 
+NAND_NCE
+ | 
+NAND_CLE
+ | 
+NAND_CTRL_CHANGE
+);
+
+851 
+	`s3c_nd_hwc
+(0, 0x00, 
+NAND_CTRL_CHANGE
+ | 
+NAND_NCE
+ | 
+NAND_ALE
+);
+
+852 
+	`s3c_nd_hwc
+(0, 0x00, 
+NAND_NCE
+ | 
+NAND_ALE
+);
+
+853 
+	`s3c_nd_hwc
+(0, 
+NAND_CMD_NONE
+, 
+NAND_NCE
+ | 
+NAND_CTRL_CHANGE
+);
+
+854 
+	`s3c_nd_devi_ady
+(0);
+
+856 
+tmp
+ = 
+	`adb
+(
+nd
+->
+IO_ADDR_R
+);
+
+858 
+tmp
+ = 
+	`adb
+(
+nd
+->
+IO_ADDR_R
+);
+
+860 
+i
+ = 0; 
+nd_ash_ids
+[i].
+me
+ !
+NULL
+; i++) {
+
+861 i(
+tmp
+ =
+nd_ash_ids
+[
+i
+].
+id
+) {
+
+862 
+ty
+ = &
+nd_ash_ids
+[
+i
+];
+
+867 
+nd
+->
+fo
+ = 
+	`adb
+d->
+IO_ADDR_R
+);
+
+869 
+tmp
+ = 
+	`adb
+(
+nd
+->
+IO_ADDR_R
+);
+
+871 i(!
+ty
+->
+gesize
+) {
+
+872 i(((
+nd
+->
+fo
+ >> 2) & 0x3) == 0) {
+
+873 
+nd_ty
+ = 
+S3C_NAND_TYPE_SLC
+;
+
+874 
+nd
+->
+ecc
+.
+size
+ = 512;
+
+875 
+nd
+->
+ecc
+.
+bys
+ = 4;
+
+877 i((1024 << (
+tmp
+ & 0x3)) > 512) {
+
+878 
+nd
+->
+ecc
+.
+ad_ge
+ = 
+s3c_nd_ad_ge_1b
+;
+
+879 
+nd
+->
+ecc
+.
+wre_ge
+ = 
+s3c_nd_wre_ge_1b
+;
+
+880 
+nd
+->
+ecc
+.
+ad_oob
+ = 
+s3c_nd_ad_oob_1b
+;
+
+881 
+nd
+->
+ecc
+.
+wre_oob
+ = 
+s3c_nd_wre_oob_1b
+;
+
+882 
+nd
+->
+ecc
+.
+yout
+ = &
+s3c_nd_oob_64
+;
+
+884 
+nd
+->
+ecc
+.
+yout
+ = &
+s3c_nd_oob_16
+;
+
+887 
+nd_ty
+ = 
+S3C_NAND_TYPE_MLC
+;
+
+888 
+nd
+->
+tis
+ |
+NAND_NO_SUBPAGE_WRITE
+;
+
+889 
+nd
+->
+ecc
+.
+ad_ge
+ = 
+s3c_nd_ad_ge_4b
+;
+
+890 
+nd
+->
+ecc
+.
+wre_ge
+ = 
+s3c_nd_wre_ge_4b
+;
+
+891 
+nd
+->
+ecc
+.
+size
+ = 512;
+
+892 
+nd
+->
+ecc
+.
+bys
+ = 8;
+
+893 
+nd
+->
+ecc
+.
+yout
+ = &
+s3c_nd_oob_mlc_64
+;
+
+897 
+nd_ty
+ = 
+S3C_NAND_TYPE_SLC
+;
+
+898 
+nd
+->
+ecc
+.
+size
+ = 512;
+
+899 
+nd
+->
+fo
+ = 0;
+
+900 
+nd
+->
+ecc
+.
+bys
+ = 4;
+
+901 
+nd
+->
+ecc
+.
+yout
+ = &
+s3c_nd_oob_16
+;
+
+904 
+nd
+->
+ecc
+.
+mode
+ = 
+NAND_ECC_SOFT
+;
+
+908 
+	}
+}
+
+	@smdk2416.c
+
+27 
+	~<comm.h
+>
+
+28 
+	~<gs.h
+>
+
+30 #i
+defed
+(
+CONFIG_DRIVER_SMC911X
+)
+
+32 
+smc911x_lize
+ (
+bd_t
+ * 
+bis
+);
+
+35 
+	gDECLARE_GLOBAL_DATA_PTR
+;
+
+37 
+le
+ 
+	$day
+(
+los
+)
+
+39 
+__asm__
+ v("1:\n" "sub%0, %1, #1\n" "b 1b":"" (
+los
+):"0"(loops));
+
+40 
+	}
+}
+
+42 
+	$brd_
+()
+
+44 
+gd
+->
+bd
+->
+bi_ch_numb
+ = 
+MACH_TYPE
+;
+
+45 
+gd
+->
+bd
+->
+bi_bo_ms
+ = (
+PHYS_SDRAM_1
++0x100);
+
+48 
+	`iche_ab
+();
+
+49 
+	`dche_ab
+();
+
+53 
+	}
+}
+
+55 
+	$dm_
+()
+
+57 
+gd
+->
+bd
+->
+bi_dm
+[0].
+t
+ = 
+PHYS_SDRAM_1
+;
+
+58 
+gd
+->
+bd
+->
+bi_dm
+[0].
+size
+ = 
+PHYS_SDRAM_1_SIZE
+;
+
+61 
+	}
+}
+
+63 #ifde
+BOARD_LATE_INIT
+
+
+64 
+	$brd__
+ ()
+
+66 
+ut
+ *
+magic
+ = (ut*)(
+PHYS_SDRAM_1
+);
+
+67 
+bo_cmd
+[100];
+
+69 i((0x24564236 =
+magic
+[0]) && (0x20764316 == magic[1])) {
+
+70 
+	`rtf
+(
+bo_cmd
+, "nd 0 40000;nd wr%08x 0 40000", 
+PHYS_SDRAM_1
+ + 0x8000);
+
+71 
+magic
+[0] = 0;
+
+72 
+magic
+[1] = 0;
+
+73 
+	`tf
+("\nready for self-burning U-Boot image\n\n");
+
+74 
+	`nv
+("bootdelay", "0");
+
+75 
+	`nv
+("bocmd", 
+bo_cmd
+);
+
+79 
+	}
+}
+
+82 #ifde
+CONFIG_DISPLAY_BOARDINFO
+
+
+83 
+	$checkbrd
+()
+
+85 
+vu_lg
+ *
+mem_g
+ = (vu_long*) 0x48000000;
+
+87 
+	`tf
+("Board: GHL SMDK2416 ");
+
+88 (*
+mem_g
+>>1) & 0x7) {
+
+90 
+	`puts
+("SDRAM\n");
+
+93 
+	`puts
+("DDR2\n");
+
+96 
+	`puts
+("Mobile SDRAM\n");
+
+99 
+	`puts
+("DDR\n");
+
+102 
+	`puts
+("Mobile DDR\n");
+
+105 
+	`puts
+("unknown Memory Type\n");
+
+108 
+	}
+}
+
+111 #ifde
+CONFIG_ENABLE_MMU
+
+
+112 
+ulg
+ 
+	$vt_to_phy_smdk2416
+(
+ulg
+ 
+addr
+)
+
+114 i((0xC0000000 <
+addr
+) && (addr < 0xC4000000))
+
+115  (
+addr
+ - 0xC0000000 + 0x30000000);
+
+117 
+	`tf
+("dn suthiadds: %08lx\n", 
+addr
+);
+
+119  
+addr
+;
+
+120 
+	}
+}
+
+123 #ifde
+CONFIG_CMD_NET
+
+
+124 
+	$brd_h_
+(
+bd_t
+ *
+bis
+)
+
+126 
+rc
+ = 0;
+
+127 #ifde
+CONFIG_DRIVER_SMC911X
+
+
+128 
+	`tf
+("come here\n");
+
+129 
+rc
+ = 
+	`smc911x_lize
+(
+bis
+);
+
+131  
+rc
+;
+
+132 
+	}
+}
+
+	@/usr/include/asm/errno.h
+
+1 #ide
+_I386_ERRNO_H
+
+
+2 
+	#_I386_ERRNO_H
+
+
+	)
+
+4 
+	#EPERM
+ 1
+
+	)
+
+5 
+	#ENOENT
+ 2
+
+	)
+
+6 
+	#ESRCH
+ 3
+
+	)
+
+7 
+	#EINTR
+ 4
+
+	)
+
+8 
+	#EIO
+ 5
+
+	)
+
+9 
+	#ENXIO
+ 6
+
+	)
+
+10 
+	#E2BIG
+ 7
+
+	)
+
+11 
+	#ENOEXEC
+ 8
+
+	)
+
+12 
+	#EBADF
+ 9
+
+	)
+
+13 
+	#ECHILD
+ 10
+
+	)
+
+14 
+	#EAGAIN
+ 11
+
+	)
+
+15 
+	#ENOMEM
+ 12
+
+	)
+
+16 
+	#EACCES
+ 13
+
+	)
+
+17 
+	#EFAULT
+ 14
+
+	)
+
+18 
+	#ENOTBLK
+ 15
+
+	)
+
+19 
+	#EBUSY
+ 16
+
+	)
+
+20 
+	#EEXIST
+ 17
+
+	)
+
+21 
+	#EXDEV
+ 18
+
+	)
+
+22 
+	#ENODEV
+ 19
+
+	)
+
+23 
+	#ENOTDIR
+ 20
+
+	)
+
+24 
+	#EISDIR
+ 21
+
+	)
+
+25 
+	#EINVAL
+ 22
+
+	)
+
+26 
+	#ENFILE
+ 23
+
+	)
+
+27 
+	#EMFILE
+ 24
+
+	)
+
+28 
+	#ENOTTY
+ 25
+
+	)
+
+29 
+	#ETXTBSY
+ 26
+
+	)
+
+30 
+	#EFBIG
+ 27
+
+	)
+
+31 
+	#ENOSPC
+ 28
+
+	)
+
+32 
+	#ESPIPE
+ 29
+
+	)
+
+33 
+	#EROFS
+ 30
+
+	)
+
+34 
+	#EMLINK
+ 31
+
+	)
+
+35 
+	#EPIPE
+ 32
+
+	)
+
+36 
+	#EDOM
+ 33
+
+	)
+
+37 
+	#ERANGE
+ 34
+
+	)
+
+38 
+	#EDEADLK
+ 35
+
+	)
+
+39 
+	#ENAMETOOLONG
+ 36
+
+	)
+
+40 
+	#ENOLCK
+ 37
+
+	)
+
+41 
+	#ENOSYS
+ 38
+
+	)
+
+42 
+	#ENOTEMPTY
+ 39
+
+	)
+
+43 
+	#ELOOP
+ 40
+
+	)
+
+44 
+	#EWOULDBLOCK
+ 
+EAGAIN
+
+
+	)
+
+45 
+	#ENOMSG
+ 42
+
+	)
+
+46 
+	#EIDRM
+ 43
+
+	)
+
+47 
+	#ECHRNG
+ 44
+
+	)
+
+48 
+	#EL2NSYNC
+ 45
+
+	)
+
+49 
+	#EL3HLT
+ 46
+
+	)
+
+50 
+	#EL3RST
+ 47
+
+	)
+
+51 
+	#ELNRNG
+ 48
+
+	)
+
+52 
+	#EUNATCH
+ 49
+
+	)
+
+53 
+	#ENOCSI
+ 50
+
+	)
+
+54 
+	#EL2HLT
+ 51
+
+	)
+
+55 
+	#EBADE
+ 52
+
+	)
+
+56 
+	#EBADR
+ 53
+
+	)
+
+57 
+	#EXFULL
+ 54
+
+	)
+
+58 
+	#ENOANO
+ 55
+
+	)
+
+59 
+	#EBADRQC
+ 56
+
+	)
+
+60 
+	#EBADSLT
+ 57
+
+	)
+
+62 
+	#EDEADLOCK
+ 
+EDEADLK
+
+
+	)
+
+64 
+	#EBFONT
+ 59
+
+	)
+
+65 
+	#ENOSTR
+ 60
+
+	)
+
+66 
+	#ENODATA
+ 61
+
+	)
+
+67 
+	#ETIME
+ 62
+
+	)
+
+68 
+	#ENOSR
+ 63
+
+	)
+
+69 
+	#ENONET
+ 64
+
+	)
+
+70 
+	#ENOPKG
+ 65
+
+	)
+
+71 
+	#EREMOTE
+ 66
+
+	)
+
+72 
+	#ENOLINK
+ 67
+
+	)
+
+73 
+	#EADV
+ 68
+
+	)
+
+74 
+	#ESRMNT
+ 69
+
+	)
+
+75 
+	#ECOMM
+ 70
+
+	)
+
+76 
+	#EPROTO
+ 71
+
+	)
+
+77 
+	#EMULTIHOP
+ 72
+
+	)
+
+78 
+	#EDOTDOT
+ 73
+
+	)
+
+79 
+	#EBADMSG
+ 74
+
+	)
+
+80 
+	#EOVERFLOW
+ 75
+
+	)
+
+81 
+	#ENOTUNIQ
+ 76
+
+	)
+
+82 
+	#EBADFD
+ 77
+
+	)
+
+83 
+	#EREMCHG
+ 78
+
+	)
+
+84 
+	#ELIBACC
+ 79
+
+	)
+
+85 
+	#ELIBBAD
+ 80
+
+	)
+
+86 
+	#ELIBSCN
+ 81
+
+	)
+
+87 
+	#ELIBMAX
+ 82
+
+	)
+
+88 
+	#ELIBEXEC
+ 83
+
+	)
+
+89 
+	#EILSEQ
+ 84
+
+	)
+
+90 
+	#ERESTART
+ 85
+
+	)
+
+91 
+	#ESTRPIPE
+ 86
+
+	)
+
+92 
+	#EUSERS
+ 87
+
+	)
+
+93 
+	#ENOTSOCK
+ 88
+
+	)
+
+94 
+	#EDESTADDRREQ
+ 89
+
+	)
+
+95 
+	#EMSGSIZE
+ 90
+
+	)
+
+96 
+	#EPROTOTYPE
+ 91
+
+	)
+
+97 
+	#ENOPROTOOPT
+ 92
+
+	)
+
+98 
+	#EPROTONOSUPPORT
+ 93
+
+	)
+
+99 
+	#ESOCKTNOSUPPORT
+ 94
+
+	)
+
+100 
+	#EOPNOTSUPP
+ 95
+
+	)
+
+101 
+	#EPFNOSUPPORT
+ 96
+
+	)
+
+102 
+	#EAFNOSUPPORT
+ 97
+
+	)
+
+103 
+	#EADDRINUSE
+ 98
+
+	)
+
+104 
+	#EADDRNOTAVAIL
+ 99
+
+	)
+
+105 
+	#ENETDOWN
+ 100
+
+	)
+
+106 
+	#ENETUNREACH
+ 101
+
+	)
+
+107 
+	#ENETRESET
+ 102
+
+	)
+
+108 
+	#ECONNABORTED
+ 103
+
+	)
+
+109 
+	#ECONNRESET
+ 104
+
+	)
+
+110 
+	#ENOBUFS
+ 105
+
+	)
+
+111 
+	#EISCONN
+ 106
+
+	)
+
+112 
+	#ENOTCONN
+ 107
+
+	)
+
+113 
+	#ESHUTDOWN
+ 108
+
+	)
+
+114 
+	#ETOOMANYREFS
+ 109
+
+	)
+
+115 
+	#ETIMEDOUT
+ 110
+
+	)
+
+116 
+	#ECONNREFUSED
+ 111
+
+	)
+
+117 
+	#EHOSTDOWN
+ 112
+
+	)
+
+118 
+	#EHOSTUNREACH
+ 113
+
+	)
+
+119 
+	#EALREADY
+ 114
+
+	)
+
+120 
+	#EINPROGRESS
+ 115
+
+	)
+
+121 
+	#ESTALE
+ 116
+
+	)
+
+122 
+	#EUCLEAN
+ 117
+
+	)
+
+123 
+	#ENOTNAM
+ 118
+
+	)
+
+124 
+	#ENAVAIL
+ 119
+
+	)
+
+125 
+	#EISNAM
+ 120
+
+	)
+
+126 
+	#EREMOTEIO
+ 121
+
+	)
+
+127 
+	#EDQUOT
+ 122
+
+	)
+
+129 
+	#ENOMEDIUM
+ 123
+
+	)
+
+130 
+	#EMEDIUMTYPE
+ 124
+
+	)
+
+131 
+	#ECANCELED
+ 125
+
+	)
+
+132 
+	#ENOKEY
+ 126
+
+	)
+
+133 
+	#EKEYEXPIRED
+ 127
+
+	)
+
+134 
+	#EKEYREVOKED
+ 128
+
+	)
+
+135 
+	#EKEYREJECTED
+ 129
+
+	)
+
+	@/usr/include/asm/io.h
+
+1 #ide
+_ASM_IO_H
+
+
+2 
+	#_ASM_IO_H
+
+
+	)
+
+4 #wng <
+asm
+/
+io
+.
+h
+> 
+is
+ 
+dd
+, 
+u
+ <
+sys
+/io.h> 
+d
+
+
+5 
+	~<sys/io.h
+>
+
+	@/usr/include/sys/io.h
+
+19 #idef 
+_SYS_IO_H
+
+
+20 
+	#_SYS_IO_H
+ 1
+
+	)
+
+22 
+	~<us.h
+>
+
+24 
+__BEGIN_DECLS
+
+
+33 
+	$im
+ (
+__om
+, 
+__num
+,
+
+34 
+__tu_
+
+__THROW
+;
+
+39 
+	$il
+ (
+__v
+
+__THROW
+;
+
+41 #i
+defed
+ 
+__GNUC__
+ && __GNUC__ >= 2
+
+43 
+__le
+ 
+
+44 
+	$b
+ (
+pt
+)
+
+46 
+_v
+;
+
+48 
+__asm__
+ 
+	`__ve__
+ ("b %w1,%0":"" (
+_v
+):"Nd" (
+pt
+));
+
+49  
+_v
+;
+
+50 
+	}
+}
+
+52 
+__le
+ 
+
+53 
+	$b_p
+ (
+pt
+)
+
+55 
+_v
+;
+
+57 
+__asm__
+ 
+	`__ve__
+ ("b %w1,%0\noutb %%,$0x80":"" (
+_v
+):"Nd" (
+pt
+));
+
+58  
+_v
+;
+
+59 
+	}
+}
+
+61 
+__le
+ 
+
+62 
+	$w
+ (
+pt
+)
+
+64 
+_v
+;
+
+66 
+__asm__
+ 
+	`__ve__
+ ("w %w1,%0":"" (
+_v
+):"Nd" (
+pt
+));
+
+67  
+_v
+;
+
+68 
+	}
+}
+
+70 
+__le
+ 
+
+71 
+	$w_p
+ (
+pt
+)
+
+73 
+_v
+;
+
+75 
+__asm__
+ 
+	`__ve__
+ ("w %w1,%0\noutb %%,$0x80":"" (
+_v
+):"Nd" (
+pt
+));
+
+76  
+_v
+;
+
+77 
+	}
+}
+
+79 
+__le
+ 
+
+80 
+	$l
+ (
+pt
+)
+
+82 
+_v
+;
+
+84 
+__asm__
+ 
+	`__ve__
+ ("%w1,%0":"" (
+_v
+):"Nd" (
+pt
+));
+
+85  
+_v
+;
+
+86 
+	}
+}
+
+88 
+__le
+ 
+
+89 
+	$l_p
+ (
+pt
+)
+
+91 
+_v
+;
+
+92 
+__asm__
+ 
+	`__ve__
+ ("%w1,%0\noutb %%,$0x80":"" (
+_v
+):"Nd" (
+pt
+));
+
+93  
+_v
+;
+
+94 
+	}
+}
+
+96 
+__le
+ 
+
+97 
+	$outb
+ (
+vue
+, 
+pt
+)
+
+99 
+__asm__
+ 
+	`__ve__
+ ("outb %b0,%w1": :"a" (
+vue
+), "Nd" (
+pt
+));
+
+100 
+	}
+}
+
+102 
+__le
+ 
+
+103 
+	$outb_p
+ (
+vue
+, 
+pt
+)
+
+105 
+__asm__
+ 
+	`__ve__
+ ("outb %b0,%w1\noutb %%,$0x80": :"a" (
+vue
+),
+
+106 "Nd" (
+pt
+));
+
+107 
+	}
+}
+
+109 
+__le
+ 
+
+110 
+	$outw
+ (
+vue
+, 
+pt
+)
+
+112 
+__asm__
+ 
+	`__ve__
+ ("outw %w0,%w1": :"a" (
+vue
+), "Nd" (
+pt
+));
+
+114 
+	}
+}
+
+116 
+__le
+ 
+
+117 
+	$outw_p
+ (
+vue
+, 
+pt
+)
+
+119 
+__asm__
+ 
+	`__ve__
+ ("outw %w0,%w1\noutb %%,$0x80": :"a" (
+vue
+),
+
+120 "Nd" (
+pt
+));
+
+121 
+	}
+}
+
+123 
+__le
+ 
+
+124 
+	$ou
+ (
+vue
+, 
+pt
+)
+
+126 
+__asm__
+ 
+	`__ve__
+ ("ou %0,%w1": :"a" (
+vue
+), "Nd" (
+pt
+));
+
+127 
+	}
+}
+
+129 
+__le
+ 
+
+130 
+	$ou_p
+ (
+vue
+, 
+pt
+)
+
+132 
+__asm__
+ 
+	`__ve__
+ ("ou %0,%w1\noutb %%,$0x80": :"a" (
+vue
+),
+
+133 "Nd" (
+pt
+));
+
+134 
+	}
+}
+
+136 
+__le
+ 
+
+137 
+	$sb
+ (
+pt
+, *
+addr
+, 
+cou
+)
+
+139 
+__asm__
+ 
+	`__ve__
+ ("d ; ; insb":"=D" (
+addr
+),
+
+140 "=c" (
+cou
+):"d" (
+pt
+), "0" (
+addr
+), "1" (count));
+
+141 
+	}
+}
+
+143 
+__le
+ 
+
+144 
+	$sw
+ (
+pt
+, *
+addr
+, 
+cou
+)
+
+146 
+__asm__
+ 
+	`__ve__
+ ("d ; ; insw":"=D" (
+addr
+),
+
+147 "=c" (
+cou
+):"d" (
+pt
+), "0" (
+addr
+), "1" (count));
+
+148 
+	}
+}
+
+150 
+__le
+ 
+
+151 
+	$
+ (
+pt
+, *
+addr
+, 
+cou
+)
+
+153 
+__asm__
+ 
+	`__ve__
+ ("d ; ; in":"=D" (
+addr
+),
+
+154 "=c" (
+cou
+):"d" (
+pt
+), "0" (
+addr
+), "1" (count));
+
+155 
+	}
+}
+
+157 
+__le
+ 
+
+158 
+	$outsb
+ (
+pt
+, c *
+addr
+, 
+cou
+)
+
+160 
+__asm__
+ 
+	`__ve__
+ ("d ; ; outsb":"=S" (
+addr
+),
+
+161 "=c" (
+cou
+):"d" (
+pt
+), "0" (
+addr
+), "1" (count));
+
+162 
+	}
+}
+
+164 
+__le
+ 
+
+165 
+	$outsw
+ (
+pt
+, c *
+addr
+, 
+cou
+)
+
+167 
+__asm__
+ 
+	`__ve__
+ ("d ; ; outsw":"=S" (
+addr
+),
+
+168 "=c" (
+cou
+):"d" (
+pt
+), "0" (
+addr
+), "1" (count));
+
+169 
+	}
+}
+
+171 
+__le
+ 
+
+172 
+	$out
+ (
+pt
+, c *
+addr
+, 
+cou
+)
+
+174 
+__asm__
+ 
+	`__ve__
+ ("d ; ; out":"=S" (
+addr
+),
+
+175 "=c" (
+cou
+):"d" (
+pt
+), "0" (
+addr
+), "1" (count));
+
+176 
+	}
+}
+
+180 
+	g__END_DECLS
+
+
+	@/usr/include/features.h
+
+19 #idef 
+_FEATURES_H
+
+
+20 
+	#_FEATURES_H
+ 1
+
+	)
+
+90 #unde
+__USE_ISOC99
+
+
+91 #unde
+__USE_POSIX
+
+
+92 #unde
+__USE_POSIX2
+
+
+93 #unde
+__USE_POSIX199309
+
+
+94 #unde
+__USE_POSIX199506
+
+
+95 #unde
+__USE_XOPEN
+
+
+96 #unde
+__USE_XOPEN_EXTENDED
+
+
+97 #unde
+__USE_UNIX98
+
+
+98 #unde
+__USE_XOPEN2K
+
+
+99 #unde
+__USE_LARGEFILE
+
+
+100 #unde
+__USE_LARGEFILE64
+
+
+101 #unde
+__USE_FILE_OFFSET64
+
+
+102 #unde
+__USE_BSD
+
+
+103 #unde
+__USE_SVID
+
+
+104 #unde
+__USE_MISC
+
+
+105 #unde
+__USE_GNU
+
+
+106 #unde
+__USE_REENTRANT
+
+
+107 #unde
+__USE_FORTIFY_LEVEL
+
+
+108 #unde
+__FAVOR_BSD
+
+
+109 #unde
+__KERNEL_STRICT_NAMES
+
+
+113 #ide
+_LOOSE_KERNEL_NAMES
+
+
+114 
+	#__KERNEL_STRICT_NAMES
+
+
+	)
+
+118 
+	#__USE_ANSI
+ 1
+
+	)
+
+127 #i
+defed
+ 
+__GNUC__
+ && defed 
+__GNUC_MINOR__
+
+
+128 
+	#__GNUC_PREREQ
+(
+maj
+, 
+m
+) \
+
+129 ((
+__GNUC__
+ << 16+ 
+__GNUC_MINOR__
+ >((
+maj
+<< 16+ (
+m
+))
+
+	)
+
+131 
+	#__GNUC_PREREQ
+(
+maj
+, 
+m
+0
+
+	)
+
+136 #i
+defed
+ 
+_BSD_SOURCE
+ && \
+
+137 !(
+defed
+ 
+	g_POSIX_SOURCE
+ || defed 
+	g_POSIX_C_SOURCE
+ || \
+
+138 
+defed
+ 
+	g_XOPEN_SOURCE
+ || defed 
+	g_XOPEN_SOURCE_EXTENDED
+ || \
+
+139 
+defed
+ 
+	g_GNU_SOURCE
+ || defed 
+	g_SVID_SOURCE
+)
+
+140 
+	#__FAVOR_BSD
+ 1
+
+	)
+
+144 #ifde
+_GNU_SOURCE
+
+
+145 #unde
+_ISOC99_SOURCE
+
+
+146 
+	#_ISOC99_SOURCE
+ 1
+
+	)
+
+147 #unde
+_POSIX_SOURCE
+
+
+148 
+	#_POSIX_SOURCE
+ 1
+
+	)
+
+149 #unde
+_POSIX_C_SOURCE
+
+
+150 
+	#_POSIX_C_SOURCE
+ 199506L
+
+	)
+
+151 #unde
+_XOPEN_SOURCE
+
+
+152 
+	#_XOPEN_SOURCE
+ 600
+
+	)
+
+153 #unde
+_XOPEN_SOURCE_EXTENDED
+
+
+154 
+	#_XOPEN_SOURCE_EXTENDED
+ 1
+
+	)
+
+155 #unde
+_LARGEFILE64_SOURCE
+
+
+156 
+	#_LARGEFILE64_SOURCE
+ 1
+
+	)
+
+157 #unde
+_BSD_SOURCE
+
+
+158 
+	#_BSD_SOURCE
+ 1
+
+	)
+
+159 #unde
+_SVID_SOURCE
+
+
+160 
+	#_SVID_SOURCE
+ 1
+
+	)
+
+165 #i(!
+defed
+ 
+__STRICT_ANSI__
+ && !defed 
+_ISOC99_SOURCE
+ && \
+
+166 !
+defed
+ 
+	g_POSIX_SOURCE
+ && !defed 
+	g_POSIX_C_SOURCE
+ && \
+
+167 !
+defed
+ 
+	g_XOPEN_SOURCE
+ && !defed 
+	g_XOPEN_SOURCE_EXTENDED
+ && \
+
+168 !
+defed
+ 
+	g_BSD_SOURCE
+ && !defed 
+	g_SVID_SOURCE
+)
+
+169 
+	#_BSD_SOURCE
+ 1
+
+	)
+
+170 
+	#_SVID_SOURCE
+ 1
+
+	)
+
+177 #i(
+defed
+ 
+_ISOC99_SOURCE
+ || defed 
+_ISOC9X_SOURCE
+ \
+
+178 || (
+defed
+ 
+	g__STDC_VERSION__
+ && __STDC_VERSION__ >= 199901L))
+
+179 
+	#__USE_ISOC99
+ 1
+
+	)
+
+184 #i((!
+defed
+ 
+__STRICT_ANSI__
+ || (
+_XOPEN_SOURCE
+ - 0) >= 500) && \
+
+185 !
+defed
+ 
+_POSIX_SOURCE
+ && !defed 
+_POSIX_C_SOURCE
+)
+
+186 
+	#_POSIX_SOURCE
+ 1
+
+	)
+
+187 #i
+defed
+ 
+_XOPEN_SOURCE
+ && (_XOPEN_SOURCE - 0) < 500
+
+188 
+	#_POSIX_C_SOURCE
+ 2
+
+	)
+
+190 
+	#_POSIX_C_SOURCE
+ 199506L
+
+	)
+
+194 #i
+defed
+ 
+_POSIX_SOURCE
+ || 
+_POSIX_C_SOURCE
+ >1 || defed 
+_XOPEN_SOURCE
+
+
+195 
+	#__USE_POSIX
+ 1
+
+	)
+
+198 #i
+defed
+ 
+_POSIX_C_SOURCE
+ && _POSIX_C_SOURCE >2 || defed 
+_XOPEN_SOURCE
+
+
+199 
+	#__USE_POSIX2
+ 1
+
+	)
+
+202 #i(
+_POSIX_C_SOURCE
+ - 0) >= 199309L
+
+203 
+	#__USE_POSIX199309
+ 1
+
+	)
+
+206 #i(
+_POSIX_C_SOURCE
+ - 0) >= 199506L
+
+207 
+	#__USE_POSIX199506
+ 1
+
+	)
+
+210 #i(
+_POSIX_C_SOURCE
+ - 0) >= 200112L
+
+211 
+	#__USE_XOPEN2K
+ 1
+
+	)
+
+214 #ifdef 
+_XOPEN_SOURCE
+
+
+215 
+	#__USE_XOPEN
+ 1
+
+	)
+
+216 #i(
+_XOPEN_SOURCE
+ - 0) >= 500
+
+217 
+	#__USE_XOPEN_EXTENDED
+ 1
+
+	)
+
+218 
+	#__USE_UNIX98
+ 1
+
+	)
+
+219 #unde
+_LARGEFILE_SOURCE
+
+
+220 
+	#_LARGEFILE_SOURCE
+ 1
+
+	)
+
+221 #i(
+_XOPEN_SOURCE
+ - 0) >= 600
+
+222 
+	#__USE_XOPEN2K
+ 1
+
+	)
+
+223 #unde
+__USE_ISOC99
+
+
+224 
+	#__USE_ISOC99
+ 1
+
+	)
+
+227 #ifde
+_XOPEN_SOURCE_EXTENDED
+
+
+228 
+	#__USE_XOPEN_EXTENDED
+ 1
+
+	)
+
+233 #ifde
+_LARGEFILE_SOURCE
+
+
+234 
+	#__USE_LARGEFILE
+ 1
+
+	)
+
+237 #ifde
+_LARGEFILE64_SOURCE
+
+
+238 
+	#__USE_LARGEFILE64
+ 1
+
+	)
+
+241 #i
+defed
+ 
+_FILE_OFFSET_BITS
+ && _FILE_OFFSET_BITS == 64
+
+242 
+	#__USE_FILE_OFFSET64
+ 1
+
+	)
+
+245 #i
+defed
+ 
+_BSD_SOURCE
+ || defed 
+_SVID_SOURCE
+
+
+246 
+	#__USE_MISC
+ 1
+
+	)
+
+249 #ifdef 
+_BSD_SOURCE
+
+
+250 
+	#__USE_BSD
+ 1
+
+	)
+
+253 #ifdef 
+_SVID_SOURCE
+
+
+254 
+	#__USE_SVID
+ 1
+
+	)
+
+257 #ifdef 
+_GNU_SOURCE
+
+
+258 
+	#__USE_GNU
+ 1
+
+	)
+
+261 #i
+defed
+ 
+_REENTRANT
+ || defed 
+_THREAD_SAFE
+
+
+262 
+	#__USE_REENTRANT
+ 1
+
+	)
+
+265 #i
+defed
+ 
+_FORTIFY_SOURCE
+ && defed 
+__OPTIMIZE__
+ \
+
+266 && 
+_FORTIFY_SOURCE
+ > 0 && 
+__OPTIMIZE__
+ > 0 \
+
+267 && (
+__GNUC_PREREQ
+ (4, 1) \
+
+268 || (
+defed
+ 
+	g__GNUC_RH_RELEASE__
+ && 
+__GNUC_PREREQ
+ (4, 0)) \
+
+269 || (
+defed
+ 
+	g__GNUC_RH_RELEASE__
+ && 
+__GNUC_PREREQ
+ (3, 4) \
+
+270 && 
+	g__GNUC_MINOR__
+ == 4 \
+
+271 && (
+__GNUC_PATCHLEVEL__
+ > 2 \
+
+272 || (
+__GNUC_PATCHLEVEL__
+ == 2 \
+
+273 && 
+defed
+ 
+__GNUC_RH_RELEASE__
+ \
+
+274 && 
+__GNUC_RH_RELEASE__
+ >= 8))))
+
+275 #i
+_FORTIFY_SOURCE
+ > 1
+
+276 
+	#__USE_FORTIFY_LEVEL
+ 2
+
+	)
+
+278 
+	#__USE_FORTIFY_LEVEL
+ 1
+
+	)
+
+281 
+	#__USE_FORTIFY_LEVEL
+ 0
+
+	)
+
+285 
+	#__STDC_IEC_559__
+ 1
+
+	)
+
+286 
+	#__STDC_IEC_559_COMPLEX__
+ 1
+
+	)
+
+289 
+	#__STDC_ISO_10646__
+ 200009L
+
+	)
+
+297 #unde
+__GNU_LIBRARY__
+
+
+298 
+	#__GNU_LIBRARY__
+ 6
+
+	)
+
+302 
+	#__GLIBC__
+ 2
+
+	)
+
+303 
+	#__GLIBC_MINOR__
+ 3
+
+	)
+
+305 
+	#__GLIBC_PREREQ
+(
+maj
+, 
+m
+) \
+
+306 ((
+__GLIBC__
+ << 16+ 
+__GLIBC_MINOR__
+ >((
+maj
+<< 16+ (
+m
+))
+
+	)
+
+309 #i
+defed
+ 
+__GNUC__
+ \
+
+310 || (
+defed
+ 
+	g__PGI
+ && defed 
+	g__i386__
+ ) \
+
+311 || (
+defed
+ 
+	g__INTEL_COMPILER
+ && (defed 
+	g__i386__
+ || defed 
+	g__64__
+)) \
+
+312 || (
+defed
+ 
+	g__STDC_VERSION__
+ && __STDC_VERSION__ >= 199901L)
+
+313 
+	#__GLIBC_HAVE_LONG_LONG
+ 1
+
+	)
+
+317 #ide
+__ASSEMBLER__
+
+
+318 #ide
+_SYS_CDEFS_H
+
+
+319 
+	~<sys/cdefs.h
+>
+
+324 #i
+defed
+ 
+__USE_FILE_OFFSET64
+ && !defed 
+__REDIRECT
+
+
+325 
+	#__USE_LARGEFILE
+ 1
+
+	)
+
+326 
+	#__USE_LARGEFILE64
+ 1
+
+	)
+
+332 #i
+__GNUC_PREREQ
+ (2, 7&& 
+defed
+ 
+__OPTIMIZE__
+ \
+
+333 && !
+defed
+ 
+	g__OPTIMIZE_SIZE__
+ && !defed 
+	g__NO_INLINE__
+
+
+334 
+	#__USE_EXTERN_INLINES
+ 1
+
+	)
+
+342 
+	~<gnu/ubs.h
+>
+
+	@/usr/include/gnu/stubs.h
+
+6 #ifde
+_LIBC
+
+
+7 #r 
+Alitis
+ 
+may
+ 
+n
+ 
+defe
+ 
+the
+ 
+mao
+ 
+_LIBC
+
+
+10 
+	#__ub___kl_co
+
+
+	)
+
+11 
+	#__ub___kl_sl
+
+
+	)
+
+12 
+	#__ub___kl_
+
+
+	)
+
+13 
+	#__ub_chags
+
+
+	)
+
+14 
+	#__ub_ach
+
+
+	)
+
+15 
+	#__ub_fchags
+
+
+	)
+
+16 
+	#__ub_fdach
+
+
+	)
+
+17 
+	#__ub_gy
+
+
+	)
+
+18 
+	#__ub_lchmod
+
+
+	)
+
+19 
+	#__ub_lutimes
+
+
+	)
+
+20 
+	#__ub_voke
+
+
+	)
+
+21 
+	#__ub_og
+
+
+	)
+
+22 
+	#__ub_sk
+
+
+	)
+
+23 
+	#__ub_ty
+
+
+	)
+
+	@/usr/include/sys/cdefs.h
+
+19 #idef 
+_SYS_CDEFS_H
+
+
+20 
+	#_SYS_CDEFS_H
+ 1
+
+	)
+
+23 #ide
+_FEATURES_H
+
+
+24 
+	~<us.h
+>
+
+30 #i
+defed
+ 
+__GNUC__
+ && !defed 
+__STDC__
+
+
+35 #unde
+__P
+
+
+36 #unde
+__PMT
+
+
+38 #ifde
+__GNUC__
+
+
+45 #i!
+defed
+ 
+__lulus
+ && 
+__GNUC_PREREQ
+ (3, 3)
+
+46 
+	#__THROW
+ 
+	`__ibu__
+ ((
+__nhrow__
+))
+
+	)
+
+47 
+	#__NTH
+(
+f
+
+	`__ibu__
+ ((
+__nhrow__
+)
+	)
+fct
+
+49 #i
+defed
+ 
+__lulus
+ && 
+__GNUC_PREREQ
+ (2,8)
+
+50 
+	#__THROW
+ 
+	`throw
+ ()
+
+	)
+
+51 
+	#__NTH
+(
+f
+f 
+	`throw
+ ()
+
+	)
+
+53 
+	#__THROW
+
+
+	)
+
+54 
+	#__NTH
+(
+f
+
+	)
+fct
+
+60 
+	#__le
+
+
+	)
+
+62 
+	#__THROW
+
+
+	)
+
+63 
+	#__NTH
+(
+f
+
+	)
+fct
+
+65 
+	#__c
+ c
+
+	)
+
+66 
+	#__sigd
+ sigd
+
+	)
+
+67 
+	#__ve
+ ve
+
+	)
+
+73 
+	#__P
+(
+gs
+
+	)
+args
+
+74 
+	#__PMT
+(
+gs
+
+	)
+args
+
+79 
+	#__CONCAT
+(
+x
+,
+y
+x ## 
+	)
+y
+
+80 
+	#__STRING
+(
+x
+#x
+
+	)
+
+83 
+	#__r_t
+ *
+
+	)
+
+84 
+	#__lg_doub_t
+ 
+
+	)
+
+88 #ifdef 
+__lulus
+
+
+89 
+	#__BEGIN_DECLS
+ "C" {
+
+	)
+
+90 
+	#__END_DECLS
+ }
+
+	)
+
+92 
+	#__BEGIN_DECLS
+
+
+	)
+
+93 
+	#__END_DECLS
+
+
+	)
+
+102 #i
+defed
+ 
+__lulus
+ && defed 
+_GLIBCPP_USE_NAMESPACES
+
+
+103 
+	#__BEGIN_NAMESPACE_STD
+ 
+mea
+ 
+d
+ {
+
+	)
+
+104 
+	#__END_NAMESPACE_STD
+ }
+
+	)
+
+105 
+	#__USING_NAMESPACE_STD
+(
+me
+
+usg
+ 
+d
+::me;
+
+	)
+
+106 
+	#__BEGIN_NAMESPACE_C99
+ 
+mea
+ 
+__c99
+ {
+
+	)
+
+107 
+	#__END_NAMESPACE_C99
+ }
+
+	)
+
+108 
+	#__USING_NAMESPACE_C99
+(
+me
+
+usg
+ 
+__c99
+::me;
+
+	)
+
+113 
+	#__BEGIN_NAMESPACE_STD
+
+
+	)
+
+114 
+	#__END_NAMESPACE_STD
+
+
+	)
+
+115 
+	#__USING_NAMESPACE_STD
+(
+me
+)
+
+	)
+
+116 
+	#__BEGIN_NAMESPACE_C99
+
+
+	)
+
+117 
+	#__END_NAMESPACE_C99
+
+
+	)
+
+118 
+	#__USING_NAMESPACE_C99
+(
+me
+)
+
+	)
+
+123 #ide
+__BOUNDED_POINTERS__
+
+
+124 
+	#__bounded
+
+
+	)
+
+125 
+	#__unbounded
+
+
+	)
+
+126 
+	#__rvue
+
+
+	)
+
+131 
+	#__bos
+(
+r
+
+	`__but_obje_size
+ (r, 
+__USE_FORTIFY_LEVEL
+ > 1)
+
+	)
+
+132 
+	#__bos0
+(
+r
+
+	`__but_obje_size
+ (r, 0)
+
+	)
+
+136 #i
+__GNUC_PREREQ
+ (2,97)
+
+138 
+	#__exr
+ []
+
+	)
+
+140 #ifde
+__GNUC__
+
+
+141 
+	#__exr
+ [0]
+
+	)
+
+143 #i
+defed
+ 
+__STDC_VERSION__
+ && __STDC_VERSION__ >= 199901L
+
+144 
+	#__exr
+ []
+
+	)
+
+147 
+	#__exr
+ [1]
+
+	)
+
+163 #i
+defed
+ 
+__GNUC__
+ && __GNUC__ >= 2
+
+165 
+	#__REDIRECT
+(
+me
+, 
+o
+, 
+s
+m
+	`__asm__
+ (
+	`__ASMNAME
+ (#s))
+
+	)
+
+166 #ifde
+__lulus
+
+
+167 
+	#__REDIRECT_NTH
+(
+me
+, 
+o
+, 
+s
+) \
+
+168 
+me
+ 
+o
+ 
+__THROW
+ 
+	`__asm__
+ (
+	`__ASMNAME
+ (#s))
+
+	)
+
+170 
+	#__REDIRECT_NTH
+(
+me
+, 
+o
+, 
+s
+) \
+
+171 
+me
+ 
+o
+ 
+	`__asm__
+ (
+	`__ASMNAME
+ (#s)
+__THROW
+
+
+	)
+
+173 
+	#__ASMNAME
+(
+ame
+
+	`__ASMNAME2
+ (
+__USER_LABEL_PREFIX__
+, cme)
+
+	)
+
+174 
+	#__ASMNAME2
+(
+efix
+, 
+ame
+
+	`__STRING
+ (efix
+	)
+cname
+
+187 #i!
+defed
+ 
+__GNUC__
+ || __GNUC__ < 2
+
+188 
+	#__ibu__
+(
+xyz
+
+
+	)
+
+194 #i
+__GNUC_PREREQ
+ (2,96)
+
+195 
+	#__ibu_mloc__
+ 
+	`__ibu__
+ ((
+__mloc__
+))
+
+	)
+
+197 
+	#__ibu_mloc__
+
+
+	)
+
+203 #i
+__GNUC_PREREQ
+ (2,96)
+
+204 
+	#__ibu_pu__
+ 
+	`__ibu__
+ ((
+__pu__
+))
+
+	)
+
+206 
+	#__ibu_pu__
+
+
+	)
+
+212 #i
+__GNUC_PREREQ
+ (3,1)
+
+213 
+	#__ibu_ud__
+ 
+	`__ibu__
+ ((
+__ud__
+))
+
+	)
+
+214 
+	#__ibu_nole__
+ 
+	`__ibu__
+ ((
+__nole__
+))
+
+	)
+
+216 
+	#__ibu_ud__
+ 
+	`__ibu__
+ ((
+__unud__
+))
+
+	)
+
+217 
+	#__ibu_nole__
+
+
+	)
+
+221 #i
+__GNUC_PREREQ
+ (3,2)
+
+222 
+	#__ibu_dd__
+ 
+	`__ibu__
+ ((
+__dd__
+))
+
+	)
+
+224 
+	#__ibu_dd__
+
+
+	)
+
+233 #i
+__GNUC_PREREQ
+ (2,8)
+
+234 
+	#__ibu_fm_g__
+(
+x
+
+	`__ibu__
+ ((
+	`__fm_g__
+ (x)))
+
+	)
+
+236 
+	#__ibu_fm_g__
+(
+x
+
+
+	)
+
+243 #i
+__GNUC_PREREQ
+ (2,97)
+
+244 
+	#__ibu_fm_rfm__
+(
+a
+,
+b
+) \
+
+245 
+	`__ibu__
+ ((
+	`__fm__
+ (
+__rfm__
+, 
+a
+, 
+b
+)))
+
+	)
+
+247 
+	#__ibu_fm_rfm__
+(
+a
+,
+b
+
+
+	)
+
+252 #i
+__GNUC_PREREQ
+ (3,3)
+
+253 
+	#__nnu
+(
+ms
+
+	`__ibu__
+ ((
+__nnu__
+ams))
+
+	)
+
+255 
+	#__nnu
+(
+ms
+)
+
+	)
+
+262 #i!
+__GNUC_PREREQ
+ (2,8)
+
+263 
+	#__exnsi__
+
+
+	)
+
+267 #i!
+__GNUC_PREREQ
+ (2,92)
+
+268 
+	#__ri
+
+
+	)
+
+274 #i
+__GNUC_PREREQ
+ (3,1&& !
+defed
+ 
+__GNUG__
+
+
+275 
+	#__ri_r
+ 
+__ri
+
+
+	)
+
+277 #ifde
+__GNUC__
+
+
+278 
+	#__ri_r
+
+
+	)
+
+280 #i
+defed
+ 
+__STDC_VERSION__
+ && __STDC_VERSION__ >= 199901L
+
+281 
+	#__ri_r
+ 
+ri
+
+
+	)
+
+284 
+	#__ri_r
+
+
+	)
+
+	@
+1
+.
+1
+/usr/include
+8
+161
+nand.c
+smdk2416.c
+/usr/include/asm/errno.h
+/usr/include/asm/io.h
+/usr/include/sys/io.h
+/usr/include/features.h
+/usr/include/gnu/stubs.h
+/usr/include/sys/cdefs.h
Binary files u-boot-2010.09-orig/board/samsung/smdk2416/cscope.po.out and u-boot-2010.09-smdk2416/board/samsung/smdk2416/cscope.po.out differ
diff -NBbur u-boot-2010.09-orig/board/samsung/smdk2416/lowlevel_init.S u-boot-2010.09-smdk2416/board/samsung/smdk2416/lowlevel_init.S
--- u-boot-2010.09-orig/board/samsung/smdk2416/lowlevel_init.S	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/board/samsung/smdk2416/lowlevel_init.S	2011-09-01 16:17:36.000000000 +0800
@@ -0,0 +1,292 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2416 by
+ * (C) Copyright 2008 Samsung Electronics
+ * Seungchull, Suh <sc.suh@samsung.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+#include <asm/arch/s3c2416.h>
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+	.globl lowlevel_init
+lowlevel_init:
+	mov	r12, lr
+
+	/* LED on to show U-Boot code is running */
+
+	ldr	r0, =ELFIN_GPIO_BASE
+	ldr	r2, [r0, #GPCCON_OFFSET]
+	bic	r2, #3
+	orr	r1, r2, #1
+	str	r1, [r0, #GPCCON_OFFSET]
+
+	ldr	r2, [r0, #GPCDAT_OFFSET]
+	bic	r2, #1
+	orr	r1, r2, #1
+	str	r1, [r0, #GPCDAT_OFFSET]
+
+	/* Disable Watchdog */
+	ldr	r0, =ELFIN_WATCHDOG_BASE
+	mov	r1, #0
+	str	r1, [r0]
+
+	/* Disable main and sub interrupts */
+	ldr	r0, =ELFIN_INTERRUPT_BASE
+	mvn	r1, #0x0
+	str	r1, [r0, #INTMSK_OFFSET]
+	str	r1, [r0, #INTSUBMSK_OFFSET]
+
+	/* Set all interrupts as IRQ */
+	mov	r1, #0x0
+	str	r1, [r0, #INTMOD_OFFSET]
+
+	/* init system clock */
+	bl system_clock_init
+
+	/* for UART */
+	bl uart_asm_init
+
+	/* simple init for NAND */
+	bl nand_asm_init
+
+	/* when we already run in ram, we don't need to relocate U-Boot.
+	 * and actually, memory controller must be configured before U-Boot
+	 * is running in ram.
+	 */
+	ldr	r0, =0xff000fff
+	bic	r1, pc, r0		/* r0 <- current base addr of code */
+	ldr	r2, _TEXT_BASE		/* r1 <- original base addr in ram */
+	bic	r2, r2, r0		/* r0 <- current base addr of code */
+	cmp     r1, r2                  /* compare r0, r1                  */
+	beq     1f			/* r0 == r1 then skip sdram init   */
+
+	adr     r0, sdram_bank_set_val
+	bl sdr_ctrl_asm_init
+
+1:	ldr	r0, =ELFIN_UART_BASE
+	ldr	r1, =0x4b4b4b4b
+	str	r1, [r0, #0x20]
+
+#ifdef CONFIG_PM
+	/* PM check */
+	@ Check if this is a wake-up from sleep
+        ldr     r0, =INFORM0_REG	/* INFORM0 register */
+        ldr     r1, [r0]
+        ldr     r2, =0x2BED
+        cmp     r2, r1
+
+	ldreq 	r0, =INFORM1_REG	/* INFORM1 register */
+        ldreq 	r1, [r0]
+        moveq 	pc, r1 			 /* end PM check */
+#endif
+
+	mov	pc, r12
+
+/*
+ * system_clock_init: Initialize core clock and bus clock.
+ * void system_clock_init(void)
+ */
+system_clock_init:
+
+	ldr	r0, =ELFIN_CLOCK_POWER_BASE
+
+	ldr	r1, [r0, #CLKDIV0CON_OFFSET]
+	bic	r1, r1, #0x37	/* clear HCLKDIV, PREDIV, PCLKDIV */
+	bic	r1, r1, #(0xf<<9) /* clear ARMCLKDIV */
+	ldr	r2, =CLK_DIV_VAL
+	orr	r1, r1, r2
+	str	r1, [r0, #CLKDIV0CON_OFFSET]
+
+	/*Set MPLL Locktime*/
+	ldr	r1, =0xe10
+	str	r1, [r0, #LOCKCON0_OFFSET]
+
+	ldr	r1, =MPLL_VAL
+	str	r1, [r0, #MPLLCON_OFFSET]
+
+#if 1
+	ldr	r1, =0x1780
+	str	r1, [r0, #LOCKCON1_OFFSET]
+
+	ldr	r1, =EPLL_VAL		/*Set EPLL*/
+	str	r1, [r0, #EPLLCON_OFFSET]
+
+	ldr	r1, [r0, #CLKSRCCON_OFFSET]
+	orr	r1, r1, #0x40
+	str	r1, [r0, #CLKSRCCON_OFFSET]
+
+#endif
+
+	/* set CLKSRC to fit MPLL and USB */
+	ldr	r1, [r0, #CLKSRCCON_OFFSET]
+	orr	r1, r1, #0x10
+	str	r1, [r0, #CLKSRCCON_OFFSET]
+
+#if 0
+	/* wait at least 200us to stablize all clock */
+	mov	r2, #0x10000
+1:	subs	r1, r1, #1
+	bne	1b
+#endif
+
+	mrc	p15, 0, r0, c1, c0, 0
+	orr	r0, r0, #0xc0000000	/* clock setting in MMU */
+	mcr	p15, 0, r0, c1, c0, 0
+
+	mov	pc, lr
+
+/*
+ * uart_asm_init: Initialize UART in asm mode, 115200bps fixed.
+ * void uart_asm_init(void)
+ */
+uart_asm_init:
+	/* set GPIO to enable UART */
+	ldr	r0, =ELFIN_GPIO_BASE
+	ldr	r1, =0x0000aaaa
+	str	r1, [r0, #GPHCON_OFFSET]    @GPIO
+
+	ldr	r0, =ELFIN_UART_BASE
+	mov	r1, #0x0
+	str	r1, [r0, #UFCON_OFFSET]
+	str	r1, [r0, #UMCON_OFFSET]
+
+	mov	r1, #0x3                     @was 0.
+	str	r1, [r0, #ULCON_OFFSET]
+
+	ldr	r1, =0x245
+	str	r1, [r0, #UCON_OFFSET]
+
+	ldr 	r1, =0x3
+
+	ldr	r1, =0x23			/* PCLK Is Fixed to 66Mhz */
+	str	r1, [r0, #UBRDIV_OFFSET]
+
+	ldr	r1, =0x0888
+	str	r1, [r0, #UDIVSLOT_OFFSET]
+
+	ldr	r1, =0x4f4f4f4f
+	str	r1, [r0, #UTXH_OFFSET]
+
+	mov	pc, lr
+
+/*
+ * Nand Interface Init for smdk2416
+ */
+
+nand_asm_init:
+	ldr	r0, =ELFIN_GPIO_BASE
+	ldr	r1, [r0]
+	orr	r1, r1, #(0x3f<<17)
+	str     r1, [r0]
+	/* EVT1 has modification in NAND */
+#if 1
+	ldr	r1, =0x1aa8a
+	str     r1, [r0, #GPADAT_OFFSET]
+#endif
+
+	ldr	r0, =ELFIN_NAND_BASE
+	ldr	r1, [r0, #NFCONF_OFFSET]
+	orr	r1, r1, #0x70
+	orr	r1, r1, #0x7700
+	str     r1, [r0, #NFCONF_OFFSET]
+
+	ldr	r1, [r0, #NFCONT_OFFSET]
+	orr	r1, r1, #0x03
+	str     r1, [r0, #NFCONT_OFFSET]
+
+	mov	pc, lr
+
+	.ltorg
+/*
+ * struct sdram_val {
+ *	ulong bankcfg_val;	r5, val of bankcfg
+ *	ulong bankcon1_val;	r6, val of bankcon1
+ *	ulong bankcon2_val;	r7, val of bankcon2
+ *	ulong bankcon3_val;	r8, val of bankcon3
+ *	ulong refresh_val;	r9, val of refresh
+ * }
+ */
+
+sdram_bank_set_val:
+	.word	CFG_BANK_CFG_VAL
+	.word	CFG_BANK_CON1_VAL
+	.word	CFG_BANK_CON2_VAL
+	.word	CFG_BANK_CON3_VAL
+	.word	CFG_BANK_REFRESH_VAL
+
+sdram_bank_sel_val_alt:
+	.word	CFG_BANK_CFG_VAL_ALT
+	.word	CFG_BANK_CON1_VAL_ALT
+
+#ifdef CONFIG_ENABLE_MMU
+
+/*
+ * MMU Table for SMDK2416
+ */
+
+#ifndef CONFIG_BUILD_MMU_TABLE_RUNTIME
+	/* form a first-level section entry */
+.macro FL_SECTION_ENTRY base,ap,d,c,b
+	.word (\base << 20) | (\ap << 10) | \
+	      (\d << 5) | (1<<4) | (\c << 3) | (\b << 2) | (1<<1)
+.endm
+.section .mmudata, "a"
+	.align 14
+	/* the following alignment creates the mmu table at address 0x4000. */
+	.globl mmu_table
+mmu_table:
+	.set __base,0
+	/* 1:1 mapping for debugging */
+	.rept 0x600
+	FL_SECTION_ENTRY __base,3,0,0,0
+	.set __base,__base+1
+	.endr
+
+	/* access is not allowed. */
+	.rept 0xC00 - 0x600
+	.word 0x00000000
+	.endr
+
+	/* 64MB for SDRAM 0xC0000000 -> 0x30000000 */
+	.set __base, 0x300
+	.rept 0xC40 - 0xC00
+	FL_SECTION_ENTRY __base,3,0,1,1
+	.set __base,__base+1
+	.endr
+
+	/* access is not allowed. */
+	.rept 0x1000 - 0xc40
+	.word 0x00000000
+	.endr
+#endif
+
+#endif
+
diff -NBbur u-boot-2010.09-orig/board/samsung/smdk2416/Makefile u-boot-2010.09-smdk2416/board/samsung/smdk2416/Makefile
--- u-boot-2010.09-orig/board/samsung/smdk2416/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/board/samsung/smdk2416/Makefile	2011-09-01 15:35:48.000000000 +0800
@@ -0,0 +1,55 @@
+#
+# (C) Copyright 2000-2006
+# scsuh, Samsung Electronics, sc.suh@samsung.com
+#
+# Derived from Makefiles made by
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= smdk2416.o
+COBJS   += nand_s3c24xx.o serial_s3c24xx.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -NBbur u-boot-2010.09-orig/board/samsung/smdk2416/nand_s3c24xx.c u-boot-2010.09-smdk2416/board/samsung/smdk2416/nand_s3c24xx.c
--- u-boot-2010.09-orig/board/samsung/smdk2416/nand_s3c24xx.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/board/samsung/smdk2416/nand_s3c24xx.c	2011-09-01 16:16:12.000000000 +0800
@@ -0,0 +1,909 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#if defined(CONFIG_CMD_NAND)
+#include <nand.h>
+#include <asm/arch/s3c2416.h>
+
+#include <asm/io.h>
+#include <asm/errno.h>
+
+/* When NAND is used as boot device, below is set to 1. */
+int boot_nand = 0;
+
+/* Nand flash definition values by jsgood */
+#define S3C_NAND_TYPE_UNKNOWN	0x0
+#define S3C_NAND_TYPE_SLC	0x1
+#define S3C_NAND_TYPE_MLC	0x2
+#undef	S3C_NAND_DEBUG
+
+/* Nand flash global values by jsgood */
+int cur_ecc_mode = 0;
+int nand_type = S3C_NAND_TYPE_UNKNOWN;
+
+/* Nand flash oob definition for SLC 512b page size by jsgood */
+static struct nand_ecclayout s3c_nand_oob_16 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,	/* Only for U-Boot */
+	.eccbytes = 4,
+	.eccpos = {1, 2, 3, 4},
+	.oobfree = {
+		{.offset = 6,
+		 . length = 10}}
+};
+
+/* Nand flash oob definition for SLC 2k page size by jsgood */
+static struct nand_ecclayout s3c_nand_oob_64 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,	/* Only for U-Boot */
+	.eccbytes = 16,
+	.eccpos = {40, 41, 42, 43, 44, 45, 46, 47,
+		   48, 49, 50, 51, 52, 53, 54, 55},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 38}}
+};
+
+/* Nand flash oob definition for MLC 2k page size by jsgood */
+static struct nand_ecclayout s3c_nand_oob_mlc_64 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,	/* Only for U-Boot */
+	.eccbytes = 32,
+	.eccpos = {
+		   32, 33, 34, 35, 36, 37, 38, 39,
+		   40, 41, 42, 43, 44, 45, 46, 47,
+ 		   48, 49, 50, 51, 52, 53, 54, 55,
+   		   56, 57, 58, 59, 60, 61, 62, 63},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 28}}
+};
+
+#if defined(S3C_NAND_DEBUG)
+/*
+ * Function to print out oob buffer for debugging
+ * Written by jsgood
+ */
+static void print_oob(const char *header, struct mtd_info *mtd)
+{
+	int i;
+	struct nand_chip *chip = mtd->priv;
+
+	printk("%s:\t", header);
+
+	for(i = 0; i < 64; i++)
+		printk("%02x ", chip->oob_poi[i]);
+
+	printk("\n");
+}
+#endif
+
+/*
+ * Hardware specific access to control-lines function
+ * Written by jsgood
+ */
+static void s3c_nand_hwcontrol(struct mtd_info *mtd, int dat, unsigned int ctrl)
+{
+	unsigned int cur;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		if (ctrl & NAND_NCE) {
+			if (dat != NAND_CMD_NONE) {
+				cur = readl(NFCONT);
+				
+				if (boot_nand)
+					cur &= ~NFCONT_CS;
+				else
+					cur &= ~NFCONT_CS_ALT;
+
+				writel(cur, NFCONT);
+			}
+		} else {
+			cur = readl(NFCONT);
+			
+			if (boot_nand)
+				cur |= NFCONT_CS;
+			else
+				cur |= NFCONT_CS_ALT;
+
+			writel(cur, NFCONT);
+		}
+	}
+
+	if (dat != NAND_CMD_NONE) {
+		if (ctrl & NAND_CLE)
+			writeb(dat, NFCMMD);
+		else if (ctrl & NAND_ALE)
+			writeb(dat, NFADDR);
+	}
+}
+
+/*
+ * Function for checking device ready pin
+ * Written by jsgood
+ */
+static int s3c_nand_device_ready(struct mtd_info *mtdinfo)
+{
+	while (!(readl(NFSTAT) & NFSTAT_RnB)) {}
+	return 1;
+}
+
+/*
+ * We don't use bad block table
+ */
+static int s3c_nand_scan_bbt(struct mtd_info *mtdinfo)
+{
+	return nand_default_bbt(mtdinfo);
+}
+
+#if defined(CFG_NAND_HWECC)
+#if 0
+/*
+ * S3C Nand flash chip enable function
+ * Written by jsgood
+ */
+static void s3c_nand_ce_on(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	chip->cmd_ctrl(mtd, 0x0, NAND_NCE | NAND_CTRL_CHANGE);
+	nand_wait_ready(mtd);
+}
+
+/*
+ * S3C Nand flash chip disable function
+ * Written by jsgood
+ */
+static void s3c_nand_ce_off(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_CTRL_CHANGE);
+	nand_wait_ready(mtd);
+}
+#endif
+
+/*
+ * Function for checking ECCEncDone in NFSTAT
+ * Written by jsgood
+ */
+static void s3c_nand_wait_enc(void)
+{
+	/* S3C2412 can not check NFSTAT_ECCENCDONE */
+#if defined(CONFIG_S3C2450) || defined(CONFIG_S3C2416) || defined(CONFIG_S3C2443)
+	while (!(readl(NFSTAT) & NFSTAT_ECCENCDONE)) {}
+#else
+	return;
+#endif
+}
+
+/*
+ * Function for checking ECCDecDone in NFSTAT
+ * Written by jsgood
+ */
+static void s3c_nand_wait_dec(void)
+{
+#if defined(CONFIG_S3C2450) || defined(CONFIG_S3C2416) || defined(CONFIG_S3C2443) || defined(CONFIG_S3C2412)
+	while (!(readl(NFSTAT) & NFSTAT_ECCDECDONE)) {}
+#else
+	return;
+#endif
+}
+
+/*
+ * Function for checking ECC Busy
+ * Written by jsgood
+ */
+static void s3c_nand_wait_ecc_busy(void)
+{
+#if defined(CONFIG_S3C2450) || defined(CONFIG_S3C2416) || defined(CONFIG_S3C2443) || defined(CONFIG_S3C2412)
+	while (readl(NFESTAT0) & NFESTAT0_ECCBUSY) {}
+#endif
+}
+
+/*
+ * This function is called before encoding ecc codes to ready ecc engine.
+ * Written by jsgood
+ */
+static void s3c_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	u_long nfcont;
+	cur_ecc_mode = mode;
+	
+#if defined(CONFIG_S3C2450) || defined(CONFIG_S3C2416) || defined(CONFIG_S3C2443) || defined(CONFIG_S3C2412)
+	u_long nfconf;
+
+	nfconf = readl(NFCONF);
+
+#if defined(CONFIG_S3C2450) || defined(CONFIG_S3C2416)
+	nfconf &= ~(0x3 << 23);
+
+	if (nand_type == S3C_NAND_TYPE_SLC)
+		nfconf |= NFCONF_ECC_1BIT;
+	else
+		nfconf |= NFCONF_ECC_4BIT;
+#else
+	if (nand_type == S3C_NAND_TYPE_SLC)
+		nfconf &= ~NFCONF_ECC_MLC;	/* SLC */
+	else
+		nfconf |= NFCONF_ECC_MLC;	/* MLC */
+#endif
+
+	writel(nfconf, NFCONF);
+#endif
+	/* Initialize & unlock */
+	nfcont = readl(NFCONT);
+	nfcont |= NFCONT_INITMECC;
+	nfcont &= ~NFCONT_MECCLOCK;
+
+#if defined(CONFIG_S3C2450) || defined(CONFIG_S3C2416) || defined(CONFIG_S3C2443) || defined(CONFIG_S3C2412)
+	if (nand_type == S3C_NAND_TYPE_MLC) {
+		if (mode == NAND_ECC_WRITE)
+			nfcont |= NFCONT_ECC_ENC;
+		else if (mode == NAND_ECC_READ)
+			nfcont &= ~NFCONT_ECC_ENC;
+	}
+#endif
+	writel(nfcont, NFCONT);
+}
+
+/*
+ * This function is called immediately after encoding ecc codes.
+ * This function returns encoded ecc codes.
+ * Written by jsgood
+ */
+static int s3c_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
+{
+	u_long nfcont, nfmecc0, nfmecc1;
+
+	/* Lock */
+	nfcont = readl(NFCONT);
+	nfcont |= NFCONT_MECCLOCK;
+	writel(nfcont, NFCONT);
+
+	if (nand_type == S3C_NAND_TYPE_SLC) {
+		nfmecc0 = readl(NFMECC0);
+		
+		ecc_code[0] = nfmecc0 & 0xff;
+		ecc_code[1] = (nfmecc0 >> 8) & 0xff;
+		ecc_code[2] = (nfmecc0 >> 16) & 0xff;
+		ecc_code[3] = (nfmecc0 >> 24) & 0xff;
+	} else {
+		if (cur_ecc_mode == NAND_ECC_READ)
+			s3c_nand_wait_dec();
+		else {
+			s3c_nand_wait_enc();
+			
+			nfmecc0 = readl(NFMECC0);
+			nfmecc1 = readl(NFMECC1);
+
+			ecc_code[0] = nfmecc0 & 0xff;
+			ecc_code[1] = (nfmecc0 >> 8) & 0xff;
+			ecc_code[2] = (nfmecc0 >> 16) & 0xff;
+			ecc_code[3] = (nfmecc0 >> 24) & 0xff;			
+			ecc_code[4] = nfmecc1 & 0xff;
+			ecc_code[5] = (nfmecc1 >> 8) & 0xff;
+			ecc_code[6] = (nfmecc1 >> 16) & 0xff;
+			ecc_code[7] = (nfmecc1 >> 24) & 0xff;
+		}
+	}
+	
+	return 0;
+}
+
+/*
+ * This function determines whether read data is good or not.
+ * If SLC, must write ecc codes to controller before reading status bit.
+ * If MLC, status bit is already set, so only reading is needed.
+ * If status bit is good, return 0.
+ * If correctable errors occured, do that.
+ * If uncorrectable errors occured, return -1.
+ * Written by jsgood
+ */
+static int s3c_nand_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)
+{
+	int ret = -1;
+	u_long nfestat0, nfestat1, nfmeccdata0, nfmeccdata1, nfmlcbitpt;
+	u_char err_type;
+
+	if (nand_type == S3C_NAND_TYPE_SLC) {
+		/* SLC: Write ecc to compare */
+		nfmeccdata0 = (read_ecc[1] << 16) | read_ecc[0];
+		nfmeccdata1 = (read_ecc[3] << 16) | read_ecc[2];
+		writel(nfmeccdata0, NFMECCDATA0);
+		writel(nfmeccdata1, NFMECCDATA1);
+
+		/* Read ecc status */
+		nfestat0 = readl(NFESTAT0);
+		err_type = nfestat0 & 0x3;
+
+		switch (err_type) {
+		case 0: /* No error */
+			ret = 0;
+			break;
+
+		case 1: /* 1 bit error (Correctable)
+			   (nfestat0 >> 7) & 0x7ff	:error byte number
+			   (nfestat0 >> 4) & 0x7	:error bit number */
+			printk("s3c-nand: 1 bit error detected at byte %ld, correcting from "
+					"0x%02x ", (nfestat0 >> 7) & 0x7ff, dat[(nfestat0 >> 7) & 0x7ff]);
+			dat[(nfestat0 >> 7) & 0x7ff] ^= (1 << ((nfestat0 >> 4) & 0x7));
+			printk("to 0x%02x...OK\n", dat[(nfestat0 >> 7) & 0x7ff]);
+			ret = 1;
+			break;
+
+		case 2: /* Multiple error */
+		case 3: /* ECC area error */
+			printk("s3c-nand: ECC uncorrectable error detected\n");
+			ret = -1;
+			break;
+		}
+	} else {
+		/* MLC: */
+		s3c_nand_wait_ecc_busy();
+		
+		nfestat0 = readl(NFESTAT0);
+		nfestat1 = readl(NFESTAT1);
+
+#if defined(CONFIG_S3C2450) || defined(CONFIG_S3C2416) || defined(CONFIG_S3C2443) || defined(CONFIG_S3C2412)
+		nfmlcbitpt = readl(NFMLCBITPT);
+#endif
+
+		err_type = (nfestat0 >> 26) & 0x7;
+
+		/* No error, If free page (all 0xff) */
+		if ((nfestat0 >> 29) & 0x1) {
+			err_type = 0;
+		} else {
+			/* No error, If all 0xff from 17th byte in oob (in case of JFFS2 format) */
+			if (dat) {
+				if (dat[17] == 0xff && dat[26] == 0xff && dat[35] == 0xff && dat[44] == 0xff && dat[54] == 0xff)
+					err_type = 0;
+			}
+		}
+
+		switch (err_type) {
+		case 5: /* Uncorrectable */
+			printk("s3c-nand: ECC uncorrectable error detected\n");
+			ret = -1;
+			break;
+
+		case 4: /* 4 bit error (Correctable) */
+			dat[(nfestat1 >> 16) & 0x3ff] ^= ((nfmlcbitpt >> 24) & 0xff);
+
+		case 3: /* 3 bit error (Correctable) */
+			dat[nfestat1 & 0x3ff] ^= ((nfmlcbitpt >> 16) & 0xff);
+
+		case 2: /* 2 bit error (Correctable) */
+			dat[(nfestat0 >> 16) & 0x3ff] ^= ((nfmlcbitpt >> 8) & 0xff);
+
+		case 1: /* 1 bit error (Correctable) */
+			printk("s3c-nand: %d bit(s) error detected, corrected successfully\n", err_type);
+			dat[nfestat0 & 0x3ff] ^= (nfmlcbitpt & 0xff);
+			ret = err_type;
+			break;
+
+		case 0: /* No error */
+			ret = 0;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+#if defined(CONFIG_NAND_BL1_8BIT_ECC) && (defined(CONFIG_S3C2450) || defined(CONFIG_S3C2416))
+/********************************************************************
+ * jsgood: Temporary 8 Bit H/W ECC supports for BL1 (2450/2416 only)
+ ********************************************************************/
+static void s3c_nand_wait_ecc_busy_8bit(void)
+{
+	while (readl(NF8ECCERR0) & NFESTAT0_ECCBUSY) {}
+}
+
+void s3c_nand_enable_hwecc_8bit(struct mtd_info *mtd, int mode)
+{
+	u_long nfcont, nfconf;
+
+	cur_ecc_mode = mode;
+
+	/* 8 bit selection */
+	nfconf = readl(NFCONF);
+
+	nfconf &= ~(0x3 << 23);
+	nfconf |= (0x1 << 23);
+	
+	writel(nfconf, NFCONF);
+
+	/* Initialize & unlock */
+	nfcont = readl(NFCONT);
+	nfcont |= NFCONT_INITECC;
+	nfcont &= ~NFCONT_MECCLOCK;
+
+	if (mode == NAND_ECC_WRITE)
+		nfcont |= NFCONT_ECC_ENC;
+	else if (mode == NAND_ECC_READ)
+		nfcont &= ~NFCONT_ECC_ENC;
+
+	writel(nfcont, NFCONT);
+}
+
+int s3c_nand_calculate_ecc_8bit(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
+{
+	u_long nfcont, nfm8ecc0, nfm8ecc1, nfm8ecc2, nfm8ecc3;
+
+	/* Lock */
+	nfcont = readl(NFCONT);
+	nfcont |= NFCONT_MECCLOCK;
+	writel(nfcont, NFCONT);
+
+	if (cur_ecc_mode == NAND_ECC_READ)
+		s3c_nand_wait_dec();
+	else {
+		s3c_nand_wait_enc();
+		
+		nfm8ecc0 = readl(NFM8ECC0);
+		nfm8ecc1 = readl(NFM8ECC1);
+		nfm8ecc2 = readl(NFM8ECC2);
+		nfm8ecc3 = readl(NFM8ECC3);
+
+		ecc_code[0] = nfm8ecc0 & 0xff;
+		ecc_code[1] = (nfm8ecc0 >> 8) & 0xff;
+		ecc_code[2] = (nfm8ecc0 >> 16) & 0xff;
+		ecc_code[3] = (nfm8ecc0 >> 24) & 0xff;			
+		ecc_code[4] = nfm8ecc1 & 0xff;
+		ecc_code[5] = (nfm8ecc1 >> 8) & 0xff;
+		ecc_code[6] = (nfm8ecc1 >> 16) & 0xff;
+		ecc_code[7] = (nfm8ecc1 >> 24) & 0xff;
+		ecc_code[8] = nfm8ecc2 & 0xff;
+		ecc_code[9] = (nfm8ecc2 >> 8) & 0xff;
+		ecc_code[10] = (nfm8ecc2 >> 16) & 0xff;
+		ecc_code[11] = (nfm8ecc2 >> 24) & 0xff;
+		ecc_code[12] = nfm8ecc3 & 0xff;
+	}
+	
+	return 0;
+}
+
+int s3c_nand_correct_data_8bit(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)
+{
+	int ret = -1;
+	u_long nf8eccerr0, nf8eccerr1, nf8eccerr2, nfmlc8bitpt0, nfmlc8bitpt1;
+	u_char err_type;
+
+	s3c_nand_wait_ecc_busy_8bit();
+	
+	nf8eccerr0 = readl(NF8ECCERR0);
+	nf8eccerr1 = readl(NF8ECCERR1);
+	nf8eccerr2 = readl(NF8ECCERR2);
+	nfmlc8bitpt0 = readl(NFMLC8BITPT0);
+	nfmlc8bitpt1 = readl(NFMLC8BITPT1);
+	
+	err_type = (nf8eccerr0 >> 25) & 0xf;
+
+	/* No error, If free page (all 0xff) */
+	if ((nf8eccerr0 >> 29) & 0x1)
+		err_type = 0;
+
+	switch (err_type) {
+	case 9: /* Uncorrectable */
+		printk("s3c-nand: ECC uncorrectable error detected\n");
+		ret = -1;
+		break;
+
+	case 8: /* 8 bit error (Correctable) */
+		dat[(nf8eccerr2 >> 22) & 0x3ff] ^= ((nfmlc8bitpt1 >> 24) & 0xff);
+
+	case 7: /* 7 bit error (Correctable) */
+		dat[(nf8eccerr2 >> 11) & 0x3ff] ^= ((nfmlc8bitpt1 >> 16) & 0xff);
+
+	case 6: /* 6 bit error (Correctable) */
+		dat[nf8eccerr2 & 0x3ff] ^= ((nfmlc8bitpt1 >> 8) & 0xff);
+
+	case 5: /* 5 bit error (Correctable) */
+		dat[(nf8eccerr1 >> 22) & 0x3ff] ^= (nfmlc8bitpt1 & 0xff);
+
+	case 4: /* 4 bit error (Correctable) */
+		dat[(nf8eccerr1 >> 11) & 0x3ff] ^= ((nfmlc8bitpt0 >> 24) & 0xff);
+
+	case 3: /* 3 bit error (Correctable) */
+		dat[nf8eccerr1 & 0x3ff] ^= ((nfmlc8bitpt0 >> 16) & 0xff);
+
+	case 2: /* 2 bit error (Correctable) */
+		dat[(nf8eccerr0 >> 15) & 0x3ff] ^= ((nfmlc8bitpt0 >> 8) & 0xff);
+
+	case 1: /* 1 bit error (Correctable) */
+		printk("s3c-nand: %d bit(s) error detected, corrected successfully\n", err_type);
+		dat[nf8eccerr0 & 0x3ff] ^= (nfmlc8bitpt0 & 0xff);
+		ret = err_type;
+		break;
+
+	case 0: /* No error */
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+void s3c_nand_write_page_8bit(struct mtd_info *mtd, struct nand_chip *chip,
+				  const uint8_t *buf)
+{
+	int i, eccsize = 512;
+	int eccbytes = 13;
+	int eccsteps = mtd->writesize / eccsize;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	const uint8_t *p = buf;
+
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		s3c_nand_enable_hwecc_8bit(mtd, NAND_ECC_WRITE);
+		chip->write_buf(mtd, p, eccsize);
+		s3c_nand_calculate_ecc_8bit(mtd, p, &ecc_calc[i]);
+	}
+
+	for (i = 0; i < eccbytes * (mtd->writesize / eccsize); i++)
+		chip->oob_poi[i] = ecc_calc[i];
+
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+}
+
+int s3c_nand_read_page_8bit(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf)
+{
+	int i, stat, eccsize = 512;
+	int eccbytes = 13;
+	int eccsteps = mtd->writesize / eccsize;
+	int col = 0;
+	uint8_t *p = buf;	
+
+	/* Step1: read whole oob */
+	col = mtd->writesize;
+	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	col = 0;
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+		s3c_nand_enable_hwecc_8bit(mtd, NAND_ECC_READ);
+		chip->read_buf(mtd, p, eccsize);
+		chip->write_buf(mtd, chip->oob_poi + (((mtd->writesize / eccsize) - eccsteps) * eccbytes), eccbytes);
+		s3c_nand_calculate_ecc_8bit(mtd, 0, 0);
+		stat = s3c_nand_correct_data_8bit(mtd, p, 0, 0);
+
+		if (stat == -1)
+			mtd->ecc_stats.failed++;
+
+		col = eccsize * ((mtd->writesize / eccsize) + 1 - eccsteps);
+	}
+
+	return 0;
+}
+
+/********************************************************/
+#endif
+
+static int s3c_nand_write_oob_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+			      int page)
+{
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	int status = 0;
+	int eccbytes = chip->ecc.bytes;
+	int secc_start = mtd->oobsize - eccbytes;
+	int i;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+
+	/* spare area */
+	chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+	chip->write_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, 0, &ecc_calc[chip->ecc.total]);
+
+	for (i = 0; i < eccbytes; i++)
+		chip->oob_poi[secc_start + i] = ecc_calc[chip->ecc.total + i];
+
+	chip->write_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+
+	/* Send command to program the OOB data */
+	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	status = chip->waitfunc(mtd, chip);
+
+	return status & NAND_STATUS_FAIL ? -EIO : 0;
+}
+
+static int s3c_nand_read_oob_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+			     int page, int sndcmd)
+{
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	int eccbytes = chip->ecc.bytes;
+	int secc_start = mtd->oobsize - eccbytes;
+	
+	if (sndcmd) {
+		chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+		sndcmd = 0;
+	}
+
+	chip->ecc.hwctl(mtd, NAND_ECC_READ);
+	chip->read_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, 0, &ecc_calc[chip->ecc.total]);
+	chip->read_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+
+	/* jffs2 special case */
+	if (!(chip->oob_poi[2] == 0x85 && chip->oob_poi[3] == 0x19))
+		chip->ecc.correct(mtd, chip->oob_poi, chip->oob_poi + secc_start, 0);
+	
+	return sndcmd;
+}
+
+static void s3c_nand_write_page_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+				  const uint8_t *buf)
+{
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	int secc_start = mtd->oobsize - eccbytes;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	const uint8_t *p = buf;
+	
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
+
+	/* main area */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+		chip->write_buf(mtd, p, eccsize);
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+	}
+
+	for (i = 0; i < chip->ecc.total; i++)
+		chip->oob_poi[eccpos[i]] = ecc_calc[i];
+
+	/* spare area */
+	chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+	chip->write_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, p, &ecc_calc[chip->ecc.total]);
+
+	for (i = 0; i < eccbytes; i++)
+		chip->oob_poi[secc_start + i] = ecc_calc[chip->ecc.total + i];
+
+	chip->write_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+}
+
+static int s3c_nand_read_page_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf, int page)
+{
+	int i, stat, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	int secc_start = mtd->oobsize - eccbytes;
+	int col = 0;
+	uint8_t *p = buf;	
+	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+
+	col = mtd->writesize;
+	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, page);
+
+	/* spare area */
+	chip->ecc.hwctl(mtd, NAND_ECC_READ);
+	chip->read_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, p, &ecc_calc[chip->ecc.total]);
+	chip->read_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+
+	/* jffs2 special case */
+	if (!(chip->oob_poi[2] == 0x85 && chip->oob_poi[3] == 0x19))
+		chip->ecc.correct(mtd, chip->oob_poi, chip->oob_poi + secc_start, 0);
+
+	col = 0;
+
+	/* main area */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, page);
+		chip->ecc.hwctl(mtd, NAND_ECC_READ);
+		chip->read_buf(mtd, p, eccsize);
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+
+		stat = chip->ecc.correct(mtd, p, chip->oob_poi + mecc_pos[0] + ((chip->ecc.steps - eccsteps) * eccbytes), 0);
+		if (stat == -1)
+			mtd->ecc_stats.failed++;
+
+		col = eccsize * (chip->ecc.steps + 1 - eccsteps);
+	}
+	
+	return 0;
+}
+
+/* 
+ * Hardware specific page read function for MLC.
+ * Written by jsgood
+ */
+static int s3c_nand_read_page_4bit(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf, int page)
+{
+	int i, stat, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	int col = 0;
+	uint8_t *p = buf;	
+	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
+
+	/* Step1: read whole oob */
+	col = mtd->writesize;
+	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, page);
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	col = 0;
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, page);
+		chip->ecc.hwctl(mtd, NAND_ECC_READ);
+		chip->read_buf(mtd, p, eccsize);
+		chip->write_buf(mtd, chip->oob_poi + mecc_pos[0] + ((chip->ecc.steps - eccsteps) * eccbytes), eccbytes);
+		chip->ecc.calculate(mtd, 0, 0);
+		stat = chip->ecc.correct(mtd, p, 0, 0);
+
+		if (stat == -1)
+			mtd->ecc_stats.failed++;
+
+		col = eccsize * (chip->ecc.steps + 1 - eccsteps);
+	}
+
+	return 0;
+}
+
+/* 
+ * Hardware specific page write function for MLC.
+ * Written by jsgood
+ */
+static void s3c_nand_write_page_4bit(struct mtd_info *mtd, struct nand_chip *chip,
+				  const uint8_t *buf)
+{
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	const uint8_t *p = buf;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
+	 
+	/* Step1: write main data and encode mecc */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+		chip->write_buf(mtd, p, eccsize);
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+	}
+
+	/* Step2: save encoded mecc */
+	for (i = 0; i < chip->ecc.total; i++)
+		chip->oob_poi[mecc_pos[i]] = ecc_calc[i];
+
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+}
+#endif
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+int board_nand_init(struct nand_chip *nand)
+{
+#if defined(CFG_NAND_HWECC)
+	int i;
+	u_char tmp;
+	struct nand_flash_dev *type = NULL;
+#endif
+	
+	if (NFCONF_REG & 0x80000000)
+		boot_nand = 1;
+	else
+		boot_nand = 0;
+
+	NFCONT_REG 		&= ~NFCONT_WP;
+	nand->IO_ADDR_R		= (void __iomem *)(NFDATA);
+	nand->IO_ADDR_W		= (void __iomem *)(NFDATA);
+	nand->cmd_ctrl		= s3c_nand_hwcontrol;
+	nand->dev_ready		= s3c_nand_device_ready;
+	nand->scan_bbt		= s3c_nand_scan_bbt;
+	nand->options		= 0;
+
+#if defined(CFG_NAND_FLASH_BBT)
+		nand->options 		|= NAND_USE_FLASH_BBT;
+#else
+		nand->options		|= NAND_SKIP_BBTSCAN;
+#endif
+
+#if defined(CFG_NAND_HWECC)
+	nand->ecc.mode		= NAND_ECC_HW;
+	nand->ecc.hwctl		= s3c_nand_enable_hwecc;
+	nand->ecc.calculate	= s3c_nand_calculate_ecc;
+	nand->ecc.correct	= s3c_nand_correct_data;
+	
+	s3c_nand_hwcontrol(0, NAND_CMD_READID, NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
+	s3c_nand_hwcontrol(0, 0x00, NAND_CTRL_CHANGE | NAND_NCE | NAND_ALE);
+	s3c_nand_hwcontrol(0, 0x00, NAND_NCE | NAND_ALE);
+	s3c_nand_hwcontrol(0, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
+	s3c_nand_device_ready(0);
+
+	tmp = readb(nand->IO_ADDR_R); /* Maf. ID */
+
+	tmp = readb(nand->IO_ADDR_R); /* Device ID */
+
+	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
+		if (tmp == nand_flash_ids[i].id) {
+			type = &nand_flash_ids[i];
+			break;
+		}
+	}
+	
+	nand->cellinfo = readb(nand->IO_ADDR_R);	/* 3rd byte */
+
+	tmp = readb(nand->IO_ADDR_R);			/* 4th byte */
+
+	if (!type->pagesize) {
+		if (((nand->cellinfo >> 2) & 0x3) == 0) {
+			nand_type = S3C_NAND_TYPE_SLC;
+			nand->ecc.size = 512;
+			nand->ecc.bytes	= 4;
+			
+			if ((1024 << (tmp & 0x3)) > 512) {
+				nand->ecc.read_page = s3c_nand_read_page_1bit;
+				nand->ecc.write_page = s3c_nand_write_page_1bit;
+				nand->ecc.read_oob = s3c_nand_read_oob_1bit;
+				nand->ecc.write_oob = s3c_nand_write_oob_1bit;
+				nand->ecc.layout = &s3c_nand_oob_64;
+			} else {
+				nand->ecc.layout = &s3c_nand_oob_16;
+			}
+		} else {
+			nand_type = S3C_NAND_TYPE_MLC;
+			nand->options |= NAND_NO_SUBPAGE_WRITE;	/* NOP = 1 if MLC */
+			nand->ecc.read_page = s3c_nand_read_page_4bit;
+			nand->ecc.write_page = s3c_nand_write_page_4bit;
+			nand->ecc.size = 512;
+			nand->ecc.bytes = 8;	/* really 7 bytes */
+			nand->ecc.layout = &s3c_nand_oob_mlc_64;
+		}
+	} else {
+
+		nand_type = S3C_NAND_TYPE_SLC;
+		nand->ecc.size = 512;
+		nand->cellinfo = 0;
+		nand->ecc.bytes = 4;
+		nand->ecc.layout = &s3c_nand_oob_16;
+	}
+#else
+	nand->ecc.mode = NAND_ECC_SOFT;
+#endif
+
+    return 0;
+}
+#endif /* CONFIG_CMD_NAND */
diff -NBbur u-boot-2010.09-orig/board/samsung/smdk2416/serial_s3c24xx.c u-boot-2010.09-smdk2416/board/samsung/smdk2416/serial_s3c24xx.c
--- u-boot-2010.09-orig/board/samsung/smdk2416/serial_s3c24xx.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/board/samsung/smdk2416/serial_s3c24xx.c	2011-09-01 16:15:51.000000000 +0800
@@ -0,0 +1,189 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <common.h>
+
+#if defined(CONFIG_S3C2400) || defined(CONFIG_TRAB)
+#include <s3c2400.h>
+#elif defined(CONFIG_S3C2410)
+#include <s3c2410.h>
+#elif defined(CONFIG_S3C24XX)
+#include <asm/arch/s3c2416.h>
+#endif
+
+#ifdef CONFIG_SERIAL1
+#define UART_NR	S3C24X0_UART0
+
+#elif defined(CONFIG_SERIAL2)
+# if defined(CONFIG_TRAB)
+#  error "TRAB supports only CONFIG_SERIAL1"
+# endif
+#define UART_NR	S3C24X0_UART1
+
+#elif defined(CONFIG_SERIAL3)
+# if defined(CONFIG_TRAB)
+#  #error "TRAB supports only CONFIG_SERIAL1"
+# endif
+#define UART_NR	S3C24X0_UART2
+
+#else
+#error "Bad: you didn't configure serial ..."
+#endif
+
+extern ulong get_PCLK(void);
+
+void serial_setbrg(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	S3C24X0_UART *const uart = S3C24X0_GetBase_UART(UART_NR);
+	int i;
+	unsigned int reg = 0;
+
+	/* value is calculated so : (int)(PCLK/16./baudrate) -1 */
+	reg = get_PCLK() / (16 * gd->baudrate) - 1;
+
+	/* FIFO enable, Tx/Rx FIFO clear */
+	uart->UFCON = 0x07;
+	uart->UMCON = 0x0;
+	/* Normal,No parity,1 stop,8 bit */
+	uart->ULCON = 0x3;
+	/*
+	 * tx=level,rx=edge,disable timeout int.,enable rx error int.,
+	 * normal,interrupt or polling
+	 */
+	uart->UCON = 0x245;
+#ifdef CONFIG_SMDK2460
+	uart->UBRDIV = 0x1a;
+#else
+	uart->UBRDIV = reg;
+#endif
+
+#ifdef CONFIG_HWFLOW
+	uart->UMCON = 0x1;	/* RTS up */
+#endif
+	for (i = 0; i < 100; i++);
+}
+
+/*
+ * Initialise the serial port with the given baudrate. The settings
+ * are always 8 data bits, no parity, 1 stop bit, no start bits.
+ *
+ */
+int serial_init(void)
+{
+
+	serial_setbrg();
+
+	return (0);
+}
+
+/*
+ * Read a single byte from the serial port. Returns 1 on success, 0
+ * otherwise. When the function is succesfull, the character read is
+ * written into its argument c.
+ */
+int serial_getc(void)
+{
+	S3C24X0_UART *const uart = S3C24X0_GetBase_UART(UART_NR);
+
+	/* wait for character to arrive */
+	while (!(uart->UTRSTAT & 0x1));
+
+	return uart->URXH & 0xff;
+}
+
+#ifdef CONFIG_HWFLOW
+static int hwflow = 0;		/* turned off by default */
+int hwflow_onoff(int on)
+{
+	switch (on) {
+	case 0:
+	default:
+		break;		/* return current */
+	case 1:
+		hwflow = 1;	/* turn on */
+		break;
+	case -1:
+		hwflow = 0;	/* turn off */
+		break;
+	}
+	return hwflow;
+}
+#endif
+
+#ifdef CONFIG_MODEM_SUPPORT
+static int be_quiet = 0;
+void disable_putc(void)
+{
+	be_quiet = 1;
+}
+
+void enable_putc(void)
+{
+	be_quiet = 0;
+}
+#endif
+
+
+/*
+ * Output a single byte to the serial port.
+ */
+void serial_putc(const char c)
+{
+	S3C24X0_UART *const uart = S3C24X0_GetBase_UART(UART_NR);
+
+#ifdef CONFIG_MODEM_SUPPORT
+	if (be_quiet)
+		return;
+#endif
+
+	/* wait for room in the tx FIFO */
+	while (!(uart->UTRSTAT & 0x2));
+
+#ifdef CONFIG_HWFLOW
+	/* Wait for CTS up */
+	while (hwflow && !(uart->UMSTAT & 0x1));
+#endif
+
+	uart->UTXH = c;
+
+	/* If \n, also do \r */
+	if (c == '\n')
+		serial_putc('\r');
+}
+
+/*
+ * Test whether a character is in the RX buffer
+ */
+int serial_tstc(void)
+{
+	S3C24X0_UART *const uart = S3C24X0_GetBase_UART(UART_NR);
+
+	return uart->UTRSTAT & 0x1;
+}
+
+void serial_puts(const char *s)
+{
+	while (*s) {
+		serial_putc(*s++);
+	}
+}
+
diff -NBbur u-boot-2010.09-orig/board/samsung/smdk2416/smdk2416.c u-boot-2010.09-smdk2416/board/samsung/smdk2416/smdk2416.c
--- u-boot-2010.09-orig/board/samsung/smdk2416/smdk2416.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/board/samsung/smdk2416/smdk2416.c	2011-09-01 16:15:06.000000000 +0800
@@ -0,0 +1,149 @@
+/*
+ * (C) Copyright 2007-2008
+ * Jong - pill, Lee <boyko.lee@samsung.com>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/s3c2416.h>
+/* ------------------------------------------------------------------------- */
+#ifdef CONFIG_SMC911X
+extern int smc911x_initialize(u8 dev_num, int base_addr); 
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static inline void delay(unsigned long loops)
+{
+	__asm__ volatile ("1:\n" "subs %0, %1, #1\n" "bne 1b":"=r" (loops):"0"(loops));
+}
+
+
+/*
+ *  * Miscellaneous platform dependent initialisations
+ *   */
+
+static void smc911x_pre_init(void)
+{
+#if 1
+    SMBIDCYR1_REG = 0;          /* Bank1 Idle cycle ctrl. */
+    SMBWSTWRR1_REG = 14;        /* Bank1 Write Wait State ctrl. */
+    SMBWSTOENR1_REG = 2;        /* Bank1 Output Enable Assertion Delay ctrl.     Tcho? */
+    SMBWSTWENR1_REG = 2;        /* Bank1 Write Enable Assertion Delay ctrl. */
+    SMBWSTRDR1_REG = 14;        /* Bank1 Read Wait State cont. = 14 clk      Tacc? */
+#endif
+    SMBCR1_REG |=  ((1<<15)|(1<<7));    
+    SMBCR1_REG |=  ((1<<2)|(1<<0));     /* SMWAIT active High, Read Byte Lane Enabl      WS1? */
+    SMBCR1_REG &= ~((3<<20)|(3<<12));   /* SMADDRVALID = always High when Read/Write */
+    SMBCR1_REG &= ~(3<<4);              /* Clear Memory Width */
+    SMBCR1_REG |=  (1<<4);              /*Memory Width = 16bit */
+}
+
+int board_init(void)
+{
+    smc911x_pre_init();    /* ethert hardware initialize*/
+
+	gd->bd->bi_arch_number = MACH_TYPE;    /* machine type */
+	gd->bd->bi_boot_params = (PHYS_SDRAM_1+0x100);  /* the address of parameter list for kernel */
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;      /* sdram start address, bank #1 */
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;  /* sdram size */
+
+	return 0;
+}
+
+#ifdef BOARD_LATE_INIT
+int board_late_init (void)
+{
+	uint *magic = (uint*)(PHYS_SDRAM_1);
+	char boot_cmd[100];
+
+	if ((0x24564236 == magic[0]) && (0x20764316 == magic[1])) {
+		sprintf(boot_cmd, "nand erase 0 40000;nand write %08x 0 40000", PHYS_SDRAM_1 + 0x8000);
+		magic[0] = 0;
+		magic[1] = 0;
+		printf("\nready for self-burning U-Boot image\n\n");
+		setenv("bootdelay", "0");
+		setenv("bootcmd", boot_cmd);
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_DISPLAY_BOARDINFO
+int checkboard(void)
+{
+	vu_long *mem_reg = (vu_long*) 0x48000000;
+
+	printf("Board: GHL SMDK2416 ");
+	switch ((*mem_reg>>1) & 0x7) {
+	case 0:
+		puts("SDRAM\n");
+		break;
+	case 1:
+		puts("DDR2\n");
+		break;
+	case 2:
+		puts("Mobile SDRAM\n");
+		break;
+	case 4:
+		puts("DDR\n");
+		break;
+	case 6:
+		puts("Mobile DDR\n");
+		break;
+	default:
+		puts("unknown Memory Type\n");
+	}
+	return (0);
+}
+#endif
+
+#ifdef CONFIG_ENABLE_MMU
+ulong virt_to_phy_smdk2416(ulong addr)
+{
+	if ((0xC0000000 <= addr) && (addr < 0xC4000000))
+		return (addr - 0xC0000000 + 0x30000000);
+	else
+		printf("do not support this address : %08lx\n", addr);
+
+	return addr;
+}
+#endif
+
+#ifdef CONFIG_CMD_NET
+int board_eth_init(bd_t *bis)
+{
+    int rc = 0;
+#ifdef CONFIG_SMC911X
+    rc = smc911x_initialize(0, CONFIG_SMC911X_BASE);
+#endif
+    return rc;
+}
+#endif
diff -NBbur u-boot-2010.09-orig/board/samsung/smdk2416/tags u-boot-2010.09-smdk2416/board/samsung/smdk2416/tags
--- u-boot-2010.09-orig/board/samsung/smdk2416/tags	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/board/samsung/smdk2416/tags	2011-09-01 15:14:32.000000000 +0800
@@ -0,0 +1,116 @@
+!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
+!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
+!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
+!_TAG_PROGRAM_NAME	Exuberant Ctags	//
+!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
+!_TAG_PROGRAM_VERSION	5.7	//
+COBJS	Makefile	/^COBJS	:= smdk2416.o nand.o $/;"	m
+LIB	Makefile	/^LIB	= $(obj)lib$(BOARD).a$/;"	m
+OBJS	Makefile	/^OBJS	:= $(addprefix $(obj),$(COBJS))$/;"	m
+S3C_NAND_DEBUG	nand.c	39;"	d	file:
+S3C_NAND_TYPE_MLC	nand.c	38;"	d	file:
+S3C_NAND_TYPE_SLC	nand.c	37;"	d	file:
+S3C_NAND_TYPE_UNKNOWN	nand.c	36;"	d	file:
+SOBJS	Makefile	/^SOBJS	:= $(addprefix $(obj),$(SOBJS))$/;"	m
+SOBJS	Makefile	/^SOBJS	:= lowlevel_init.o$/;"	m
+SRCS	Makefile	/^SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)$/;"	m
+TEXT_BASE	config.mk	/^TEXT_BASE = 0xc3e00000$/;"	m
+_TEXT_BASE	lowlevel_init.S	/^_TEXT_BASE:$/;"	l
+board_eth_init	smdk2416.c	/^int board_eth_init(bd_t *bis)$/;"	f
+board_init	smdk2416.c	/^int board_init(void)$/;"	f
+board_late_init	smdk2416.c	/^int board_late_init (void)$/;"	f
+board_nand_init	nand.c	/^int board_nand_init(struct nand_chip *nand)$/;"	f
+boot_cmd	smdk2416.c	/^	char boot_cmd[100];$/;"	l
+boot_nand	nand.c	/^int boot_nand = 0;$/;"	v
+checkboard	smdk2416.c	/^int checkboard(void)$/;"	f
+chip	nand.c	/^	struct nand_chip *chip = mtd->priv;$/;"	l
+col	nand.c	/^	int col = 0;$/;"	l
+cur	nand.c	/^	unsigned int cur;$/;"	l
+cur_ecc_mode	nand.c	/^int cur_ecc_mode = 0;$/;"	v
+delay	smdk2416.c	/^static inline void delay(unsigned long loops)$/;"	f	file:
+dram_init	smdk2416.c	/^int dram_init(void)$/;"	f
+ecc_calc	nand.c	/^	uint8_t *ecc_calc = chip->buffers->ecccalc;$/;"	l
+eccbytes	nand.c	/^	int eccbytes = 13;$/;"	l
+eccbytes	nand.c	/^	int eccbytes = chip->ecc.bytes;$/;"	l
+eccpos	nand.c	/^	uint32_t *eccpos = chip->ecc.layout->eccpos;$/;"	l
+eccsize	nand.c	/^	int i, eccsize = 512;$/;"	l
+eccsize	nand.c	/^	int i, eccsize = chip->ecc.size;$/;"	l
+eccsize	nand.c	/^	int i, stat, eccsize = 512;$/;"	l
+eccsize	nand.c	/^	int i, stat, eccsize = chip->ecc.size;$/;"	l
+eccsteps	nand.c	/^	int eccsteps = chip->ecc.steps;$/;"	l
+eccsteps	nand.c	/^	int eccsteps = mtd->writesize \/ eccsize;$/;"	l
+err_type	nand.c	/^	u_char err_type;$/;"	l
+i	nand.c	/^	int i, eccsize = 512;$/;"	l
+i	nand.c	/^	int i, eccsize = chip->ecc.size;$/;"	l
+i	nand.c	/^	int i, stat, eccsize = 512;$/;"	l
+i	nand.c	/^	int i, stat, eccsize = chip->ecc.size;$/;"	l
+i	nand.c	/^	int i;$/;"	l
+lowlevel_init	lowlevel_init.S	/^lowlevel_init:$/;"	l
+magic	smdk2416.c	/^	uint *magic = (uint*)(PHYS_SDRAM_1);$/;"	l
+mecc_pos	nand.c	/^	uint32_t *mecc_pos = chip->ecc.layout->eccpos;$/;"	l
+mem_reg	smdk2416.c	/^	vu_long *mem_reg = (vu_long*) 0x48000000;$/;"	l
+mmu_table	lowlevel_init.S	/^mmu_table:$/;"	l
+nand_asm_init	lowlevel_init.S	/^nand_asm_init:$/;"	l
+nand_type	nand.c	/^int nand_type = S3C_NAND_TYPE_UNKNOWN;$/;"	v
+nf8eccerr0	nand.c	/^	u_long nf8eccerr0, nf8eccerr1, nf8eccerr2, nfmlc8bitpt0, nfmlc8bitpt1;$/;"	l
+nf8eccerr1	nand.c	/^	u_long nf8eccerr0, nf8eccerr1, nf8eccerr2, nfmlc8bitpt0, nfmlc8bitpt1;$/;"	l
+nf8eccerr2	nand.c	/^	u_long nf8eccerr0, nf8eccerr1, nf8eccerr2, nfmlc8bitpt0, nfmlc8bitpt1;$/;"	l
+nfconf	nand.c	/^	u_long nfconf;$/;"	l
+nfconf	nand.c	/^	u_long nfcont, nfconf;$/;"	l
+nfcont	nand.c	/^	u_long nfcont, nfconf;$/;"	l
+nfcont	nand.c	/^	u_long nfcont, nfm8ecc0, nfm8ecc1, nfm8ecc2, nfm8ecc3;$/;"	l
+nfcont	nand.c	/^	u_long nfcont, nfmecc0, nfmecc1;$/;"	l
+nfcont	nand.c	/^	u_long nfcont;$/;"	l
+nfestat0	nand.c	/^	u_long nfestat0, nfestat1, nfmeccdata0, nfmeccdata1, nfmlcbitpt;$/;"	l
+nfestat1	nand.c	/^	u_long nfestat0, nfestat1, nfmeccdata0, nfmeccdata1, nfmlcbitpt;$/;"	l
+nfm8ecc0	nand.c	/^	u_long nfcont, nfm8ecc0, nfm8ecc1, nfm8ecc2, nfm8ecc3;$/;"	l
+nfm8ecc1	nand.c	/^	u_long nfcont, nfm8ecc0, nfm8ecc1, nfm8ecc2, nfm8ecc3;$/;"	l
+nfm8ecc2	nand.c	/^	u_long nfcont, nfm8ecc0, nfm8ecc1, nfm8ecc2, nfm8ecc3;$/;"	l
+nfm8ecc3	nand.c	/^	u_long nfcont, nfm8ecc0, nfm8ecc1, nfm8ecc2, nfm8ecc3;$/;"	l
+nfmecc0	nand.c	/^	u_long nfcont, nfmecc0, nfmecc1;$/;"	l
+nfmecc1	nand.c	/^	u_long nfcont, nfmecc0, nfmecc1;$/;"	l
+nfmeccdata0	nand.c	/^	u_long nfestat0, nfestat1, nfmeccdata0, nfmeccdata1, nfmlcbitpt;$/;"	l
+nfmeccdata1	nand.c	/^	u_long nfestat0, nfestat1, nfmeccdata0, nfmeccdata1, nfmlcbitpt;$/;"	l
+nfmlc8bitpt0	nand.c	/^	u_long nf8eccerr0, nf8eccerr1, nf8eccerr2, nfmlc8bitpt0, nfmlc8bitpt1;$/;"	l
+nfmlc8bitpt1	nand.c	/^	u_long nf8eccerr0, nf8eccerr1, nf8eccerr2, nfmlc8bitpt0, nfmlc8bitpt1;$/;"	l
+nfmlcbitpt	nand.c	/^	u_long nfestat0, nfestat1, nfmeccdata0, nfmeccdata1, nfmlcbitpt;$/;"	l
+p	nand.c	/^	const uint8_t *p = buf;$/;"	l
+p	nand.c	/^	uint8_t *p = buf;	$/;"	l
+print_oob	nand.c	/^static void print_oob(const char *header, struct mtd_info *mtd)$/;"	f	file:
+rc	smdk2416.c	/^    int rc = 0;$/;"	l
+ret	nand.c	/^	int ret = -1;$/;"	l
+s3c_nand_calculate_ecc	nand.c	/^static int s3c_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)$/;"	f	file:
+s3c_nand_calculate_ecc_8bit	nand.c	/^int s3c_nand_calculate_ecc_8bit(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)$/;"	f
+s3c_nand_correct_data	nand.c	/^static int s3c_nand_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)$/;"	f	file:
+s3c_nand_correct_data_8bit	nand.c	/^int s3c_nand_correct_data_8bit(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)$/;"	f
+s3c_nand_device_ready	nand.c	/^static int s3c_nand_device_ready(struct mtd_info *mtdinfo)$/;"	f	file:
+s3c_nand_enable_hwecc	nand.c	/^static void s3c_nand_enable_hwecc(struct mtd_info *mtd, int mode)$/;"	f	file:
+s3c_nand_enable_hwecc_8bit	nand.c	/^void s3c_nand_enable_hwecc_8bit(struct mtd_info *mtd, int mode)$/;"	f
+s3c_nand_hwcontrol	nand.c	/^static void s3c_nand_hwcontrol(struct mtd_info *mtd, int dat, unsigned int ctrl)$/;"	f	file:
+s3c_nand_oob_16	nand.c	/^static struct nand_ecclayout s3c_nand_oob_16 = {$/;"	v	typeref:struct:nand_ecclayout	file:
+s3c_nand_oob_64	nand.c	/^static struct nand_ecclayout s3c_nand_oob_64 = {$/;"	v	typeref:struct:nand_ecclayout	file:
+s3c_nand_oob_mlc_64	nand.c	/^static struct nand_ecclayout s3c_nand_oob_mlc_64 = {$/;"	v	typeref:struct:nand_ecclayout	file:
+s3c_nand_read_oob_1bit	nand.c	/^static int s3c_nand_read_oob_1bit(struct mtd_info *mtd, struct nand_chip *chip,$/;"	f	file:
+s3c_nand_read_page_1bit	nand.c	/^static int s3c_nand_read_page_1bit(struct mtd_info *mtd, struct nand_chip *chip,$/;"	f	file:
+s3c_nand_read_page_4bit	nand.c	/^static int s3c_nand_read_page_4bit(struct mtd_info *mtd, struct nand_chip *chip,$/;"	f	file:
+s3c_nand_read_page_8bit	nand.c	/^int s3c_nand_read_page_8bit(struct mtd_info *mtd, struct nand_chip *chip,$/;"	f
+s3c_nand_scan_bbt	nand.c	/^static int s3c_nand_scan_bbt(struct mtd_info *mtdinfo)$/;"	f	file:
+s3c_nand_wait_dec	nand.c	/^static void s3c_nand_wait_dec(void)$/;"	f	file:
+s3c_nand_wait_ecc_busy	nand.c	/^static void s3c_nand_wait_ecc_busy(void)$/;"	f	file:
+s3c_nand_wait_ecc_busy_8bit	nand.c	/^static void s3c_nand_wait_ecc_busy_8bit(void)$/;"	f	file:
+s3c_nand_wait_enc	nand.c	/^static void s3c_nand_wait_enc(void)$/;"	f	file:
+s3c_nand_write_oob_1bit	nand.c	/^static int s3c_nand_write_oob_1bit(struct mtd_info *mtd, struct nand_chip *chip,$/;"	f	file:
+s3c_nand_write_page_1bit	nand.c	/^static void s3c_nand_write_page_1bit(struct mtd_info *mtd, struct nand_chip *chip,$/;"	f	file:
+s3c_nand_write_page_4bit	nand.c	/^static void s3c_nand_write_page_4bit(struct mtd_info *mtd, struct nand_chip *chip,$/;"	f	file:
+s3c_nand_write_page_8bit	nand.c	/^void s3c_nand_write_page_8bit(struct mtd_info *mtd, struct nand_chip *chip,$/;"	f
+sdram_bank_sel_val_alt	lowlevel_init.S	/^sdram_bank_sel_val_alt:$/;"	l
+sdram_bank_set_val	lowlevel_init.S	/^sdram_bank_set_val:$/;"	l
+secc_start	nand.c	/^	int secc_start = mtd->oobsize - eccbytes;$/;"	l
+stat	nand.c	/^	int i, stat, eccsize = 512;$/;"	l
+stat	nand.c	/^	int i, stat, eccsize = chip->ecc.size;$/;"	l
+status	nand.c	/^	int status = 0;$/;"	l
+system_clock_init	lowlevel_init.S	/^system_clock_init:$/;"	l
+tmp	nand.c	/^	u_char tmp;$/;"	l
+type	nand.c	/^	struct nand_flash_dev *type = NULL;$/;"	l
+uart_asm_init	lowlevel_init.S	/^uart_asm_init:$/;"	l
+virt_to_phy_smdk2416	smdk2416.c	/^ulong virt_to_phy_smdk2416(ulong addr)$/;"	f
diff -NBbur u-boot-2010.09-orig/boards.cfg u-boot-2010.09-smdk2416/boards.cfg
--- u-boot-2010.09-orig/boards.cfg	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-smdk2416/boards.cfg	2011-09-01 15:09:52.000000000 +0800
@@ -238,6 +238,7 @@
 sbc2410x	arm	arm920t		-		-		s3c24x0
 smdk2400	arm	arm920t		-		samsung		s3c24x0
 smdk2410	arm	arm920t		-		samsung		s3c24x0
+smdk2416    arm s3c24xx   -       samsung       s3c2416
 voiceblue	arm	arm925t
 omap1510inn	arm	arm925t		-		ti
 afeb9260	arm	arm926ejs	-		-		at91
diff -NBbur u-boot-2010.09-orig/drivers/mtd/nand/nand_util.c u-boot-2010.09-smdk2416/drivers/mtd/nand/nand_util.c
--- u-boot-2010.09-orig/drivers/mtd/nand/nand_util.c	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-smdk2416/drivers/mtd/nand/nand_util.c	2011-09-01 17:43:23.000000000 +0800
@@ -126,7 +126,7 @@
 			if (ret > 0) {
 				if (!opts->quiet)
 					printf("\rSkipping bad block at  "
-					       "0x%08llx                 "
+					       "0x%08x                 "
 					       "                         \n",
 					       erase.addr);
 				continue;
@@ -180,11 +180,11 @@
 			if (percent != percent_complete) {
 				percent_complete = percent;
 
-				printf("\rErasing at 0x%llx -- %3d%% complete.",
+				printf("\rErasing at 0x%x -- %3d%% complete.",
 				       erase.addr, percent);
 
 				if (opts->jffs2 && result == 0)
-					printf(" Cleanmarker written at 0x%llx.",
+					printf(" Cleanmarker written at 0x%x.",
 					       erase.addr);
 			}
 		}
Binary files u-boot-2010.09-orig/examples/standalone/smc911x_eeprom and u-boot-2010.09-smdk2416/examples/standalone/smc911x_eeprom differ
diff -NBbur u-boot-2010.09-orig/include/configs/smdk2416.h u-boot-2010.09-smdk2416/include/configs/smdk2416.h
--- u-boot-2010.09-orig/include/configs/smdk2416.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2010.09-smdk2416/include/configs/smdk2416.h	2011-09-02 10:58:15.000000000 +0800
@@ -0,0 +1,314 @@
+/*
+ * (C) Copyright 2007-2008
+ * Jong - pill, Lee <boyko.lee@samsung.com>
+ *
+ * Configuation settings for the SAMSUNG SMDK2416 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_S3C2416		1		/* in a SAMSUNG S3C2416 SoC     */
+#define CONFIG_S3C24XX		1		/* in a SAMSUNG S3C24XX Family  */
+#define CONFIG_SMDK2416		1		/* on a SAMSUNG SMDK2416 Board  */
+
+#define MEMORY_BASE_ADDRESS	0x30000000
+
+/* input clock of PLL */
+#define CONFIG_SYS_CLK_FREQ	12000000	/* the SMDK2416 has 12MHz input clock */
+
+#define CONFIG_ENABLE_MMU               /* Enable MMU */
+
+#ifdef CONFIG_ENABLE_MMU
+#define CONFIG_BUILD_MMU_TABLE_RUNTIME	1
+#ifdef CONFIG_BUILD_MMU_TABLE_RUNTIME
+#define MMU_TABLE_BASE		(CFG_PHY_UBOOT_BASE + 0xa0000 - 0x4000)
+#define MMU_IO_AREA_START	(0x00000000)
+#define MMU_RESERVED1_START	(0x60000000)
+#define MMU_MEM_AREA_START	(0xc0000000)
+#define MMU_RESERVED2_START	(0xc4000000)
+#endif
+#define virt_to_phys(x)	virt_to_phy_smdk2416(x)
+#else
+#define virt_to_phys(x)	(x)
+#endif
+/* CONFIG_ENABLE_MMU */
+
+#define CONFIG_MEMORY_UPPER_CODE    /* memory upper growth */
+
+#define CONFIG_USE_IRQ				/* we need IRQ/FIQ stuff */
+
+#define CONFIG_INCLUDE_TEST
+
+#define CONFIG_ZIMAGE_BOOT
+#define CONFIG_IMAGE_BOOT
+
+#define BOARD_LATE_INIT
+
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_INITRD_TAG
+
+/*
+ * Architecture magic and machine type
+ */
+#define MACH_TYPE		1685
+#define UBOOT_MAGIC		(0x43090000 | MACH_TYPE)
+
+/* Power Management is enabled */
+#define CONFIG_PM
+
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#undef CONFIG_SKIP_RELOCATE_UBOOT
+
+/* No nor flash */
+#define  CONFIG_SYS_NO_FLASH
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(1024*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+#define CFG_STACK_SIZE		        0x40000	/* 256k */
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_S3C24XX_SERIAL
+#define CONFIG_SERIAL2		1	/* we use SERIAL 1 on SMDK2416 */
+
+#define CFG_HUSH_PARSER			/* use "hush" command parser	*/
+#ifdef CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2	"> "
+#endif
+
+#define CONFIG_CMDLINE_EDITING
+
+/************************************************************
+ * RTC
+ ************************************************************/
+#define CONFIG_RTC_S3C24XX	1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_BAUDRATE		115200
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+//#define CONFIG_CMD_DATE
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_REGINFO
+#define	CONFIG_CMD_NAND
+#define CONFIG_CMD_CACHE
+#define CONFIG_CMD_NET
+//#define CONFIG_COMMANDS    1 
+#define CFG_CMD_NAND       1
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_DHCP
+
+#define CONFIG_BOOTDELAY	3
+
+/*Delay 0s */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+/* Network */
+#define CONFIG_NET_MULTI
+#define CONFIG_SMC911X
+#define CONFIG_SMC911X_BASE	    0x08000000
+#define CONFIG_SMC911X_16_BIT
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200		/* speed to run kgdb serial port */
+/* what's this ? it's not used anywhere */
+#define CONFIG_KGDB_SER_INDEX	1		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+#define CONFIG_SYS_PROMPT		"SAM2416EDK # "	/* Monitor Command Prompt	*/
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE		384		/* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CFG_BARGSIZE		CFG_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	MEMORY_BASE_ADDRESS	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		(MEMORY_BASE_ADDRESS + 0x3e00000)	/* 62 MB in DRAM	*/
+
+#undef  CFG_CLKS_IN_HZ		             /* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		MEMORY_BASE_ADDRESS	/* default load address	*/
+
+/* the PWM TImer 4 uses a counter of 15625 for 10 ms, so we need */
+/* it to wrap 100 times (total 1562500) to get 1 sec. */
+#define CONFIG_SYS_HZ			1562500
+
+/* valid baudrates */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	0x40000		/* regular stack 256KB */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Clock Configuration
+ */
+
+//#define CONFIG_CLK_534_133_66
+#define CONFIG_CLK_400_133_66
+//#define CONFIG_CLK_267_133_66
+
+#if defined(CONFIG_CLK_400_133_66)/* Output CLK 800MHz 2:4:8*/
+#define Startup_MDIV		400
+#define Startup_PDIV		3
+#define Startup_SDIV		1
+#define Startup_EPLLSTOP	0
+#define Startup_ARMCLKdiv	1
+#define Startup_PREdiv		0x2
+#define Startup_HCLKdiv		0x1
+#define Startup_PCLKdiv		1
+#elif defined (CONFIG_CLK_534_133_66)
+#define Startup_MDIV		267
+#define Startup_PDIV		3
+#define Startup_SDIV		1
+#define Startup_EPLLSTOP	0
+#define Startup_ARMCLKdiv	0
+#define Startup_PREdiv		0x1
+#define Startup_HCLKdiv		0x1
+#define Startup_PCLKdiv		1
+#elif defined (CONFIG_CLK_267_133_66)
+#define Startup_MDIV		267
+#define Startup_PDIV		3
+#define Startup_SDIV		1
+#define Startup_EPLLSTOP	0
+#define Startup_ARMCLKdiv	1
+#define Startup_PREdiv		0x1
+#define Startup_HCLKdiv		0x1
+#define Startup_PCLKdiv		1
+#else
+# error Must define CONFIG_CLK_534_133_66 or CONFIG_CLK_400_133_66
+#endif
+
+#define CLK_DIV_VAL	((Startup_ARMCLKdiv<<9)|(Startup_PREdiv<<4)|(Startup_PCLKdiv<<2)|(Startup_HCLKdiv)|(1<<3))
+#define MPLL_VAL	((Startup_EPLLSTOP<<24)|(Startup_MDIV<<14)|(Startup_PDIV<<5)|(Startup_SDIV))
+#define EPLL_VAL	(32<<16)|(1<<8)|(2<<0)
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+
+#define CONFIG_SDRAM_AUTO_DETECT
+						/* Memoery Type mSDRAM or mDDR */
+#define CFG_BANK_CFG_VAL	0x0004920d
+#define CFG_BANK_CON1_VAL	0x04000040
+#define CFG_BANK_CFG_VAL_ALT	0x00048904
+#define CFG_BANK_CON1_VAL_ALT	0x04000040
+#define CFG_BANK_CFG_VAL_DDR2	0x00049253
+#define CFG_BANK_CON1_VAL_DDR2	0x44000040
+
+#define CFG_BANK_CON2_VAL	0x0057003a
+#define CFG_BANK_CON2_VAL_DDR2	0x005d0035
+#define CFG_BANK_CON3_VAL	0x80000030
+#define CFG_BANK_REFRESH_VAL	0x00000313
+
+#define CONFIG_NR_DRAM_BANKS	1	   /* we have 2 bank of DRAM */
+#define PHYS_SDRAM_1		MEMORY_BASE_ADDRESS /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x04000000 /* 64 MB */
+
+#define CFG_FLASH_BASE		0x08000000
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	1024
+#define CONFIG_AMD_LV800
+#define PHYS_FLASH_SIZE		0x100000
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(5*CONFIG_SYS_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(5*CONFIG_YSY_HZ) /* Timeout for Flash Write */
+
+#define CONFIG_ENV_SIZE		    0x20000	    /* 1 block save Environment */
+#define CONFIG_ENV_OFFSET 		0x00040000  /* The first 2 blocks save uboot, then the Bootloader Environment */
+
+/*
+ * SMDK2416 board specific data
+ */
+
+#define CONFIG_IDENT_STRING	" for SMDK2416"
+
+/* total memory required by uboot */
+#define CFG_UBOOT_SIZE		(2*1024*1024)
+
+/* base address for u-boot */
+#ifdef CONFIG_ENABLE_MMU
+#define CFG_UBOOT_BASE		0xc3e00000
+#else
+#define CFG_UBOOT_BASE		0x33e00000
+#endif
+#define CFG_PHY_UBOOT_BASE	(MEMORY_BASE_ADDRESS + 0x3e00000)
+
+/* NAND configuration */
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		(0x4e000000)
+#define CFG_NAND_HWECC 
+#define CONFIG_NAND_BL1_8BIT_ECC
+#define NAND_MAX_CHIPS		1
+#define NAND_DISABLE_CE()	(NFCONT_REG |= (1 << 1))
+#define NAND_ENABLE_CE()	(NFCONT_REG &= ~(1 << 1))
+#define NF_TRANSRnB()		do { while(!(NFSTAT_REG & (1 << 0))); } while(0)
+
+/* Boot configuration */
+#define CONFIG_BOOT_NAND
+
+/* Settings as above boot configuration */
+#if defined(CONFIG_BOOT_NAND)
+#define CONFIG_ENV_IS_IN_NAND
+#define CFG_NAND_LARGEPAGE_SAVEENV
+//#define CONFIG_BOOTCOMMAND	"nand read c0008000 40000 1c0000;bootm c0008000"
+//#define CONFIG_BOOTARGS    	"root=ramfs devfs=mount console=ttySA0,9600" 
+#define CONFIG_ETHADDR		00:40:5c:26:0a:5b
+#define CONFIG_NETMASK      255.255.255.0
+#define CONFIG_IPADDR		10.78.28.114
+#define CONFIG_SERVERIP		10.78.28.15
+#define CONFIG_GATEWAYIP	10.78.28.01
+#endif
+
+#endif
diff -NBbur u-boot-2010.09-orig/include/image.h u-boot-2010.09-smdk2416/include/image.h
--- u-boot-2010.09-orig/include/image.h	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-smdk2416/include/image.h	2011-09-05 17:21:54.000000000 +0800
@@ -166,7 +166,8 @@
 #define IH_COMP_LZMA		3	/* lzma  Compression Used	*/
 #define IH_COMP_LZO		4	/* lzo   Compression Used	*/
 
-#define IH_MAGIC	0x27051956	/* Image Magic Number		*/
+//#define IH_MAGIC	0x27051956	/* Image Magic Number		*/
+#define IH_MAGIC    0x534C4847  /* Image Magic Number,SLHG, modify by guoqingdong */
 #define IH_NMLEN		32	/* Image Name Length		*/
 
 /*
diff -NBbur u-boot-2010.09-orig/include/linux/mtd/mtd-abi.h u-boot-2010.09-smdk2416/include/linux/mtd/mtd-abi.h
--- u-boot-2010.09-orig/include/linux/mtd/mtd-abi.h	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-smdk2416/include/linux/mtd/mtd-abi.h	2011-09-01 15:26:34.000000000 +0800
@@ -126,6 +126,10 @@
 	uint32_t eccpos[128];
 	uint32_t oobavail;
 	struct nand_oobfree oobfree[MTD_MAX_OOBFREE_ENTRIES];
+    
+    /* XXX U-BOOT XXX, Add by guoqingdong */
+    uint32_t useecc;
+    uint32_t reserved;
 };
 
 /**
diff -NBbur u-boot-2010.09-orig/include/linux/mtd/mtd.h u-boot-2010.09-smdk2416/include/linux/mtd/mtd.h
--- u-boot-2010.09-orig/include/linux/mtd/mtd.h	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-smdk2416/include/linux/mtd/mtd.h	2011-09-01 17:38:08.000000000 +0800
@@ -44,9 +44,9 @@
    specific to any particular block. */
 struct erase_info {
 	struct mtd_info *mtd;
-	uint64_t addr;
-	uint64_t len;
-	uint64_t fail_addr;
+	uint32_t addr;
+	uint32_t len;
+	uint32_t fail_addr;
 	u_long time;
 	u_long retries;
 	u_int dev;
